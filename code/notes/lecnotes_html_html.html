<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>
<!--|Using lwarp|lecnotes_html.html|-->


<div class="bodywithoutsidetoc">


<main class="bodycontainer">


<section class="textbody">

<a id="lecnotes_html-autofile-0"></a>

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<a id="lecnotes_html-autopage-1"></a>
</section>

</main>

</div>

</body>
</html>
<!--|Start file|ch1.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-3"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch1 ......
-->
<h3 id="autosec-4">Chapter&nbsp;<span class="sectionnumber">1&#x2003;</span>Introduction. How to detect and correct errors?</h3>
<a id="lecnotes_html-autopage-4"></a>
<a id="lecnotes_html-autofile-1"></a>

<p>
Version 2022-09-24. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<!--
...... section Preface ......
-->
<h4 id="autosec-5">Preface</h4>
<a id="lecnotes_html-autopage-5"></a>


<p>
These notes are being revised to reflect the content of the course as taught in the 2022/23 academic year. Questions and comments on these lecture notes should be directed to<br />
<kbd>Yuri.Bazlov@manchester.ac.uk</kbd>.
</p>
<!--
...... subsection Synopsis ......
-->
<h5 id="autosec-6">Synopsis</h5>
<a id="lecnotes_html-autopage-6"></a>


<p>
<i>We discuss information transmission and introduce the most basic notions of Coding Theory: <b>channel</b>, <b>alphabet</b>, <b>symbol</b>, <b>word</b>, <b>Hamming distance</b> and of course <b>code</b>. We show how a code can
detect and correct some errors that occur during transmission.</i>
</p>
<!--
...... subsection What is information? ......
-->
<h5 id="autosec-7">What is information?</h5>
<a id="lecnotes_html-autopage-7"></a>


<p>
It is fair to say that our age is the age of information. Huge quantities of information and data literally flow around us and are stored in various forms.
</p>

<p>
Information processing gives rise to many mathematical questions. Information needs to be processed because we may need, for example, to:
</p>
<ul style="list-style-type:none">

<li>
<p>
• <em>store</em> the information;
</p>


</li>
<li>


<p>
• <em>encrypt</em> the information;
</p>


</li>
<li>


<p>
• <em>transmit</em> the information.
</p>
</li>
</ul>

<p>
For practical purposes, information needs to be stored efficiently, which leads to problems such as <em>compacting</em> or <em>compressing</em> the information. For the purposes of data protection and security, information may need to be
<em>encrypted</em>. We will NOT consider these problems here.
</p>

<p>
In this course, we will address problems that arise in connection with <em>information transmission</em>.
</p>

<p>
We do not attempt to give an exhaustive definition of <i>information</i>. Whereas some mathematical models for space, time, motion were developed hundreds of years ago, the modern mathematical theory of information was only born in 1948 in
the paper <i>A Mathematical Theory of Communication</i> by <b>Claude Shannon</b> (1916–2001). The following will be enough for our purposes:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-8"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (information, alphabet, symbol)</span>.
</p>

<p>
Fix a finite set \(F\) and call it <b><i>the alphabet</i></b>.
</p>

<p>
Elements of \(F\) are called <b><i>symbols</i></b>.
</p>

<p>
By <b><i>information</i></b>, we mean a stream (a sequence) of symbols.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-9"></a>
<span class="amsthmnamedefinition">Remark</span>.        The alphabet should contain at least two symbols, otherwise any sequence of symbols will contain zero information. The philosophical explanation for this is: if there is only one possible we
know each symbol in the sequence, hence reading the sequence does not give us any new knowledge.
</p>

</li>

</ul>

</div>
<!--
...... subsection What does it mean to transmit information? What is a channel?                   ......
-->
<h5 id="autosec-10">What does it mean to transmit information? What is a channel?</h5>
<a id="lecnotes_html-autopage-10"></a>


<p>
It means that symbols are sent by one party (the sender) and are received by another party (receiver). The symbols are transmitted via some medium, which we will in general refer to as <b><i>the channel</i></b>. More precisely, the channel is a
mathematical abstraction of various real-life media such as a telephone line, a satellite communication link, a voice (in a face to face conversation between individuals), a CD (the sender writes information into it — the user reads the information from
it), etc.
</p>

<p>
In this course we will assume that when a symbol is fed into the channel (the input symbol), the same or another symbol is read from the other end of the channel (the output symbol). Thus, we will only consider channels where neither erasures
(when the output symbol is unreadable) nor deletions (when some symbols fed into the channel simply disapear) occur. Working with those more general channels requires more advanced mathematical apparatus which is beyond this course.
</p>

<p>
Importantly, we assume that there is <b><i>noise</i></b> in the channel, which means that the symbols are randomly changed by the channel. Our <b><i>simple model of information transmission</i></b> is thus as follows:
</p>

<p>
\[ \fbox {sender} \xrightarrow {\text {stream of symbols}} \fbox {channel} \xrightarrow [\text {with random changes}]{\text {stream of symbols}} \fbox {receiver} \]
</p>

<p>
When a single symbol \(x\in F\) is being transmitted, there are two possible outcomes:
</p>
<ul style="list-style-type:none">

<li>
<p>
• The received symbol is \(x\). We say that no error occurred in this symbol.
</p>


</li>
<li>


<p>
• The received symbol is \(y\ne x\). An error occurred in this symbol.
</p>
</li>
</ul>

<p>
We will now give the most basic example of a channel, \(\mathit {BSC}(p)\). There are other mathematical models of channels, but \(\mathit {BSC}(p)\) is the only one we study systematically in the course.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (binary alphabet, bit)</span>.   The <b><i>binary alphabet</i></b> is the set \(\F _2=\{0,1\}\). A <b><i>bit</i></b> is the same as
<b><i>binary symbol</i></b>, an element of the binary alphabet.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-12"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (\(\mathit {BSC}(p)\))</span>.                 The <b><i>binary symmetric channel with bit error rate \(p\)</i></b>, denoted \(\mathit {BSC}(p)\), is
a channel which transmits binary symbols according to the following rule. A bit (\(0\) or \(1\)), transmitted via the channel, arrives unchanged with probability \(1-p\), and gets flipped with probability \(p\):
</p>
<div class="center">

<p>


<a href="bsc.svg" target="_blank" ><img
      src="bsc.svg"
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

<p>
The error in any given bit is an event which is independent of all the previous bits. We thus say that this channel is <b><i>memoryless</i></b>.
</p>

</li>

</ul>

</div>
<!--
...... subsection What is a code? ......
-->
<h5 id="autosec-14">What is a code?</h5>
<a id="lecnotes_html-autopage-14"></a>


<p>
Generally, a word is a finite sequence of symbols, and a code is a set of words. However, in this course we will only consider <i>block codes</i> — this means that all the words in the code are of the same length \(n\). Although variable length codes
are used in modern applications, we will not consider them in the course, and will refer to block codes simply as codes.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (word)</span>.
</p>

<p>
A <i><b>word of length \(n\)</b></i> in the alphabet \(F\) is an element of \(F^n\). Note that \(F^n\) is the set of all \(n\)-tuples of symbols:
</p>

<p>
\[ F^n=\{\ul v=(v_1,v_2,\ldots ,v_n)\mid v_i\in F,\ 1\le i \le n\}.           \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
We may write a word \((x_1,x_2,\dots ,x_n)\in F^n\) simply as \(x_1x_2\dots x_n\) if this is unambiguous. So, for example, the binary words \(000\), \(101\) and \(111\) belong to \(\F _2^3\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-16"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (code, codeword)</span>.   A <i><b>code</b></i> of length \(n\) in the alphabet \(F\) is a non-empty subset of \(F^n\). We will denote a code by
\(C\). That is, \(C\subseteq F^n\), \(C\ne \varnothing \).
</p>

<p>
A <i><b>codeword</b></i> is an element of the code.
</p>

</li>

</ul>

</div>

<p>
Our next goal is to understand how codes are used to detect and correct errors occurring in transmission.
</p>
<!--
...... subsection How can a code detect errors? ......
-->
<h5 id="autosec-17">How can a code detect errors?</h5>
<a id="lecnotes_html-autopage-17"></a>


<p>
Instead of transmitting an arbitrary stream of symbols via the channel, the sender and the receiver agree to transmit <b>only codewords</b>.
</p>

<p>
\[ \fbox {sender} \xrightarrow [\ul c\in C]{\text { codeword }} \fbox {channel} \xrightarrow [\ul y\in F^n]{\text { received word }} \fbox {receiver} \]
</p>

<p>
The sender transmits a codeword \(\ul c\in C\). The received word, \(\ul y\), may be not the same as \(\ul c\), due to noise in the channel. Of course, if \(\ul y\notin C\), the receiver knows that \(\ul y\) is not what was sent. If, however,
\(\ul y\in C\), the receiver has no way of knowing whether an error occurred, and must assume that there was no error. Here is the terminology we will use:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-18"></a>
<span class="amsthmnamedefinition">Definition</span>.     Transmission outcomes:
</p>
<ul style="list-style-type:none">


<li>
<p>
• If \(\ul y\notin C\), we say that a <b><i>detected error</i></b> occurred.
</p>
</li>
<li>


<p>
• If \(\ul y \in C\) but \(\ul y\ne \ul c\), we speak of an <i><b>undetected error</b></i>.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
At this stage, we informally notice that if the codewords of \(C\) are “far apart”, then a small number of symbol errors will not change a codeword into another codeword, so the errors will be detected. We quantify this in Theorem&nbsp;<a
href="ch2.html#thm:detect-correct">2.1</a> below. For this, we need a way to measure the distance between words. The following definition is credited to <b>Richard Hamming</b> (1915–1998), whose first construction of more efficient codes
was the beginning of modern coding theory.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-19"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (Hamming distance)</span>.           The <i><b>Hamming distance</b></i> between two words \(\ul x,\ul y\in F^n\) is the number of positions
where the symbol in \(\ul x\) differs from the symbol in \(\ul y\):
</p>

<p>
\[ d(\ul x, \ul y) = \#\{i\in \{1,\ldots ,n\} :        x_i\ne y_i\}.   \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
For example, in the set \(\F _2^3\) of \(3\)-bit binary words one has \(d(101,111)=1\) and \(d(101,000)=2\). Of course, \(d(101,101)=0\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Lemma</span><span class="amsthmnumberdefinition"> <span class="textup">1.1</span></span><span class="amsthmnotedefinition"> (Properties of the Hamming distance)</span>.
</p>

<p>
For any words \(\ul x, \ul y, \ul z\in F^n\),
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(d(\ul x,\ul y)\ge 0\); \(d(\ul x,\ul y)= 0\) iff \(\ul x = \ul y\).
</p>


</li>
<li>


<p>
2. \(d(\ul x,\ul y)=d(\ul y,\ul x)\).
</p>


</li>
<li>


<p>
3. \(d(\ul x,\ul z)\le d(\ul x,\ul y)+d(\ul y,\ul z)\) (<b><i>the triangle inequality</i></b>).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Remark</span>.     A function \(d(-,-)\) of two arguments which satisfies axioms 1.–3. is called a <em>metric</em>. This is familiar to those who studied <em>Metric spaces</em>. The Lemma says that the
Hamming distance turns \(F^n\) into a metric space.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-22"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> For this proof only, write \(d(\ul x, \ul y) = \sum _{i=1}^n d_{x_i,y_i}\) where \(d_{ab}=\begin {cases} 1, &amp; \text {if }a\ne b, \\ 0, &amp;\text { if }a=b.              \end {cases}\).
</p>

<p>
1. Since \(d_{x_i,y_i}\in \{0,1\}\), the sum \(\sum _{i=1}^n d_{x_i,y_i}\) is an integer between \(0\) and \(n\), and is \(0\) iff \(d_{x_i,y_i}=0\) for all \(i\) meaning that \(\ul x=\ul y\).
</p>

<p>
2. Symmetry is clear as \(x_i\ne y_i\) is equivalent to \(y_i\ne x_i\).
</p>

<p>
3. The inequality \(d_{x_i,z_i}\le d_{x_i,y_i}+ d_{y_i,z_i}\) holds for all \(i\): it is obvious when \(d_{x_i,y_i}\) or \(d_{y_i,z_i}\) is \(1\), and if \(d_{x_i,y_i}=d_{y_i,z_i}=0\) then \(x_i=y_i=z_i\) and so \(d_{x_i,z_i}=0\).
Summing over \(i=1,\dots ,n\) gives the required triangle inequality. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We will now use the Hamming distance to set up error correction.
</p>
<!--
...... subsection How can a code correct errors? ......
-->
<h5 id="autosec-23">How can a code correct errors?</h5>
<a id="lecnotes_html-autopage-23"></a>


<p>
Let \(C\subseteq F^n\) be a code.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-24"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (decoder, nearest neighbour)</span>.           A <b><i>decoder</i></b> for \(C\) is a function \(\Decode \colon F^n\to C\) such that for any \(\ul
y\in F^n\), \(\Decode (\ul y)\) is a nearest neighbour of \(\ul y\) in \(C\).
</p>

<p>
A <b><i>nearest neighbour</i></b> of \(\ul y\in F^n\) in \(C\) is a codeword \(\ul c\in C\) such that
</p>

<p>
\[ d(\ul c,\ul y) = \min \{d(\ul z,\ul y):        \ul z\in C\}.   \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
In order to use error correction, the sender and the receiver choose a decoder \(\Decode \colon F^n\to C\). (It may happen that some words \(\ul y\in F^n\) have more than one nearest neighbour in \(C\), which means that there exist more than
one decoder function. In this course we assume that the receiver fixes one particular decoder to make decoding deterministic.)
</p>

<p>
The sender transmits codewords of \(C\).
</p>

<p>
The receiver <i>decodes</i> the received words:
</p>

<p>
\[ \fbox {sender} \xrightarrow [\ul c\in C]{\text { codeword }} \fbox {channel} \xrightarrow [\ul y\in F^n]{\text { received word }} \xrightarrow [\ \Decode (\ul y)\in C\ ]{\text { decoded word }} \fbox {receiver}
\]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Remark</span>.           Thus, if the received word \(\ul y\) is not a codeword, the decoder must assume that the codeword closest to \(\ul y\) was sent. This means that the following assumption is made about
the channel: <i>out of all error patterns which may have resulted in receiving \(\ul y\), the pattern with fewest symbol errors is the most likely one.</i>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-26"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (decoded correctly)</span>.               In the above setup, let \(\ul c\in C\) be the transmitted codeword and let \(\ul y\in F^n\) be the received word.
If \(\Decode (\ul y)=\ul c\), we say that the received word is <i><b>decoded correctly</b></i>.
</p>

</li>

</ul>

</div>

<p>
The following Claim shows that the error-correcting setup makes sense — at least, if <i>no</i> symbol errors occurred in a codeword, the decoder will not introduce errors! Strictly speaking, the Claim is unnecessary, because it will follow from a
theorem given later.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-27"></a>
<span class="amsthmnamedefinition">Claim</span>.   <b><i>A codeword is its own unique nearest neighbour</i>:</b> indeed, \(d(-,-)\) is non-negative hence \(d(\ul c,\ul c)=0=\min \{d(\ul z,\ul c):   \ul z\in C\}\). Therefore,
<i><b>a codeword is always decoded to itself:</b></i>
</p>

<p>
\[ \ul y\in C\quad \implies \quad \Decode (\ul y)=\ul y.   \]
</p>

<p>


</p>

</li>

</ul>

</div>
<!--
...... subsection Concluding remarks for Chapter 1 ......
-->
<h5 id="autosec-28">Concluding remarks for Chapter 1</h5>
<a id="lecnotes_html-autopage-28"></a>


<p>
Codes have been used for error correction for thousands of years: a natural language is essentially a code! If we “receive” a corrupted English word such as PHEOEEM, we will assume that is has most likely been THEOREM, because this would
involve fewest mistakes.
</p>

<p>
<i>The following examples are part of historical background to Coding Theory and are not covered in lectures.</i>
</p>
<!--
...... subsection Example 1 ......
-->
<h5 id="autosec-29">Example 1</h5>
<a id="lecnotes_html-autopage-29"></a>


<p>
Here is a real-world example of how Coding Theory is used in scientific research.
</p>
<figure id="autoid-1" class="figure ">
<div class="center">

<p>

<a href="voyager1.jpg" target="_blank" ><img
    src="voyager1.jpg"
    class="inlineimage"
    alt="(image)"
></a>
</p>


<div class="figurecaption">
<p>
Figure 1.1:&nbsp;The Voyager spacecraft. Image taken from <a href="https://voyager.jpl.nasa.gov/mission/spacecraft/instruments/" target="_blank" >https://voyager.jpl.nasa.gov/mission/spacecraft/instruments/</a>
</p>
</div>

</div>

</figure>

<p>
<i>Voyager 1</i> is an unmanned spacecraft launched by NASA in 1977. Its primary mission was to explore Jupiter, Saturn, Uranus and Neptune. Voyager 1 sent a lot of precious photographs and data back to Earth. It has recently been in the
news because the NASA scientists had concluded that it <i>reached the interstellar space</i>.
</p>

<p>
The messages from Voyager 1 have to travel through the vast expanses of interplanetary space. Given that the spacecraft is equipped with a mere 23 Watt radio transmitter (powered by a plutonium-238 nuclear battery), it is inevitable that noise,
such as cosmic rays, interferes with its transmissions. In order to protect the data from distortion, it is encoded with the error-correcting code called <i>extended binary Golay code</i>. We will look at this code later in the course. More modern
space missions employ more efficient and more sophisticated codes.
</p>
<!--
...... subsection Example 2 ......
-->
<h5 id="autosec-31">Example 2</h5>
<a id="lecnotes_html-autopage-31"></a>


<p>
Here is a more down-to-earth example of the use of error-correcting codes. A CD can hold up to 80 minutes of music, represented by an array of zeros and ones. The data on the CD is encoded using a <i>Reed-Solomon code</i>. This way, even if a
small scratch, a particle of dust or a fingerprint happens to be on the surface of the CD, it will still play perfectly well — all due to error correction.
</p>

<p>
However, every method has its limits, and larger scratches or stains may lead to something like a thunderclap during playback!
</p>
<!--
...... subsection Example 3 ......
-->
<h5 id="autosec-32">Example 3</h5>
<a id="lecnotes_html-autopage-32"></a>


<p>
To finish this historical excursion, let us recall one of the very first uses of error-correcting codes.
</p>

<p>
In 1948, Richard Hamming was working at the famous <i>Bell Laboratories</i>. Back then, the data for “computers” was stored on <i>punch cards</i>:
</p>
<figure id="autoid-2" class="figure ">
<div class="center">

<p>

<a href="punch-card.png" target="_blank" ><img
    src="punch-card.png"
    class="inlineimage"
    alt="(image)"
></a>
</p>


<div class="figurecaption">
<p>
Figure 1.2:&nbsp;A punch card. Image from <a href="http://www.columbia.edu/cu/computinghistory" target="_blank" >http://www.columbia.edu/cu/computinghistory</a>
</p>
</div>

</div>

</figure>

<p>
pieces of thick paper where holes represented ones and absences of holes represented zeros. Punchers who had to perforate punch cards sometimes made mistakes, which frustrated Hamming.
</p>

<p>
Hamming was able to come up with a code with the following properties: each codeword is 7 bits long, and if one error is made in a codeword (i.e., one bit is changed from 0 to 1 or vice versa), one can still recover the original codeword. This made
the punch card technology more robust, as a punch card with a few mistakes would still be usable. The trade-off, however, was that the length of data was increased by 75%: there are only 16 different codewords, therefore, they can be used to convey
messages which have the length of 4 bits.
</p>

<p>
The original <i>Hamming code</i> will be introduced in the course soon!
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch1ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-35"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch1ex ......
-->
<h3 id="autosec-36">Chapter&nbsp;<span class="sectionnumber">1&#x2003;</span>Exercises </h3>
<a id="lecnotes_html-autopage-36"></a>
<a id="lecnotes_html-autofile-2"></a>

<p>
Version 2022-09-24. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.1</span></span>.                    The <b>Manchester code</b> was first used in the Manchester Mark 1 computer at the University
of Manchester in 1949 and is still used in low-speed data transfer: e.g. TV remote sending signals via infrared. This binary code consists of two codewords: \(10\) and \(01\). The codeword \(10\) is interpreted by the recipient as the message \(0\),
and \(01\) is understood to mean \(1\); whereas the received word \(00\) or \(11\) indicates a detected error.
</p>

<p>
The following error-free fragment of a bit stream encoded by Manchester code (that is: the stream is a sequence of codewords) had been intercepted: \(\dots 010101x01011010\dots \) What was the bit \(x\)?
</p>

</li>

</ul>

</div>

<p>
[<a href="ch1exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.2</span></span>.               Consider the alphabet \(\mathbb Z_{10}=\{0,1,2,3,4,5,6,7,8,9\}\). The <b>Luhn
checksum</b> of a word \(x_1x_2\dots x_{16}\in (\mathbb Z_{10})^{16}\) is \(\pi (x_1)+x_2+\pi (x_3)+x_4+\pi (x_5)+\dots +x_{16}\text { mod } 10\), viewed as an element of \(\mathbb Z_{10}\). Here \(\pi \colon \mathbb
Z_{10}\to \mathbb Z_{10}\) is defined by the rule “\(\pi (a)\) is the sum of digits of \(2a\)”. The <b>Luhn code</b> consists of all words in \((\mathbb Z_{10})^{16}\) whose Luhn checksum is \(0\).
</p>

<p>
(i) Write down all values of \(\pi \) and check that \(\pi \) is a permutation of the alphabet \(\mathbb Z_{10}\).
</p>

<p>
(ii) Find the total number of codewords of the Luhn code.
</p>

<p>
(iii) Prove that a single digit error is detected by the Luhn code.
</p>

<p>
(iv) Look at your 16-digit debit/credit card numbers. Are they codewords of the Luhn code? If you have a card with a number which is <b>not</b> a codeword of the Luhn code, can you bring it to the tutorial? Thanks!
</p>

</li>

</ul>

</div>

<p>
[<a href="ch1exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.3</span></span>. (<i>based on a question from a past exam. Not done in the tutorial.</i>). Alice transmitted the same
binary word of length 6 to Bob three times, but Bob received three different words: \(101010\), \(011100\), \(110001\). Engineer Clara told Bob that at most two bit errors could have occurred in each word during transmission. Help Bob to recover
the word transmitted by Alice.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch1exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.4</span></span>.   (<i>not done in the tutorial.</i>) <a id="ex:simplex"></a>Recall that the binary alphabet is \(\F
_2=\{0,1\}\). Let the code \(\Sigma \subseteq \F _2^7\) consist of the following eight words:
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1.</td>
</tr>
</table>

<p>
Show that the Hamming distance between each pair of codewords is the same. (You will probably have to use brute force as we are yet to describe an algebraic structure behind this code.)
</p>

<p>
What is \(\Decode (0001110)\)? Give an example of a word which has more than one nearest neighbour in \(\Sigma \). Try to see if there are words with three, four etc. nearest neighbours. Try to write a word with a maximum possible number of
nearest neighbours in \(\Sigma \).
</p>

</li>

</ul>

</div>

<p>
[<a href="ch1exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch1exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-8"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch1exans ......
-->
<h3 id="autosec-9">Chapter&nbsp;<span class="sectionnumber">1&#x2003;</span>Exercises — solutions</h3>
<a id="lecnotes_html-autopage-9"></a>
<a id="lecnotes_html-autofile-3"></a>

<p>
Version 2022-09-24. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.1</span></span>.                    The <b>Manchester code</b> was first used in the Manchester Mark 1 computer at the University
of Manchester in 1949 and is still used in low-speed data transfer: e.g. TV remote sending signals via infrared. This binary code consists of two codewords: \(10\) and \(01\). The codeword \(10\) is interpreted by the recipient as the message \(0\),
and \(01\) is understood to mean \(1\); whereas the received word \(00\) or \(11\) indicates a detected error.
</p>

<p>
The following error-free fragment of a bit stream encoded by Manchester code (that is: the stream is a sequence of codewords) had been intercepted: \(\dots 010101x01011010\dots \) What was the bit \(x\)?
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E1.1. </b> [<a href="ch1ex.html#.">These exercises without answers</a>]
</p>

<p>
In \(\dots 010101x01011010\dots \), notice that \(11\) cannot be a codeword. Therefore, the bit stream is split into codewords in the following way:
</p>

<p>
\[ \dots 0 | 10 | 10 | 1x | 01 | 01 | 10 | 10 | \dots .          \]
</p>

<p>
The codeword \(1x\) must be \(10\) so \(x=0\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.2</span></span>.                 Consider the alphabet \(\mathbb Z_{10}=\{0,1,2,3,4,5,6,7,8,9\}\). The <b>Luhn
checksum</b> of a word \(x_1x_2\dots x_{16}\in (\mathbb Z_{10})^{16}\) is \(\pi (x_1)+x_2+\pi (x_3)+x_4+\pi (x_5)+\dots +x_{16}\text { mod } 10\), viewed as an element of \(\mathbb Z_{10}\). Here \(\pi \colon \mathbb
Z_{10}\to \mathbb Z_{10}\) is defined by the rule “\(\pi (a)\) is the sum of digits of \(2a\)”. The <b>Luhn code</b> consists of all words in \((\mathbb Z_{10})^{16}\) whose Luhn checksum is \(0\).
</p>

<p>
(i) Write down all values of \(\pi \) and check that \(\pi \) is a permutation of the alphabet \(\mathbb Z_{10}\).
</p>

<p>
(ii) Find the total number of codewords of the Luhn code.
</p>

<p>
(iii) Prove that a single digit error is detected by the Luhn code.
</p>

<p>
(iv) Look at your 16-digit debit/credit card numbers. Are they codewords of the Luhn code? If you have a card with a number which is <b>not</b> a codeword of the Luhn code, can you bring it to the tutorial? Thanks!
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E1.2. </b> [<a href="ch1ex.html#.">These exercises without answers</a>]
</p>

<p>
(i) \(\pi \) is the following permutation of \(\mathbb Z_{10}\):
</p>

<p>
\[\begin {pmatrix}0&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9 \\ 0&amp;2&amp;4&amp;6&amp;8&amp;1&amp;3&amp;5&amp;7&amp;9\end {pmatrix}.                      \]
</p>

<p>
(ii) Every sequence of 15 digits is the beginning of exactly one Luhn codeword. Indeed, let \(x_1,\ldots ,x_{15}\in \mathbb Z_{10}\) be arbitrary. Calculate \(z=\pi (x_1)+x_2+\pi (x_3)+x_4+\pi (x_5)+\dots +\pi (x_{15})\). Then the one
and only Luhn codeword of the form \(x_1x_2\dots x_{15}x_{16}\) is determined by \(z+x_{16}\equiv 0\) mod 10. This is the same as \(x_{16}\equiv (-z) \text { mod }10\).
</p>

<p>
Therefore, the number of Luhn codewords is equal to the number of sequences of \(15\) digits, that is, \(10^{15}\).
</p>

<p>
(iii) If \(x_i\) is replaced by \(y_i\), then the Luhn checksum changes by \(y_i-x_i\) mod 10 (if \(i\) is odd) or by \(\pi (y_i)-\pi (x_i)\) mod 10 (if \(i\) is even). In any case, if \(y_i\ne x_i\), then neither of these changes is zero mod
\(10\), hence <i>altering a single digit changes the Luhn checksum</i>. A codeword has Luhn checksum 0, hence changing a single digit in a codeword gives a word with non-zero Luhn checksum, i.e., not a codeword, resulting in a detected error. In
particular, the minimum distance of the Luhn code is at least \(2\). (It is, in fact, \(2\) — you can easily write down two codewords at distance \(2\) from each other.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.3</span></span>. (<i>based on a question from a past exam. Not done in the tutorial.</i>). Alice transmitted the same
binary word of length 6 to Bob three times, but Bob received three different words: \(101010\), \(011100\), \(110001\). Engineer Clara told Bob that at most two bit errors could have occurred in each word during transmission. Help Bob to recover
the word transmitted by Alice.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E1.3. </b> [<a href="ch1ex.html#.">These exercises without answers</a>]
</p>

<p>
Let \(\ul z\) be the word sent by Alice. We are given that each one of the words
</p>

<p>
\[ \ul v_1=101010, \qquad \ul v_2=011100, \qquad \ul v_3=110001 \]
</p>

<p>
received by Bob contains at most two errors. To work out \(\ul z\), let’s try to see where the errors in \(\ul v_1\), \(\ul v_2\) and \(\ul v_3\) could have occurred. Write \(\ul v_1\), \(\ul v_2\) and \(\ul v_3\) as rows of a matrix:
</p>

<p>
\[ \begin {matrix} 1&amp;0&amp;1&amp;0&amp;1&amp;0 \\ 0&amp;1&amp;1&amp;1&amp;0&amp;0 \\ 1&amp;1&amp;0&amp;0&amp;0&amp;1 \end {matrix} \]
</p>

<p>
Note that each column of the matrix contains both \(0\)s and \(1\)s which cannot both be correct. Hence <i>each column contains at least one error</i>, and in total, there are at least \(6\) errors in the whole matrix. On the other hand, we are
given that there were <i>at most</i> \(6=2+2+2\) errors. Thus, there are exactly \(6\) errors in the matrix, and the only \(\ul z\) which guarantees \(6\) errors is the word which ensures that there is exactly one error per column — that is, the
“majority” bits in each column must be correct:
</p>

<p>
\[ \begin {matrix} &amp; 1&amp;0&amp;1&amp;0&amp;1&amp;0 \\ &amp; 0&amp;1&amp;1&amp;1&amp;0&amp;0 \\ &amp; 1&amp;1&amp;0&amp;0&amp;0&amp;1 \\ \hline \ul z= &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end
{matrix} \]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">1.4</span></span>.   (<i>not done in the tutorial.</i>) Recall that the binary alphabet is \(\F _2=\{0,1\}\). Let the
code \(\Sigma \subseteq \F _2^7\) consist of the following eight words:
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1,</td>
</tr>


<tr>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">0,</td>
</tr>


<tr>
<td class="tdc">0</td>
<td class="tdc">0</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">1</td>
<td class="tdc">0</td>
<td class="tdc">1.</td>
</tr>
</table>

<p>
Show that the Hamming distance between each pair of codewords is the same. (You will probably have to use brute force as we are yet to describe an algebraic structure behind this code.)
</p>

<p>
What is \(\Decode (0001110)\)? Give an example of a word which has more than one nearest neighbour in \(\Sigma \). Try to see if there are words with three, four etc. nearest neighbours. Try to write a word with a maximum possible number of
nearest neighbours in \(\Sigma \).
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E1.4. </b> [<a href="ch1ex.html#.">These exercises without answers</a>]
</p>

<p>
The Hamming distances between all pairs of distinct codewords can be found directly by looking at the 28 possible pairs. (The number of pairs of distinct codewords is \(M(M-1)/2\) where \(M=\#\Sigma \).)
</p>

<p>
This can be optimised by observing that the non-zero codewords are cyclic shifts of \(1001110\). Because applying a cyclic shift to both \(\ul v\) and \(\ul w\) does not change the Hamming distance between \(\ul v\) and \(\ul w\), it is enough
to only find the distance \(d(0000000,1001110)\) and the distance from \(1001110\) to all the other codewords. All distances turn out to be&nbsp;\(4\).
</p>

<p>
The nearest neighbour of \(0001110\) in \(\Sigma \) is \(1001110\) (by inspection), at distance 1. Hence \(\Decode (0001110)=1001110\).
</p>

<p>
The rest of the question is somewhat open-ended; we address it only partially. Here is an example of a word with <i>seven</i> nearest neighbours in \(\Sigma \): \(1111111\). All the non-zero codewords of \(\Sigma \) are at distance \(3\) from
this word. It looks as if there is no word equidistant from <i>all</i> codewords, i.e., with 8 nearest neighbours; check this!
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-7"></a>
<span class="amsthmnamedefinition">Remark</span>. More efficient ways of calculating the parameters of \(\Sigma \) (and other so-called <i>simplex codes</i>) will arise when we learn how to deal with linear codes, Hamming codes and cyclic
codes. To give you a hint: in \(\Sigma \), the <em>difference</em> of two codewords (viewed as vectors in \(\F _2^7\)) is again a codeword, so \(d=4\).
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch2.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-9"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch2 ......
-->
<h3 id="autosec-10">Chapter&nbsp;<span class="sectionnumber">2&#x2003;</span>Parameters. Channel coding. Bounds</h3>
<a id="lecnotes_html-autopage-10"></a>
<a id="lecnotes_html-autofile-4"></a>

<p>
Version 2022-10-11. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>           <a id="ch:basic"></a>
</p>

<p>
<b>Synopsis.</b> <i>Basic properties of a code \(C\) can be expressed by numbers called <b>parameters.</b> We learn why such parameters as the <b>rate</b>, \(R\), and the <b>minimum distance</b>, \(d(C)\), are important when \(C\) is
used for channel coding. We also learn to use the notation \((n,M,d)_q\) and \([n,k,d]_q\). It turns out that there is essentially a trade-off between the rate and the minimum distance: both cannot be high (good) at the same time. This trade-off is
expressed by inequalities known as <b>bounds</b>. We only prove the Hamming bound and the Singleton bound in this course, although other bounds have been obtained in coding theory research.</i>
</p>

<p>
We work with a finite alphabet \(F\) and denote by \(q\) the number of elements of \(F\): \(q=\#F\). We assume \(q\ge 2\).
</p>
<!--
...... subsection Parameters of a code ......
-->
<h5 id="autosec-11">Parameters of a code</h5>
<a id="lecnotes_html-autopage-11"></a>


<p>
Parameters are numerical characteristics of a code. Most important parameters are listed in the following
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-12"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (parameters of a code)</span>.
</p>

<p>
Let \(C\subseteq F^n\) be a code. Then:
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(n\) is the <b><i>length</i></b> of the code;
</p>


</li>
<li>


<p>
• \(M\) denotes the <b><i>number of codewords</i></b>, i.e., \(M=\#C\);
</p>


</li>
<li>


<p>
• \(k=\log _q M\) is the <b><i>information dimension</i></b> of \(C\)<br />
(<i>warning</i>: \(k\) may not be an integer, although we will see that \(k\) is an integer for all useful types of codes and should be an integer in the most common use case, see below);
</p>


</li>
<li>


<p>
• \(d(C) = \min \{ d(\ul v, \ul w):       \ul v,\ul w\in C, \ul v\ne \ul w\}\) is the <b><i>minimum distance</i></b> of \(C\) (already seen in the previous chapter);
</p>


</li>
<li>


<p>
• \(R=k/n\) is the <b><i>rate</i></b> of \(C\);
</p>


</li>
<li>


<p>
• \(\delta = d/n\) is the <b><i>relative distance</i></b> of \(C\).
</p>
</li>
</ul>

<p>
We say that \(C\) is <i><b>an \((n,M,d)_q\)-code</b></i> or <i><b>an \([n,k,d]_q\)-code</b></i>.
</p>

</li>

</ul>

</div>
<!--
...... subsection The minimum distance and the strength of error detection/correction ......
-->
<h5 id="autosec-13">The minimum distance and the strength of error detection/correction</h5>
<a id="lecnotes_html-autopage-13"></a>
<!--
......   paragraph Notation ......
-->


<p>
<span class="paragraph" id="autosec-14">Notation</span>
<a id="lecnotes_html-autopage-14"></a>
\([a]\) denotes the integer part of a real \(a\); e.g., \([3]=[3.5]=[\pi ]=3\), \([7.99]=7\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">2.1</span></span><span class="amsthmnotedefinition"> (The number of errors detected/corrected by a code)</span>.
<a id="thm:detect-correct"></a> Let \(C\) be a code with \(d(C)=d\). Throughout the course, \(t\) will denote \([ (d-1)/2]\). Let \(\ul v\in C\) and \(\ul y\in F^n\).
</p>

<p>
1. If \(1\le d(\ul v,\ul y)\le d-1\), then \(\ul y\notin C\). Thus, if at most \(d-1\) errors occur in a transmitted codeword, they will be <i>detected</i>.
</p>

<p>
2. If \(d(\ul v,\ul y)\le t\), then \(\ul y\) has a unique nearest neighbour in \(C\), which is \(\ul v\). Thus if at most \(t\) errors occur in a codeword, any decoder will <i>correct</i> them by decoding \(\ul y\) back to&nbsp;\(\ul c\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-16"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> 1. If \(\ul y\in C\) then by definition of minimum distance \(d(\ul v,\ul y)=0\) or \(d(\ul v,\ul y)\ge d\) so the statement follows by contrapositive.
</p>

<p>
2. We use proof by contradiction, so we must assume for contradiction that \(\ul w\) is a nearest neighbour of \(\ul y\) in \(C\) such that \(\ul w\ne \ul v\). Then \(d(\ul y,\ul w)\le d(\ul y,\ul v)\le t\) so by the triangle inequality
</p>

<p>
\[ 0 &lt; d(\ul v,\ul w)\le d(\ul v,\ul y)+d(\ul y,\ul w)\le t+t=2t\le d-1.          \]
</p>

<p>
This contradicts \(d\) being the minimum distance of \(C\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-17"></a>
<span class="amsthmnamedefinition">Remark</span>.   The Theorem is expressed by saying that <i>a code of minimal distance \(d\) detects up to \(d-1\) errors and corrects up to \([(d-1)/2]\) errors in a codeword.</i>
</p>

</li>

</ul>

</div>
<!--
...... subsection Channel coding. The meaning of rate ......
-->
<h5 id="autosec-18">Channel coding. The meaning of rate</h5>
<a id="lecnotes_html-autopage-18"></a>


<p>
To understand why the information dimension \(k\) and hence the rate \(R\) are defined via logarithm, we consider the most common use case known as <i><b>channel coding</b></i>. Information is transmitted via a noisy channel, and one
wants to detect or correct errors.
</p>

<p>
Information may contain arbitrary sequences of symbols, not just codewords. However, to take advantage error detection and correction, the sender must send only codewords. This is achieved in the following workflow:
</p>
<ul style="list-style-type:none">

<li>
<p>
• The information stream is split up into chunks, called <b><i>messages</i></b>. In this course we assume that all messages have the same length \(k\), hence lie in \(F^k\).
</p>


</li>
<li>


<p>
• We set up an injective function
</p>
<p>
\[ \Encode \colon F^k\to C \]
</p>
<p>
called the <b><i>encoder</i></b>. By the Pigeonhole Principle, such a function can exist only if \(k\le n\).
</p>


</li>
<li>


<p>
• When a message \(\ul m\in F^k\) arrives, the sender replaces it with the codeword \(\ul c = \Encode (\ul m)\) and sends \(\ul c\) into the channel.
</p>


</li>
<li>


<p>
• The received word \(\ul y\in F^n\) is either tested to see if \(\ul y\in C\) (<i>error detection</i>) or fed into the function \(\Decode \colon F^n\to C\) (<i>error correction</i>).
</p>


</li>
<li>


<p>
• Codewords not in the image of \(\Encode \) are never transmitted so assume \(\Encode \) is surjective hence bijective and \(\#C=\#F^k\). The receiver <b><i>unencodes</i></b> the decoded codeword to a message, applying the function
\(\Encode ^{-1}\colon C \to F^k\).
</p>
</li>
</ul>

<p>
The workflow is illustrated by the following diagram:
</p>

<p>
\[ \fbox {sender} \xrightarrow [\text { message }]{\ul m} \xrightarrow [\text { codeword }]{\ \Encode (\ul m)\ } \fbox {channel} \xrightarrow [\text { word }]{\text { received }} \xrightarrow {\ \Decode ()\ }
\xrightarrow {\ \Encode ^{-1}()\ } \fbox {receiver} \]
</p>

<p>
The cardinality of \(F^k\) is \(q^k\), because a word \((u_1,u_2,\dots ,u_k)\in F^k\) can be chosen in \(q^k\) ways: \(q\) choices for \(u_1\), \(q\) independent choices for \(u_2\) and so on, hence
</p>

<p>
\[ M = \# C = q^k \qquad \iff \qquad k = \log _q M. \]
</p>

<p>
We note that <i>in the typical use case, the information dimension \(k\) is an integer</i> (the number of symbols in a message).
</p>

<p>
We also note that the rate \(R\) is the ratio of “useful information” carried by a codeword (the number of symbols in a message) to the length of the codeword (the total number of symbols which need to be transmitted, per message). One always has
\(R\le 1\). When a code of rate \(R\) is used, the total number of symbols is \(R^{-1}\) times greater than the number of symbols in unencoded information.
</p>

<p>
Thus, encoding increases transmission costs. This is a price to pay for error detection and correction.
</p>
<!--
...... subsection Bounds ......
-->
<h5 id="autosec-19">Bounds</h5>
<a id="lecnotes_html-autopage-19"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">2.2</span></span><span class="amsthmnotedefinition"> (trivial bound)</span>.   <a
id="prop:trivialbound"></a> If \([n,k,d]_q\)-codes exist, \(k\le n\) and \(d\le n\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-21"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(C\) be an \([n,k,d]_q\)-code. Then, by definition, \(C\) is a non-empty subset of \(F^n\) with \(\#F=q\). The cardinality of a set is greater than or equal to the cardinality of its subset. In
particular, \(M=\#C\le \#F^n=q^n\). Applying the monotone function \(\log _q\) to both sides of the inequality, we obtain \(k=\log _q M \le n\). (<i>By the way, the equality \(k=n\) is attained only if \(C=F^n\), i.e., \(C\) is a trivial code.</i>)
</p>

<p>
Furthermore, as noted earlier, the Hamming distance between any two words of length \(n\) is an integer between \(0\) and \(n\). Therefore, \(0&lt;d(C)\le n\) for any code of length \(n\). (<i>The equality \(d=n\) can be attained by non-trivial
codes, for example \(\text {Rep}(n,F)\).</i>) <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
To state the next bound, we recall that \(\binom {n}{i}\) is the number of ways to choose \(i\) positions out of \(n\). This integer is called the binomial coefficient. It is given by the formula \(\binom n i = \frac {n!}{(n-i)!\,i!} = \frac
{n(n-1)\ldots (n-i+1)}{1\cdot 2\cdot \ldots \cdot i}\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-22"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">2.3</span></span><span class="amsthmnotedefinition"> (Hamming bound)</span>.   <a id="thm:HB"></a> If
\((n,M,d)_q\)-codes exist, \(\displaystyle \smash {M\le \frac {q^ n}{ \sum \limits _{i=0}^t \binom {n}{i}(q-1)^i}} \) where \(t=\left [ (d-1)/2 \right ]\).
</p>

</li>

</ul>

</div>

<p>
Before proving the Theorem, we introduce
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-23"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (Hamming sphere)</span>.
</p>

<p>
If \(\ul y\in F^n\) and \(0\le r\le n\), the set
</p>

<p>
\[ S_r(\ul y)=\{\ul v\in F^n:    d(\ul v,\ul y)\le r\}.   \]
</p>

<p>
is the <b><i>Hamming sphere</i></b> with centre \(\ul y\) and radius \(r\).
</p>

</li>

</ul>

</div>
<!--
...... subsection ......
-->
<h5 id="autosec-24"></h5>
<a id="lecnotes_html-autopage-24"></a>


<p>
The number of words in the Hamming sphere of radius \(r\) does not depend on the centre, \(\ul y\), of the sphere and is found as follows.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Lemma</span><span class="amsthmnumberdefinition"> <span class="textup">2.4</span></span><span class="amsthmnotedefinition"> (The cardinality of a Hamming sphere)</span>.   <a
id="lem:S_r"></a> \(\displaystyle {\#S_r(\ul y)=\sum _{i=0}^r \binom {n}{i}(q-1)^i} \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-26"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> To construct a word \(\ul v\) at distance \(i\) from \(\ul y\), we need to choose \(i\) positions out of \(n\) where \(\ul y\) will differ from \(\ul v\). Then we need to change the symbol in each
of the \(i\) chosen positions to one of the other \(q-1\) symbols. The total number of choices for \(\ul v\) which is at distance exactly \(i\) from \(\ul y\) is thus \(\binom {n}{i}(q-1)^i\).
</p>

<p>
The Hamming sphere contains all vectors at distance \(0\le i\le r\) from \(\ul v\), so we sum over \(i\) from \(0\) up to \(r\). The Lemma is proved. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-27"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><b>Proof of Theorem <a href="ch2.html#thm:HB">2.3</a></b>.</span> First of all, we prove that spheres of radius \(t\) centred at distinct codewords \(\ul c\) do not overlap. Indeed, by Theorem <a
href="ch2.html#thm:detect-correct">2.1</a>(2), each word in \(S_t(\ul c)\) has unique nearest neighbour, which is \(\ul c\). Hence a word in \(S_t(\ul c)\) cannot lie in another such sphere (a word cannot have two <i>unique</i> nearest
neighbours!)
</p>

<p>
Therefore, the whole set \(F^n\) contains \(M\) <i>disjoint</i> spheres centred at codewords. By Lemma&nbsp;<a href="ch2.html#lem:S_r">2.4</a>, each of the \(M\) spheres contains \(\sum _{i=0}^t \binom {n}{i}(q-1)^i\) words. The
number of elements in a disjoint union of sets is equal to the sum of cardinalities of the sets, hence the total number of words in the \(M\) spheres is \(M\sum _{i=0}^t \binom {n}{i}(q-1)^i\). Since the union of the \(M\) spheres is a subset of
\(F^n\), this does not exceed \(\#F^n=q^n\). The bound follows. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Given the length \(n\) and the minimum distance \(d\), we may wish to know whether there are codes with the number of codewords <em>equal</em> to the Hamming bound. Such a code would be the most economical (highest possible number
\(M\) of codewords). Such codes have a special name:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (perfect code)</span>.   A code which attains the Hamming bound is called a <b><i>perfect</i></b> code.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-29"></a>
<span class="amsthmnamedefinition">Remark</span>.           “<em>Attains the bound</em>” means that the inequality in the bound becomes an equality for this code.
</p>

<p>
(A mistake is sometimes made in saying that perfect codes are those that satisfy the Hamming bound. In fact, every code <i>satisfies</i> the Hamming bound!)
</p>

<p>
It turns out that, unfortunately, meaningful perfect codes are quite rare. When the number of symbols in the alphabet is a prime power, a complete classification of perfect codes up to parameter equivalence is known; we will see it later in the course.
</p>

</li>

</ul>

</div>
<!--
...... subsection The Singleton bound ......
-->
<h5 id="autosec-30">The Singleton bound</h5>
<a id="lecnotes_html-autopage-30"></a>


<p>
Another upper bound on the number \(M\) of codewords can be conveniently stated for \(k=\log _q M\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-31"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">2.5</span></span><span class="amsthmnotedefinition"> (Singleton bound)</span>.   <a id="thm:SB"></a> If
\([n,k,d]_q\) codes exist, \(k\le n-d+1\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-32"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(C\) be an \([n,k,d]_q\)-code. Consider the function \(f\colon C\to F^{n-d+1}\) where \(f(\ul v)\) is the word obtained from \(\ul v\) by deleting the last \(d-1\) symbols.
</p>

<p>
I claim that \(f\) is an injective function. Indeed, if \(\ul v,\ul w\in C\), \(\ul v\ne \ul w\), then by definition of the minimum distance, \(\ul v\) and \(\ul w\) differ in at least \(d\) positions. Since \(f\) deletes only \(d-1\) symbols, the
words \(f(\ul v)\) and \(f(\ul w)\) still differ in at least one position. So \(f(\ul v)\ne f(\ul w)\). Injectivity of \(f\) is proved.
</p>

<p>
Now, by the Pigeonhole Principle, injective functions \(f\colon C \to F^{n-d+1}\) exist only if \(\#C \le \#F^{n-d+1}\). We conclude that \(\#C\le q^{n-d+1}\) so that \(k=\log _q\#C \le n-d+1\) as claimed. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-33"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (maximum distance separable code, MDS code)</span>.
</p>

<p>
A code which attains the Singleton bound is called a <em>maximum distance separable</em> (<em>MDS</em>) code.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-34"></a>
<span class="amsthmnamedefinition">Remark</span>.         It is important to remember that the converses to Theorems <a href="ch2.html#thm:HB">2.3</a> and <a href="ch2.html#thm:SB">2.5</a> do not hold. That is, if the numbers
\(n,k,d,q\) satisfy the Hamming bound and/or the Singleton bound, it does not automatically imply that an \([n,k,d]_q\)-code exists.
</p>

<p>
See the Exercises after this chapter for non-trivial examples related to the Hamming and Singleton bounds. Further examples will be constructed when we introduce linear codes in the next chapter and Hamming and Golay codes later in the course.
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch2ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-36"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch2ex ......
-->
<h3 id="autosec-37">Chapter&nbsp;<span class="sectionnumber">2&#x2003;</span>Exercises </h3>
<a id="lecnotes_html-autopage-37"></a>
<a id="lecnotes_html-autofile-5"></a>

<p>
Version 2022-09-28. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.1</span></span>.               Consider the trivial code \(F^n\), the Manchester code and the Luhn code. For each of these codes,
determine the parameters \([n,k,d]_q\) of the code; state how many errors the code can detect and how many errors the code can correct; determine if the code is perfect and/or MDS.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch2exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.2</span></span><span class="amsthmnotedefinition"> (important part of the theory; you will need these facts for the
exam)</span>.
</p>

<p>
<b>Definition (repeated from the lecture notes):</b> a code \(C\) is <b><i>perfect</i></b> if \(C\) <b>attains</b> the Hamming bound, meaning that
</p>

<p>
\[ \#C = \frac {q^n}{\sum \limits _{i=0}^t \binom {n}{i}(q-1)^i} \]
</p>

<p>
where \(n\) is the length of the code and \(t=[(d(C)-1)/2]\).
</p>

<p>
(a) Use the proof of Theorem <a href="ch2.html#thm:HB">2.3</a> to show that a code \(C\subseteq F^n\) is perfect, if and only if the (disjoint) spheres of radius \(t\), centred at codewords of \(C\), fill up the set \(F^n\) of all words.
</p>

<p>
<b>Equivalently,</b> \(C\) is perfect iff every word in \(F^n\) is at distance \(\le t\) from some codeword.
</p>

<p>
(b) Prove that a perfect code has odd minimum distance \(d\). (<i>Hint</i>: if \(d\) is even, construct a word at distance \(d/2\) from a codeword and show that it is not at distance \(\le t\) from any codeword.)
</p>

<p>
(c) Show that binary repetition codes of odd lengths are perfect.
</p>

<p>
(d) Show that \(\text {Rep}(n,F)\) is not perfect if \(q=\#F&gt;2\). (<i>Hint</i>: using three different symbols, write down a word at distance \(&gt;n/2\) from each codeword.)
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
[<a href="ch2exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.3</span></span><span class="amsthmnotedefinition"> (not done in the tutorial)</span>.                         Assume that the cost of
transmitting one symbol via a \(q\)-ary channel is \(cq\). (<em>Imagine a \(q\)-ary channel as a cable with \(q\) wires; the costs of building and maintaining it would be roughly proportional to \(q\)</em>.) Suppose that you are given a very large
number \(M\) and need to design a code with \(M\) codewords. You have the control over the length \(n\) and the size \(q\) of the alphabet. Which \(q\) will ensure the lowest transmission costs <em>per codeword</em>? In particular, are the binary
channels (the type most widely used in today’s computer networks) the most economical?
</p>

</li>

</ul>

</div>

<p>
[<a href="ch2exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch2exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch2exans ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">2&#x2003;</span>Exercises — solutions</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-6"></a>

<p>
Version 2022-09-28. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.1</span></span>.                      Consider the trivial code \(F^n\), the Manchester code and the Luhn code. For each of these codes,
determine the parameters \([n,k,d]_q\) of the code; state how many errors the code can detect and how many errors the code can correct; determine if the code is perfect and/or MDS.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E2.1. </b> [<a href="ch2ex.html#.">These exercises without answers</a>]
</p>

<p>
<b>Trivial code \(F^n\):</b> \(k=n\), \(d=1\). Does not detect or correct any errors. Is perfect because \(M=q^n=q^n/\sum _{i=0}^0 \binom {n}{0} (q-1)^0\). Is MDS as \(k=n-d+1\).
</p>

<p>
<b>The Manchester code:</b> \(n=2\), \(q=2\), \(M=2\) so \(k=1\); \(d=2\) by inspection. A \([2,1,2]_2\)-code, can detect up to \(1\) bit error. Does not correct errors. Is not perfect as \(M=2&lt; 2^2/\sum _{i=0}^0 \binom {2}{0}
(2-1)^0\) (using \(t=0\)). Is MDS as \(1=2-2+1\).
</p>

<p>
<b>The Luhn code:</b> \(n=16\), \(q=10\), \(M=10^{15}\) so \(k=15\). One has \(d\le 2\) as for example the codewords \(0000\dots 0\) and \(9100\dots 0\) are at distance 2.
</p>

<p>
On the other hand, \(d&gt;1\): consider two words \(\ul x = x_1x_2\dots x_{16}\) and \(\ul y=y_1y_2\dots y_{16}\) at distance \(1\). They differ in exactly one position, say \(i\), and the difference between their Luhn checksums is
\(y_i-x_i\mod 10\) if \(i\) is even or \(\pi (y_i)-\pi (x_i)\mod 10\) if \(i\) is odd. In either case the difference is non-zero so \(\ul x\) and \(\ul y\) cannot both be codewords. This shows that the Luhn code does not contain a pair of
codewords at distance \(1\), as claimed.
</p>

<p>
To conclude, the Luhn code is a \([16,15,2]_{10}\)-code.
</p>

<p>
Can detect up to \(1\) symbol error. Does not correct errors.
</p>

<p>
One has \(n-d+1=16-2+1=15=k\) — this is an MDS code. (It is not perfect; this can be checked directly, or use an exercise below as \(d\) is even.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.2</span></span><span class="amsthmnotedefinition"> (important part of the theory; you will need these facts for the
exam)</span>.
</p>

<p>
<b>Definition (repeated from the lecture notes):</b> a code \(C\) is <b><i>perfect</i></b> if \(C\) <b>attains</b> the Hamming bound, meaning that
</p>

<p>
\[ \#C = \frac {q^n}{\sum \limits _{i=0}^t \binom {n}{i}(q-1)^i} \]
</p>

<p>
where \(n\) is the length of the code and \(t=[(d(C)-1)/2]\).
</p>

<p>
(a) Use the proof of Theorem <a href="ch2.html#thm:HB">2.3</a> to show that a code \(C\subseteq F^n\) is perfect, if and only if the (disjoint) spheres of radius \(t\), centred at codewords of \(C\), fill up the set \(F^n\) of all words.
</p>

<p>
<b>Equivalently,</b> \(C\) is perfect iff every word in \(F^n\) is at distance \(\le t\) from some codeword.
</p>

<p>
(b) Prove that a perfect code has odd minimum distance \(d\). (<i>Hint</i>: if \(d\) is even, construct a word at distance \(d/2\) from a codeword and show that it is not at distance \(\le t\) from any codeword.)
</p>

<p>
(c) Show that binary repetition codes of odd lengths are perfect.
</p>

<p>
(d) Show that \(\text {Rep}(n,F)\) is not perfect if \(q=\#F&gt;2\). (<i>Hint</i>: using three different symbols, write down a word at distance \(&gt;n/2\) from each codeword.)
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<b>Answer to E2.2. </b> [<a href="ch2ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) We know from the proof of Theorem <a href="ch2.html#thm:HB">2.3</a> that the \(\#C\) spheres \(S_t(\ul c)\), where \(\ul c\in C\), are disjoint. Each sphere contains \(\sum _{i=0}^t \binom {n}{i}(q-1)^i\) words, hence the total
number of words covered by these spheres is \((\#C)\sum _{i=0}^t \binom {n}{i}(q-1)^i\). This number is equal to \(\#F^n=q^n\) iff these spheres cover all words in \(F^n\), i.e., fill up the space \(F^n\). On the other hand, this number is equal
to \(\#F^n=q^n\) iff the code \(C\) is perfect. Q.E.D.
</p>

<p>
(b) Assume for contradiction that a perfect \(C\) has even \(d(C)=d\). Take any codeword \(\ul w\) of \(C\) and change the first \(d/2\) symbols in \(\ul w\) to obtain a word \(\ul z\in F^n\) with \(d(\ul z,\ul w)=d/2\). Since \(C\) is
perfect, there must be another codeword \(\ul v\) such that \(d(\ul v,\ul z)\le t\). Then by the triangle inequality \(d(\ul v,\ul w)\le t+d/2 \le (d-1)/2+d/2 &lt;d\), a contradiction.
</p>

<p>
(c) \(\text {Rep}(n,\F _2)\) consists of \(\ul 0 = 00\ldots 0\) and \(\ul 1 = 11\dots 1\). Here \(n=2t+1\). A word \(\ul y\in \F _2^n\) may have \(\le t\) zero bits — then \(d(\ul y,\ul 1)\le t\). Otherwise, \(\ul y\) has \(t+1\)
or more zero bits, hence \(\le t\) one bits, and \(d(\ul y,\ul 0)\le t\). This shows that every word is at distance \(\le t\) from one of the two codewords. Now apply (a).
</p>

<p>
(d) Assume that the alphabet \(F\) contains at least three symbols; for simplicity, assume that \(F\) contains \(0\), \(1\) and \(2\). The repetition code \(\text {Rep}(n,F)\) has minimum distance \(n\), hence \(t=[(n-1)/2]\).
</p>

<p>
Let \(n\) be odd — the case of even \(n\) follows from (b). Then \(n=2t+1\). Consider the word \(0\dots 01\dots 12\) which has \(t\) zeros, \(t\) ones and \(1\) two. It differs from each codeword in at least \(t+1\) positions, hence is not at
distance \(\le t\) from any codeword. We have shown that the code is not perfect.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">2.3</span></span><span class="amsthmnotedefinition"> (not done in the tutorial)</span>.                         Assume that the cost of
transmitting one symbol via a \(q\)-ary channel is \(cq\). (<em>Imagine a \(q\)-ary channel as a cable with \(q\) wires; the costs of building and maintaining it would be roughly proportional to \(q\)</em>.) Suppose that you are given a very large
number \(M\) and need to design a code with \(M\) codewords. You have the control over the length \(n\) and the size \(q\) of the alphabet. Which \(q\) will ensure the lowest transmission costs <em>per codeword</em>? In particular, are the binary
channels (the type most widely used in today’s computer networks) the most economical?
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E2.3. </b> [<a href="ch2ex.html#.">These exercises without answers</a>]
</p>

<p>
The cost of transmitting one codeword is \(cqn\). By the trivial bound, \(n\ge k=\log _qM\) so this cost is estimated from below as \(cq\log _qM= K\dfrac {q}{\ln q}\) where the constant \(K\) is \(c\ln M\). The function \(f(x)=x/\ln x\)
decreases on \((0,e)\) and increases on \((e,\infty )\) (<i>check this by differentiation or otherwise</i>) so \(f(q)&gt;f(3)\) if \(q&gt;3\). Hence the only candidates for the minimum are \(q=2\) and \(q=3\). Calculating \(f(2)\cong 2.89\)
and \(f(3)\cong 2.73\), we conclude that — if we accept the (somewhat arbitrary) assumptions in the problem — ternary codes are the most economical.
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch3.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch3 ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">3&#x2003;</span>Linear codes</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-7"></a>

<p>
Version 2022-10-05. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>We define the most important class of codes called the linear codes. Their ability to correct errors is no worse than that of general codes, but linear codes are easier to implement in practice and allow us to use algebraic methods.
We learn how to find the minimum distance by looking at weights, and how to define a linear code by its generator matrix.</i>
</p>
<!--
...... subsection The definition of a linear code ......
-->
<h5 id="autosec-8">The definition of a linear code</h5>
<a id="lecnotes_html-autopage-8"></a>
<!--
...... subsection Reminder (vector spaces) ......
-->
<h5 id="autosec-9">Reminder (vector spaces)</h5>
<a id="lecnotes_html-autopage-9"></a>


<p>
Let \(\F _q\) denote the field of \(q\) elements. When we use \(\F _q\) as the alphabet, we refer to words in \(\F _q^n\) as (row) <b>vectors</b>. The set \(\F _q^n\) of all vectors of length \(n\) has the structure of a <b>vector space</b>
over the field \(\F _q\). If the vectors \(\ul u\), \(\ul v\) are in \(\F _q^n\), we can add the vectors together: \(\ul u+\ul v\in \F _q^n\), and multiply a vector by a scalar: \(\lambda \ul u \in \F _q^n\) for all \(\lambda \in \F _q\). The
addition and the scalar multiplication are performed <b>componentwise</b>. We will often write vectors in compact form, as words:
</p>

<p>
\[ 011011, 100110\in \F _2^6 \qquad \mapsto \qquad 011011+100110 = 111101\in \F _2^6.            \]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-10"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (linear code)</span>.   A <b><i>linear code</i></b> is a subspace of the vector space \(\F _q^n\).
</p>

<p>
Codewords of a linear code are called <b><i>codevectors</i></b>.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Remark</span>.   This means that the zero vector \(\ul 0\) belongs to \(C\), and that sums and scalar multiples of codevectors are again codevectors. Thus, \(C\) is a vector space in its own right.
</p>

</li>

</ul>

</div>
<!--
...... subsection Discussion: Why are linear codes useful?                ......
-->
<h5 id="autosec-12">Discussion: Why are linear codes useful?</h5>
<a id="lecnotes_html-autopage-12"></a>


<p>
<i>Not examinable</i>.
</p>
<ul style="list-style-type:none">

<li>
<p>
• They seem to be as efficient as general codes. In particular, it was proved that Shannon’s Theorem about the capacity of a channel is still true for linear codes.
</p>


</li>
<li>


<p>
• It is possible to define a linear code without specifying all the codewords (see below).
</p>


</li>
<li>


<p>
• The minimum distance is easier to calculate than for general codes (see below).
</p>


</li>
<li>


<p>
• We can use algebra to design linear codes and to construct efficient encoding and decoding algorithms.
</p>
</li>
</ul>

<p>
The absolute majority of codes designed by coding theorists are linear codes. In the rest of the course, (almost) all the codes we consider will be linear codes.
</p>

<p>
<i>End of discussion.</i>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-13"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (the most basic examples)</span>.   The trivial code \(\F _q^n\) is a linear code. (Indeed, \(\F _q^n\) is a vector subspace of itself.)
</p>

<p>
The repetition code \(\text {Rep}(n,\F _q)\) over \(\F _q\) is a linear code (<i>exercise; will see soon</i>).
</p>

<p>
To get non-trivial examples, we need to introduce more structure.
</p>

</li>

</ul>

</div>
<!--
...... subsection The weight ......
-->
<h5 id="autosec-14">The weight</h5>
<a id="lecnotes_html-autopage-14"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (weight of a vector, weight of a code)</span>.
</p>

<p>
The <b><i>weight \(w(\ul v)\) of a vector</i></b> \(\ul v\in \F _q^n\) is the number of non-zero symbols in \(\ul v\).
</p>

<p>
The <b><i>weight \(w(C)\) of a code</i></b> \(C\subseteq \F _q^n\) is \(w(C)=\min \{w(\ul v) \mid \ul v\in C\setminus \{\ul 0\}\}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-16"></a>
<span class="amsthmnamedefinition">Lemma</span><span class="amsthmnumberdefinition"> <span class="textup">3.1</span></span><span class="amsthmnotedefinition"> (distance and weight)</span>.   <a
id="lem:dist-weight"></a>
</p>

<p>
For any vectors \(\ul v,\ul y\in \F _q^n\), \(d(\ul v,\ul y)=w(\ul v-\ul y)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-17"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Indeed, \(d(\ul v,\ul y)\) is the number of positions \(i\), \(1\le i\le n\), where \(v_i\ne y_i\). Obviously, this is the same as the number of positions \(i\) where \(v_i- y_i\ne 0\). By
definition of the weight, this is \(w(\ul v - \ul y)\), as claimed. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Recall that the minimum distance, \(d(C)\), of a code \(C\) is a very important parameter which tells us how many errors can the code detect and correct in a codeword. The following theorem shows how one can find \(d(C)\) if \(C\) is linear:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-18"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">3.2</span></span>.   \(d(C)=w(C)\) for a linear code \(C\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-19"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Take a codevector \(\ul v\) such that \(w(C)=w(\ul v)\). Observe, \(w(\ul v)=w(\ul v-\ul 0)=d(\ul v,\ul 0)\) but \(\ul v\ne \ul 0\in C\) so \(w(\ul v)\ge d(C)\). We proved that
\(w(C)\ge d(C)\).
</p>

<p>
Now take a pair \(\ul y\ne \ul z\in C\) such that \(d(\ul y,\ul z)=d(C)\). Rewrite this as \(w(\ul y-\ul z)\). Since \(C\) is linear, \(\ul y - \ul z\in C\setminus \{0\}\) so \(w(\ul y-\ul z)\ge w(C)\). We proved that \(d(C)\ge
w(C)\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Remark</span>.   In the proof, we twice used that \(C\) is linear: first, \(\ul 0\in C\); second, \(\ul y ,\ul z\in C\) implies \(\ul y - \ul z\in C\). This condition is essential.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Remark</span>.   Given a linear code \(C\), one needs to check only \(M-1\) vectors to compute \(d(C)=w(C)\). For a non-linear code, one has to check \(M(M-1)/2\) pairs of words to compute the minimum
distance \(d\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-22"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (The zero sum code)</span>. For any finite field \(\F _q\) and for any \(n\ge 1\) we can define the <b><i>zero sum code</i></b> in \(\F _q^n\)
as
</p>

<p>
\[ Z = \{(v_1,v_2,\dots ,v_n)\in \F _q^n \mid v_1+v_2+\dots +v_n = 0\text { in }\F _q\}.                     \]
</p>

<p>
We note that the zero sum code in \(\F _q^n\) is a linear code because \(Z\) is the set of solutions to the homogeneous linear equation \(v_1+\dots +v_n=0\). It is known from linear algebra (and is easy to check directly) that the sum of two vectors
satisfying this equation also satisfies this equation, and scaling a vector satisfying this equation again satisfies the equation. In other words, \(Z\) is a vector space.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-23"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (The binary even weight code \(E_n\))</span>.
</p>

<p>
The <b><i>binary even weight code of length \(n\)</i></b> is defined as
</p>

<p>
\[ E_n=\{\ul v\in \F _2^{n}:       w(\ul v)\text { is even}\}.        \]
</p>

<p>
Due to the rules of arithmetic in \(\F _2\) we have
</p>

<p>
\[ E_n = \{x_1x_2\ldots x_n :       x_i\in \F _2, \ x_1+x_2+\dots +x_n=0\text { in }\F _2\} \]
</p>

<p>
which shows that \(E_n\) is a particular case of a zero sum code, hence is a linear binary code.
</p>

<p>
<b>Remark:</b> \(0\) is an even number! The binary even weight code contains the codeword \(00\ldots 0.\)
</p>

<p>
<b>Minimum distance = weight:</b> a vector with only one \(1\) has odd weight but a vector \(1100\ldots 0\) of weight \(2\) is in \(E_n\). Hence \(d(E_n)=w(E_n)=2.\) The code detects up to \(1\) error and corrects up to \(0\) errors.
</p>

<p>
<b>The number of codewords:</b> in a codeword \(\ul v=(x_1,x_2,\ldots ,x_n)\), the first \(n-1\) bits can be arbitrary (\(2^{n-1}\) combinations), then the last bit is uniquely determined by \(x_n = x_1+x_2+\ldots +x_{n-1},\) where
\(+\) is the addition is in the field \(\F _2.\) We thus have \(2^{n-1}\) codewords.
</p>

<p>
Another argument to that effect is as follows. We can take a binary word and flip (change) its first bit. This operation splits the set \(\F _2^n\) into pairs of vectors, such that the vectors in a pair only differ in the first bit. Each pair contains one
vector of even weight and one vector of odd weight. Therefore, the number of vectors of even weight is equal to the number of vectors of odd weight, and is \(\frac 12 \#\F _2^n=2^{n-1}.\)
</p>

<p>
<b>Conclusion:</b> \(E_n\) is an \([n,n-1,2]_2\)-code.
</p>

<p>
<b>Remark:</b> A widely used code. If an error is <i>detected</i>, the recipient will request retransmission of the codeword where the error occurred. Error <i>correction</i> is not available.
</p>

</li>

</ul>

</div>
<!--
...... subsection The code generated by a matrix. A generator matrix of a linear code ......
-->
<h5 id="autosec-24">The code generated by a matrix. A generator matrix of a linear code</h5>
<a id="lecnotes_html-autopage-24"></a>


<p>
We have an unlimited supply of linear codes, due to the following construction.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (the linear code generated by a matrix)</span>.   Let \(G\) be a \(k\times n\) matrix with linearly independent rows \(\ul r_1,\dots ,\ul
r_k\in \F _q^n\). The code
</p>

<p>
\[ C=\{ u_1 \ul r_1 + \ldots +u_k \ul r_k \mid u_1,\ldots ,u_k\in \F _q\} \quad \subseteq \quad \F _q^n \]
</p>

<p>
is said to be <b><i>generated by the matrix \(G\)</i></b>. In this case, the function
</p>

<p>
\[ \Encode \colon \F _q^k \to C,\qquad \Encode (\ul u) = \ul u G \quad \text {for all }\ul u\in \F _q^k \]
</p>

<p>
is the <b><i>encoder</i></b> for \(C\) given by the matrix \(G\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-26"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">3.3</span></span><span class="amsthmnotedefinition"> (properties of a code generated by a matrix)</span>.                            In
the above definition, \(C\) is a linear code. The function \(\Encode \) is a bijective linear map between \(\F _q^k\) and \(C\). The information dimension of \(C\) is \(k\) and is equal to \(\dim C\), the dimension of \(C\) as a vector space.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-27"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> The definition says that \(C\) is the span of \(\ul r_1,\ldots ,\ul r_k\) in the vector space \(\F _q^n\). By linear algebra, a span is a subspace of \(\F _q^n\) hence a linear code.
</p>

<p>
Matrix multiplication is linear in each argument so \(\Encode (\ul u) = \ul u G\) is a linear function of \(\ul u =(u_1,\dots ,u_k)\). As \(C\) consists of vectors of the form \(u_1 \ul r_1 + \dots +u_k \ul r_k=\ul u G\), the image of
\(\Encode \) is \(C\) so \(\Encode \) is surjective. The kernel of \(\Encode \) is made up of all \((u_1,\dots ,u_k)\) such that \(u_1 \ul r_1 + \ldots +u_k \ul r_k=\ul 0\), but as \(\ul r_1,\ldots ,\ul r_k\) are linearly independent,
\(\ker \Encode =\{\ul 0\}\) and so \(\Encode \) is injective, hence bijective.
</p>

<p>
Therefore, \(M = \# C = \# \F _q^k = q^k\) which shows that the information dimension of \(C\) is \(\log _q(M)=k\). This is also the dimension of \(C\) as a vector space because \(\{\ul r_1,\ldots ,\ul r_k\}\) is a basis of \(C\), being a
linearly independent set which spans \(C\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Not only every code generated by a matrix is linear, but every linear code is generated by a matrix:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (generator matrix)</span>.
</p>

<p>
Let \(C\subseteq \F _q^n\) be a linear code. A <b><i>generator matrix</i></b> of \(C\) is a matrix
</p>

<p>
\[ G=\begin {bmatrix} \ul r_1 \\ \ul r_2 \\ \vdots \\ \ul r_k \end {bmatrix}, \]
</p>

<p>
where the row vectors \(\ul r_1,\ldots ,\ul r_k\) are a basis of \(C\). (Clearly, \(C\) is generated by any of its generator matrices.)
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-29"></a>
<span class="amsthmnamedefinition">Example</span>.
</p>
<ul style="list-style-type:none">


<li>
<p>
(a) The identity matrix \(I_n\) is a generator matrix for the trivial code, \(\F _q^n\). Any other \(n\times n\) matrix with linearly independent rows is also a generator matrix for the trivial code of length \(n\).
</p>
</li>
<li>


<p>
(b) The repetition code \(\text {Rep}(n,\F _q)\) has generator matrix \(G=\begin {bmatrix}1&amp;1&amp;\dots &amp;1\end {bmatrix}\), of size \(1\times n\). The matrix \(\lambda G\) for any \(\lambda \in \F _q\), \(\lambda \ne 0\) is
also a generator matrix for \(\text {Rep}(n,\F _q)\).
</p>
</li>
<li>


<p>
(c) Consider the binary even weight code of length \(3\):
</p>
<p>
\[ E_3=\{000,011,101,110\}.      \]
</p>
<p>
The code has \(4=2^2\) codewords, so the dimension of this code is \(2\). Therefore, a generator matrix has \(2\) rows and \(3\) columns.
</p>
<p>
To write down a generator matrix, we need to take two linearly independent codevectors. We must not use the zero codevector, \(000\), because a linearly independent set must not contain the zero vector.
</p>
<p>
So we can use
</p>
<p>
\[ G=\left [\begin {matrix}0&amp;1&amp;1\\ 1&amp;0&amp;1\end {matrix}\right ] \text { or } G=\left [\begin {matrix}0&amp;1&amp;1\\ 1&amp;1&amp;0\end {matrix}\right ] \text { or } G=\left [\begin
{matrix}1&amp;0&amp;1\\ 0&amp;1&amp;1\end {matrix}\right ] \text { etc.} \]
</p>
<p>
Each of these matrices is a generator matrix for \(E_3\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-30"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnotedefinition"> (Defining a linear code by a generator matrix)</span>.   Thus, to work with a linear code, it is enough to store just its generator matrix instead of
storing all codevectors. This approach to linear codes has its practical advantages and disadvantages.
</p>

<p>
<i>Advantage.</i> The single advantage which outweighs everything else is the amount of storage space required.
</p>
<blockquote>

<p>
To better visualise the difference between storing all the \(q^k\) codewords of a linear code and storing only \(k\) rows of a generator matrix, consider the following. A binary code of dimension about \(1500\) was used in computer networks for
error detection. While it is possible to store \(1500\) rows of a generator matrix, it is definitely not possible to store a list of all \(2^{1500}\) codewords. Indeed, the number \(10^{100}\) (the <i>googol</i>) is believed to be much bigger than the
number of electrons in the visible Universe; and the googol is less than \(2^{340}\).
</p>
</blockquote>

<p>
<i>Disadvantages.</i> A generator matrix is in general <b>not unique</b>, because a basis of a vector space \(C\) can be chosen in more than one way. It may not be obvious if two matrices generate the same code (although it is easy to test by
bringing both matrices to reduced row echelon form and comparing the result).
</p>

<p>
If a linear code \(C\) is specified by a generator matrix \(G\), it may be difficult to compute the <b>weight</b> \(w(C)\) of \(C\). Of course, the weight of \(C\) does not exceed, but is in general not equal to, the minimum weight of a row of \(G\).
For some linear codes which have been used in practice, the weight is not known!
</p>

</li>

</ul>

</div>
<!--
...... subsection Generator matrices in standard form ......
-->
<h5 id="autosec-32">Generator matrices in standard form</h5>
<a id="lecnotes_html-autopage-32"></a>


<p>
For a linear code \(C\), the encoder, \(\Encode (\ul u)=\ul uG\), depends on the choice of a generator matrix \(G\). In practice, for many codes there is the best choice:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-33"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (generator matrix in standard form)</span>.
</p>

<p>
A generator matrix \(G\) is in <i>standard form</i> if its leftmost colums form an identity matrix:
</p>

<p>
\[ G = [I_k \,|\, A ] = \left [ \begin {array}{cccc|ccc} 1&amp; 0 &amp; \ldots &amp; 0 &amp; * &amp; \ldots &amp; * \\ 0&amp; 1 &amp; \ldots &amp; 0 &amp; * &amp; \ldots &amp; * \\ &amp; &amp; \ddots &amp; &amp;
&amp; &amp; \\ 0 &amp; 0 &amp; \ldots &amp; 1 &amp; * &amp; \ldots &amp; * \end {array} \right ].                   \]
</p>

<p>
Note that entries in the last \(n-k\) columns, denoted by \(*\), are arbitrary elements of \(\F _q\).
</p>

</li>

</ul>

</div>

<p>
If \(G\) is in standard form, then, after encoding, the first \(k\) symbols of the codeword show the original message:
</p>

<p>
\[ \ul u\in \F _q^k \quad \mapsto \quad \Encode (\ul u) = \ul u G = \ul u [I_k \,|\, A ] = [ \ul u\, | \,\ul u A] \]
</p>

<p>
(this is an easy example of multiplication of block matrices). This means that it is easy to <b><i>unencode</i></b> a codevector, simply by taking its first \(k\) symbols.
</p>

<p>
In this situation, the first \(k\) symbols of a codeword are called <i>information symbols</i>. The last \(n-k\) symbols are called <i>check symbols</i>; their job is to protect the information from noise by increasing the Hamming distance between
codewords.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-34"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">3.4</span></span><span class="amsthmnotedefinition"> (generator matrix in standard form)</span>.   <a
id="thm:standardunique"></a> If a generator matrix in standard form exists for a linear code \(C\), it is unique, and any generator matrix can be brought to the standard from by the following operations:
</p>
<ul style="list-style-type:none">


<li>
<p>
(R1) Permutation of rows.
</p>


</li>
<li>


<p>
(R2) Multiplication of a row by a non-zero scalar.
</p>


</li>
<li>


<p>
(R3) Adding a scalar multiple of one row to another row.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-35"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Not given — a standard fact from linear algebra (uniqueness of reduced row echelon form). We will do some examples to show how to find the generator matrix in standard form. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<b>Remark.</b> If we apply a sequence of the row operations (R1), (R2) and (R3) to a generator matrix of a code \(C\), we again obtain a generator matrix of \(C\). This is implied in the Theorem, and follows from the fact that a basis of a vector
space remains a basis under permutations, multiplication of an element of the basis by a scalar, and adding a scalar multiple of an element to another element. This fact is known from linear algebra.
</p>

<p>
Examples of finding a generator matrix in standard form, and examples of codes which have no generator matrix in standard form, are given on the example sheets. We consider one example here:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-36"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (Bringing a generator matrix into standard form)</span>.                 The binary code \(C\) is generated by \(\left [\begin
{matrix}0&amp;1&amp;1&amp;1&amp;1\\ 1&amp;0&amp;1&amp;1&amp;1 \\ 1&amp;1&amp;0&amp;1&amp;1 \\ 1&amp;1&amp;1&amp;1&amp;0\end {matrix}\right ]\). Find the generator matrix in standard form for \(C\). Find the parameters of
\(C\). Identify the code \(C\) by its well-known name.
</p>

<p>
<b>Solution:</b> apply row operations \(\left [\begin {matrix}0&amp;1&amp;1&amp;1&amp;1\\ 1&amp;0&amp;1&amp;1&amp;1 \\ 1&amp;1&amp;0&amp;1&amp;1 \\ 1&amp;1&amp;1&amp;1&amp;0\end {matrix}\right ]\) \((r_1\leftrightarrow
r_2)\) \(\left [\begin {matrix} 1&amp;0&amp;1&amp;1&amp;1 \\ 0&amp;1&amp;1&amp;1&amp;1\\ 1&amp;1&amp;0&amp;1&amp;1 \\ 1&amp;1&amp;1&amp;1&amp;0\end {matrix}\right ]\) (\(r_3\to r_3+r_1\), \(r_4\to r_4+r_1\)) \(\left
[\begin {matrix} 1&amp;0&amp;1&amp;1&amp;1 \\ 0&amp;1&amp;1&amp;1&amp;1\\ 0&amp;1&amp;1&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0&amp;1\end {matrix}\right ]\) (\(r_2\leftrightarrow r_4\)) \(\left [\begin {matrix}
1&amp;0&amp;1&amp;1&amp;1 \\ 0&amp;1&amp;0&amp;0&amp;1 \\ 0&amp;1&amp;1&amp;0&amp;0 \\ 0&amp;1&amp;1&amp;1&amp;1\end {matrix}\right ]\) (\(r_3\to r_3+r_2\), \(r_4\to r_4+r_2\)) \(\left [\begin {matrix}
1&amp;0&amp;1&amp;1&amp;1 \\ 0&amp;1&amp;0&amp;0&amp;1 \\ 0&amp;0&amp;1&amp;0&amp;1 \\ 0&amp;0&amp;1&amp;1&amp;0\end {matrix}\right ]\) (\(r_1\to r_1+r_4\)) \(\left [\begin {matrix} 1&amp;0&amp;0&amp;0&amp;1 \\
0&amp;1&amp;0&amp;0&amp;1 \\ 0&amp;0&amp;1&amp;0&amp;1 \\ 0&amp;0&amp;1&amp;1&amp;0\end {matrix}\right ]\) (\(r_4\to r_4+r_3\)) \(\left [\begin {matrix} 1&amp;0&amp;0&amp;0&amp;1 \\ 0&amp;1&amp;0&amp;0&amp;1 \\
0&amp;0&amp;1&amp;0&amp;1 \\ 0&amp;0&amp;0&amp;1&amp;1\end {matrix}\right ]\).
</p>

<p>
The parameters of \(C\) are: length 5 (the number of columns of the generator matrix), dimension 4 (the number of rows of the generator matrix). From the generator matrix in standard form (its rows are also codevectors!) we can see that
\(w(C)\le 2\). In fact, all the rows of the generator matrix are of even weight; hence they lie in the vector space \(E_5\). Hence all their linear combinations lie in \(E_5\). Since \(\dim C = 4 = \dim E_5\), we have \(C=E_5\) (<i>the even weight
code of length 5</i>) and \(d(C)=w(C)=2\).
</p>

<p>


</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch3ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-38"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch3ex ......
-->
<h3 id="autosec-39">Chapter&nbsp;<span class="sectionnumber">3&#x2003;</span>Exercises </h3>
<a id="lecnotes_html-autopage-39"></a>
<a id="lecnotes_html-autofile-8"></a>

<p>
Version 2022-10-05. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.1</span></span>.
</p>

<p>
Write down a generator matrix for the repetition code \(\Rep (5,\F _7)\).
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.2</span></span><span class="amsthmnotedefinition"> (<b>important — you need to know the ISBN-10 code
for the exam</b>)</span>.      Consider the field \(\F _{11}=\{0,1,2,3,4,5,6,7,8,9,X\}\) of integers modulo \(11\); by convention, \(X\) means ten.
</p>

<p>
The <b>ISBN-10 checksum</b> of a word \(x_1x_2\dots x_{10}\) in \(\F _{11}^{10}\) is
</p>

<p>
\[ 1x_1+2x_2+\dots +10x_{10} = \sum _{i=1}^{10}ix_i \in \F _{11}.           \]
</p>

<p>
The <b>ISBN-10</b> code, which was used to give unique IDs to books until it was superseded by ISBN-13, consists of all vectors in \(\F _{11}^{10}\) which have zero checksum. It is a linear code (the set of solutions to a homogeneous linear
equation is a vector space).
</p>

<p>
Show that the code detects a single error. Show that the code detects a transposition error (when two adjacent digits are swapped in a codeword, it is no longer a codeword). Show that the code has \(d=2\) hence is not perfect.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.3</span></span><span class="amsthmnotedefinition"> (an exam style question)</span>.   Let \(C\) be the ternary
linear code generated by \(G=\left [\begin {matrix}0&amp; 1&amp; 2&amp; 1\\ 2&amp; 0&amp; 1&amp; 1\end {matrix}\right ]\). (Reminder: <i>ternary</i> means that the alphabet is \(\F _3\).)
</p>

<p>
(a) List all the codevectors of \(C\). Find \(d(C)\) by inspection. Deduce that \(C\) is a perfect code. Does \(C\) attain the Singleton bound?
</p>

<p>
(b) Find a generator matrix of \(C\) in standard form.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.4</span></span>.                If \(\ul v=(x_1,x_2,\ldots ,x_n)\) is a binary vector, we extend \(\ul v\) to obtain the vector
\(\widehat {\ul v}\) \(=(x_1,\ldots ,\) \(x_n,x_{n+1})\) where \(x_{n+1}=x_1+\ldots +x_n\) in \(\F _2\). That is, a vector is extended by appending one bit so that the resulting vector has even weight.
</p>

<p>
If \(C\) is a binary linear code, we define the <b>extended code</b> \(\widehat C =\{\widehat {\ul c}:      \ul c\in C\}\).
</p>

<p>
(a) Prove that \(d(\widehat C)\) is even. Prove that \(\widehat C\) is never perfect. Which code do you get by extending a trivial binary code, i.e., what is the code \(\widehat {\F _2^n}\)? Is it true that \(\widehat {E_n}=E_{n+1}\)? What is
\(\widehat {\Rep (n,\F _2)}\)?
</p>

<p>
(b) It is said that <i>extending a binary code may improve error detection but cannot improve error correction</i>. Do you agree with this statement? Justify your answer. (<b>Warning:</b> this is a mathematical question and not an ‘opinion’
question. Your arguments must be based on the theory covered in the course. Such questions may appear in the exam.)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-6"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.5</span></span>.   (a) Show that the binary linear code generated by   \(\begin {bmatrix}1&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;1 \end {bmatrix}\) has no generator matrix in standard form.
</p>

<p>
(b) The ISBN-10 code has a generator matrix in standard form. Find it.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-7"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.6</span></span>.              The binary simplex code \(\Sigma \) of length 7, which we introduced earlier by listing all
codevectors, is a linear code (you may wish to check this):
</p>

<p>
\[\begin {matrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp;
1 &amp; 1 \end {matrix} \qquad \qquad \begin {matrix} 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0
&amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end {matrix} \]
</p>

<p>
Write down the standard form generator matrix for \(\Sigma \) <i>without doing any calculations</i>. Now look at the seven columns of your generator matrix: does it have two equal columns? Write down another generator matrix for the same
code. What can you say about its columns?
</p>

</li>

</ul>

</div>

<p>
[<a href="ch3exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch3exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-9"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch3exans ......
-->
<h3 id="autosec-10">Chapter&nbsp;<span class="sectionnumber">3&#x2003;</span>Exercises — solutions</h3>
<a id="lecnotes_html-autopage-10"></a>
<a id="lecnotes_html-autofile-9"></a>

<p>
Version 2022-10-05. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.1</span></span>.
</p>

<p>
Write down a generator matrix for the repetition code \(\Rep (5,\F _7)\).
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.1. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
\(\Rep (n,\F _q)\) consists of all vectors proportional to the vector \(11\dots 11\) of \(n\) ones. Hence the only row of the \(1\times n\) matrix \(\begin {bmatrix} 1&amp; 1 &amp; \dots &amp; 1 &amp; 1\end {bmatrix}\) spans the code,
i.e., forms a spanning set, which is obviously linearly independent.
</p>

<p>
Multiplying the above generator matrix by any scalar \(\lambda \in \F _q\setminus \{0\}\) also gives a generator matrix for \(\Rep (n,\F _q)\).
</p>

<p>
For \(\Rep (5,\F _7)\) we get \(\begin {bmatrix} 1&amp; 1 &amp; 1 &amp; 1 &amp; 1\end {bmatrix}\) or any matrix obtained by scaling this one by a non-zero scalar in \(\F _7\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.2</span></span><span class="amsthmnotedefinition"> (<b>important — you need to know the ISBN-10 code
for the exam</b>)</span>.      Consider the field \(\F _{11}=\{0,1,2,3,4,5,6,7,8,9,X\}\) of integers modulo \(11\); by convention, \(X\) means ten.
</p>

<p>
The <b>ISBN-10 checksum</b> of a word \(x_1x_2\dots x_{10}\) in \(\F _{11}^{10}\) is
</p>

<p>
\[ 1x_1+2x_2+\dots +10x_{10} = \sum _{i=1}^{10}ix_i \in \F _{11}.           \]
</p>

<p>
The <b>ISBN-10</b> code, which was used to give unique IDs to books until it was superseded by ISBN-13, consists of all vectors in \(\F _{11}^{10}\) which have zero checksum. It is a linear code (the set of solutions to a homogeneous linear
equation is a vector space).
</p>

<p>
Show that the code detects a single error. Show that the code detects a transposition error (when two adjacent digits are swapped in a codeword, it is no longer a codeword). Show that the code has \(d=2\) hence is not perfect.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.2. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
If the \(i\)th digit in a word \(x_1\dots x_{10}\) is changed to \(y_i\), the checksum is changed by \(iy_i-ix_i=i(y_i-x_i)\). Note that \(i\ne 0\) and \(y_i-x_i\ne 0\) in \(\F _{11}\), hence \(i(y_i-x_i)\ne 0\) because in a field, the
product of non-zero elements is not zero. Hence, changing one digit changes the ISBN-10 checksum; so a codeword becomes a non-codeword. This shows that \(d\ge 2\).
</p>

<p>
To observe that \(d=2\), take the codewords \(0000000000\) and \(0000110000\).
</p>

<p>
To show that the code detects a transposition error, we check that when two adjacent symbols are swapped, the checksum is changed. Indeed, when \(\dots xy\dots \) is changed to \(\dots yx\dots \) (symbols in positions \(i\), \(i+1\)), the
checksum changes by \(iy+(i+1)x - (ix+(i+1)y) = x-y\). This is not zero mod 11 as long as \(x\ne y\) (but if \(x=y\), there was no error!) Therefore, a codeword becomes a non-codeword as a result of a transposition error.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.3</span></span><span class="amsthmnotedefinition"> (an exam style question)</span>.                       Let \(C\) be the ternary
linear code generated by \(G=\left [\begin {matrix}0&amp; 1&amp; 2&amp; 1\\ 2&amp; 0&amp; 1&amp; 1\end {matrix}\right ]\). (Reminder: <i>ternary</i> means that the alphabet is \(\F _3\).)
</p>

<p>
(a) List all the codevectors of \(C\). Find \(d(C)\) by inspection. Deduce that \(C\) is a perfect code. Does \(C\) attain the Singleton bound?
</p>

<p>
(b) Find a generator matrix of \(C\) in standard form.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.3. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) First of all, it is useful to recall that the total number of codevectors is \(q^k\) where \(k\) is the number of rows in the generator matrix. In this case, \(q^k=3^2=9\).
</p>

<p>
We need to list all the \(9\) linear combinations of the two rows of the matrix \(G\),
</p>

<p>
\[ \ul r_1 = [\begin {matrix}0&amp; 1&amp; 2&amp; 1\end {matrix}], \quad \ul r_2=[\begin {matrix}2&amp; 0&amp; 1&amp; 1\end {matrix}].                           \]
</p>

<p>
Let us do this by encoding all vectors of length \(2\), in matrix form. Remember, ‘encoding in matrix form’ simply means that the codevector \(\lambda _1 \ul r_1 + \lambda _2 \ul r_2\) is written as \([ \begin {matrix} \lambda _1 &amp;
\lambda _2 \\ \end {matrix}]G\) where \(G=\begin {bmatrix}\ul r_1 \\ \ul r_2 \end {bmatrix}\):
</p>

<p>
\([ \begin {matrix} 0 &amp; 0 \\ \end {matrix} ]G=[ \begin {matrix} 0 &amp; 0 &amp; 0 &amp; 0 \\ \end {matrix} ]\),                     \([ \begin {matrix} 0 &amp; 1 \\ \end {matrix} ]G=[ \begin {matrix} 2 &amp; 0 &amp; 1 &amp; 1 \\
\end {matrix} ]\), \([ \begin {matrix} 0 &amp; 2 \\ \end {matrix} ]G=[ \begin {matrix} 1 &amp; 0 &amp; 2 &amp; 2 \\                     \end {matrix} ]\),<br />
\([ \begin {matrix} 1 &amp; 0 \\ \end {matrix} ]G=[ \begin {matrix} 0 &amp; 1 &amp; 2 &amp; 1 \\ \end {matrix} ]\),                     \([ \begin {matrix} 1 &amp; 1 \\ \end {matrix} ]G=[ \begin {matrix} 2 &amp; 1 &amp; 0 &amp; 2 \\
\end {matrix} ]\), \([ \begin {matrix} 1 &amp; 2 \\ \end {matrix} ]G=[ \begin {matrix} 1 &amp; 1 &amp; 1 &amp; 0 \\                     \end {matrix} ]\),<br />
\([ \begin {matrix} 2 &amp; 0 \\ \end {matrix} ]G=[ \begin {matrix} 0 &amp; 2 &amp; 1 &amp; 2 \\ \end {matrix} ]\),                     \([ \begin {matrix} 2 &amp; 1 \\ \end {matrix} ]G=[ \begin {matrix}2&amp;2&amp;2&amp;0\\ \end
{matrix} ]\), \([ \begin {matrix} 2 &amp; 2 \\ \end {matrix} ]G=[ \begin {matrix} 1 &amp; 2 &amp; 0 &amp; 1 \\ \end                     {matrix} ]\).
</p>

<p>
To find \(d(C)\), one could of course check all 36 pairwise distances between codewords — but this is wrong, because we know that \(C\) is a linear code, so by a theorem from the course, \(d(C)=w(C)\). Having checked each of the \(8\) non-zero
codevectors obtained above, we conclude that \(w(C)=3\).
</p>

<p>
To show that \(C\) is perfect, let us check the Hamming bound (in logarithmic form): \(t=1\) so \(k=n-\log _q(\binom n0+\binom n1(q-1))\), \(2=4-\log _3(1+4\times 2)\), \(2=4-\log _39\) — true. Hence the code is perfect.
</p>

<p>
<b>Exercise:</b> show that \(C\) is an MDS code (attains the Singleton bound).
</p>

<p>
(b) Once <b>we know all the codevectors</b>, finding a generator matrix in standard form does not require any further calculations. Simply select the codevectors which begin with 10 and 01:
</p>

<p>
\[ G = \left [\begin {matrix}1&amp;0&amp;2&amp;2 \\ 0&amp;1&amp;2&amp;1\end {matrix}\right ].                   \]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.4</span></span>.                    If \(\ul v=(x_1,x_2,\ldots ,x_n)\) is a binary vector, we extend \(\ul v\) to obtain the vector
\(\widehat {\ul v}\) \(=(x_1,\ldots ,\) \(x_n,x_{n+1})\) where \(x_{n+1}=x_1+\ldots +x_n\) in \(\F _2\). That is, a vector is extended by appending one bit so that the resulting vector has even weight.
</p>

<p>
If \(C\) is a binary linear code, we define the <b>extended code</b> \(\widehat C =\{\widehat {\ul c}:         \ul c\in C\}\).
</p>

<p>
(a) Prove that \(d(\widehat C)\) is even. Prove that \(\widehat C\) is never perfect. Which code do you get by extending a trivial binary code, i.e., what is the code \(\widehat {\F _2^n}\)? Is it true that \(\widehat {E_n}=E_{n+1}\)? What is
\(\widehat {\Rep (n,\F _2)}\)?
</p>

<p>
(b) It is said that <i>extending a binary code may improve error detection but cannot improve error correction</i>. Do you agree with this statement? Justify your answer. (<b>Warning:</b> this is a mathematical question and not an ‘opinion’
question. Your arguments must be based on the theory covered in the course. Such questions may appear in the exam.)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.4. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) By construction, the weight of each codevector of \(\widehat C\) is even. Hence \(w(\widehat C)=d(\widehat C)\) is even, so by one of the earlier exercises, \(\widehat C\) is not perfect (the minimum distance of a perfect code is odd).
</p>

<p>
Every codevector of \(\widehat {\F _2^n}\) has length \(n+1\) and is of even weight, hence lies in the ieven weight code \(E_{n+1}\). Thus, \(\widehat {\F _2^n}\subseteq E_{n+1}\). Observing that \(\#\widehat {\F _2^n} = 2^n =
\#E_{n+1}\), we conclude that \(\widehat {\F _2^n}= E_{n+1}\).
</p>

<p>
We have \(\widehat {E_n}\ne E_{n+1}\) because the cardinality of \(\widehat {E_n}\) is \(2^{n-1}\) but \(\#E_{n+1}=2^n\). Rather, \(\widehat {E_n}\) is obtained by appending a zero bit to every vector in \(E_n\).
</p>

<p>
Finally, \(\Rep (n,\F _2)\) consists of two vectors, \(\ul 0\) and \(\ul 1 = 11\ldots 11\). We have \(\widehat {\ul 0}=\ul 0\) (of length \(n+1\)), and \(\widehat {11\dots 11} \) is either \(11\dots 111\) (\(n+1\) ones) if \(n\) is odd, or
\(11\dots 110\) if \(n\) is even. Thus, \(\widehat {\Rep (n,\F _2)}\) is \(\Rep (n+1,\F _2)\) iff \(n\) is odd.
</p>

<p>
(b) To address error detection and correction, we need to relate the question to the minimal distance of the code, which is the same as weight since we work with linear codes. Assume that \(w(C)=d\) so that the code detects up to \(d-1\) bit errors
and corrects up to \([(d-1)/2]\) errors. Let \(\ul v\in C\) be a non-zero vector of minimum weight \(d\). Consider two cases.
</p>

<p>
<i>Case 1</i>, \(d\) is odd. Then \(\widehat v\) has weight \(d+1\) and clearly no non-zero vector in \(\widehat C\) has smaller weight. Hence \(d(\widehat C)=d+1\), and \(\widehat C\) detects up to \(d\) errors; that is, error detection has
improved after extending the code. But \([(d-1)/2]=(d-1)/2\) which is an integer, and \([(d+1-1)/2]=[(d-1)/2 + 0.5] = (d-1)/2\), hence error correction has not improved.
</p>

<p>
<i>Case 2</i>, \(d\) is even. <b>Exercise:</b> show that \(d(\widehat C)=d\) so that neither error detection nor error correction have improved.
</p>

<p>
In summary, it make sense to extend a binary code of odd weight to improve error detection. As a trade-off, the length of the code increases and the dimension stays the same, so that the rate, \(R=k/n\), decreases.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-6"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.5</span></span>.                    (a) Show that the binary linear code generated by      \(\begin {bmatrix}1&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;1 \end {bmatrix}\) has no generator matrix in standard form.
</p>

<p>
(b) The ISBN-10 code has a generator matrix in standard form. Find it.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.5. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) The codevectors of this code are \(0000\), \(1100\), \(0011\) and \(1111\). The first row of a generator matrix in standard form must start with \(10\), but there is no such codevector.
</p>

<p>
(b) We know that \(n=10\) and \(k=9\), so the generator matrix will have 9 rows and 10 columns; hence the first 9 columns will form the identity matrix, and we are left to fill the last column only. Look at the first row of the generator matrix in
standard form. It is of the form \(100000000*\). It must also be a codevector: its ISBN-10 checksum is \(1\times 1 + 2\times 0 + 3\times 0 +\dots +9\times 0 + 10\times *=0\), so \(1+10*=0\) whence \(*=1\). We similarly deal with the
second row, \(010000000*\): we have \(2\times 1 + 10*=0\) so \(*=2\). Continuing in this fashion, we obtain
</p>

<p>
\[G=\left [\begin {matrix}1000000001\\0100000002\\0010000003\\0001000004\\ \ddots \\0000000019\end {matrix}\right ].\]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-7"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">3.6</span></span>.                    The binary simplex code \(\Sigma \) of length 7, which we introduced earlier by listing all
codevectors, is a linear code (you may wish to check this):
</p>

<p>
\[\begin {matrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp;
1 &amp; 1 \end {matrix} \qquad \qquad \begin {matrix} 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ 0
&amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end {matrix} \]
</p>

<p>
Write down the standard form generator matrix for \(\Sigma \) <i>without doing any calculations</i>. Now look at the seven columns of your generator matrix: does it have two equal columns? Write down another generator matrix for the same
code. What can you say about its columns?
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E3.6. </b> [<a href="ch3ex.html#.">These exercises without answers</a>]
</p>

<p>
The code has 8 codevectors hence is of dimension 3. The generator matrix will therefore have 3 rows and 8 columns. Since all the codevectors are given, we simply need to select the codevectors which begin with \(100\), \(010\) and \(001\). Here
they are:
</p>

<p>
\[G=\left [\begin {matrix} 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end {matrix}\right ].                                  \]
</p>

<p>
We observe that all the columns of \(G\) are distinct. They are all the possible nonzero binary column vectors of size 3. (There are \(2^r\) binary column vectors of size \(r\), among which \(2^r-1\) are non-zero.)
</p>

<p>
Let us try a different generator matrix, not in standard form: for example,
</p>

<p>
\[G&apos;=\left [\begin {matrix} 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\ \end {matrix}\right ].                                       \]
</p>

<p>
Note that \(G&apos;\) is a generator matrix for \(\Sigma \), since its rows are codevectors of \(\Sigma \), are linearly independent (look at the first three bits to see that no two rows sum up to give the third row), and it has \(3=\dim \Sigma \)
rows. Miraculously, \(G&apos;\) consists of the same columns as \(G\) — that is, all the three-dimensional non-zero binary column vectors — but in a different order.
</p>

<p>
This is a special property of binary simplex codes, which we will prove when we study Hamming codes.
</p>

<p>
<b>Exercise:</b> rearrange the columns of \(G\) to obtain a matrix which generates a code different from \(\Sigma \).
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch4.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-9"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch4 ......
-->
<h3 id="autosec-10">Chapter&nbsp;<span class="sectionnumber">4&#x2003;</span>Decoding linear codes</h3>
<a id="lecnotes_html-autopage-10"></a>
<a id="lecnotes_html-autofile-10"></a>

<p>
Version 2022-10-11. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>We explicitly describe a decoder \(\Decode \colon \F _q^n \to C\) based on coset leaders and a standard array for \(C\). For binary \(C\) sent via a binary symmetric channel, we find the probability \(P_{\mathrm
{undetect}}(C)\) of an undetected transmission error. It is related to the weight enumerator of \(C\). We also find the probability \(P_{\mathrm {corr}}(C)\) that a codeword is decoded correctly.</i>
</p>
<!--
...... subsection Cosets and coset leaders ......
-->
<h5 id="autosec-11">Cosets and coset leaders</h5>
<a id="lecnotes_html-autopage-11"></a>


<p>
Our next objective is a <i>decoder</i> for a linear code \(C\), i.e., an algorithm which defines a function \(\Decode \colon \F _q^n\to C\) such that \(\Decode (\ul y)\) is a nearest neighbour of \(\ul y\) in \(C\). It turns out that the following
notion is of direct relevance to decoding:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-12"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (coset)</span>.                Given a linear code \(C\subseteq \F _q^n\) and a vector \(\ul y\in \F _q^n\), the set
</p>

<p>
\[ \ul y + C = \{\ul y + \ul c\mid \ul c \in C\} \]
</p>

<p>
is called the <b><i>coset</i></b> of \(\ul y\).
</p>

</li>

</ul>

</div>

<p>
We recall basic facts about cosets (see for example <i>Algebraic Structures 1</i>):
</p>
<ul style="list-style-type:none">

<li>
<p>
• \(C=\ul 0+C\) is itself a coset. (\(C\) is called the <i>trivial coset</i>.) Moreover, \(C\) is the coset of any codeword \(\ul c\in C\).
</p>
</li>
<li>


<p>
• If \(\ul y,\ul z\in \F _q^n\), then either \(\ul y + C = \ul z+C\) (<i>this happens if \(\ul y-\ul z\in C\)</i>) or \((\ul y + C)\cap (\ul z+C)=\varnothing \).
</p>
</li>
<li>


<p>
• \(\#(\ul y+C)=\#C=q^k\).
</p>
</li>
<li>


<p>
• There are \(\dfrac {\#\F _q^n}{\#C}=q^{n-k}\) distinct cosets.
</p>
</li>
</ul>

<p>
Thus, the whole space \(\F _q^n\) is split (<i>partitioned</i>) into \(q^{n-k}\) cosets:
</p>

<p>
\[ \F _q^n = C \sqcup (\ul a_1+C)\sqcup \ldots \sqcup (\ul a_{q^{n-k}-1}+C). \]
</p>

<p>
The above is true for cosets in arbitrary abelian groups. We need, however, a notion specific to Coding Theory:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-13"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (coset leader)</span>.   A <b><i>coset leader</i></b> of a coset \(\ul y+C\) is a vector of minimum weight in \(\ul y +C\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-14"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnotedefinition"> (non-uniqueness of coset leader)</span>.   There may be more than one coset leader in a coset. However, all coset leaders of a given coset are of the
same weight — the minimum of all weights of vectors in the coset.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">4.1</span></span><span class="amsthmnotedefinition"> (the formula for a decoder for a linear code)</span>.   <a
id="prop:err"></a> For a linear code \(C\subseteq \F _q^n\), any decoder \(\Decode \colon \F _q^n \to C\) satisfies:
</p>

<p>
\[ \forall \ul y\in \F _q^n\quad \Decode (\ul y)=\ul y - \ul e \text { where $\ul e$ is a coset leader of the coset $\ul y + C$ of $\ul y$.} \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-16"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(\ul v=\Decode (\ul y)\). Then \(\ul v\in C\). Put \(\ul e=\ul y - \ul v\). Since \(C\) is a linear code, \(-\ul v\in C\), so \(\ul e=\ul y + (-\ul v)\in \ul y + C\). We have
proved that \(\ul e\) must lie in the coset \(\ul y+C\).
</p>

<p>
Furthermore, by Lemma&nbsp;<a href="ch3.html#lem:dist-weight">3.1</a> \(d(\ul y,\ul v)=w(\ul y-\ul v)=w(\ul e)\). The decoder must decode \(\ul y\) to a nearest neighbour of \(\ul y\) in \(C\), that is, to minimise \(d(\ul y,\ul
v)\); hence the decoder must choose \(\ul e\) so that \(w(\ul e)\) is minimal in the coset \(\ul y+C\). Hence by definition of a coset leader, \(\ul e\) must be a coset leader of the coset \(\ul y+C\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Standard array: construction ......
-->
<h5 id="autosec-17">Standard array: construction</h5>
<a id="lecnotes_html-autopage-17"></a>


<p>
The following construction is a way to construct all cosets and to find one coset leader for every coset for a given linear code \(C\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-18"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (standard array)</span>.                 A <b><i>standard array</i></b> for a linear code \(C\subseteq \F _q^n\) is a table with the following properties.
The table has \(|C|=q^k\) columns and \(q^{n-k}\) rows. Each row is a coset. The leftmost entry in each row is a coset leader of that row. Row 0 is the trivial coset (i.e., \(C\) itself). Each entry in the table is the sum of the leftmost entry in its
row and the top entry in its column. The table contains every vector from \(\F _q^n\) exactly once.
</p>

</li>

</ul>

</div>

<p>
We will show how to construct a standard array, using the linear code \(C=\{0000\), \(0111\), \(1011, 1100\} \subseteq \F _2^4\) as an example. (In fact, this code is the even weight code of length \(3\) with last bit repeated; but the origin of
the code is not important for the standard array construction.)
</p>

<p>
<b>Row 0 of the standard array:</b> lists all <i>codevectors</i> (elements of \(C=\ul 0+C\)). They must start from \(\ul 0\), but otherwise the order is arbitrary.
</p>
<div class="center">

<p>
\(0000\qquad 0111 \qquad 1011 \qquad 1100\)
</p>
</div>

<p>
<b>Row 1:</b> choose a vector \(\ul a_1\) of smallest weight not yet listed. Because of its minimum weight, that vector will automatically be a coset leader. Fill in Row 1 by adding \(\ul a_1\) to each codevector in Row 0.<br />
Say, \(\ul a_1=0001\). To list its coset, add it to row \(0\): e.g., \(0001+0111=0110\), etc.
</p>
<div class="center">

<p>
\(0001\qquad 0110\qquad 1010 \qquad 1101\)
</p>
</div>

<p>
<b>Row 2:</b> choose \(\ul a_2\) of smallest weight not yet listed, and do the same as for Row 1.<br />
Say, \(\ul a_2=0010\), add it to row 0:
</p>
<div class="center">

<p>
\(0010\qquad 0101\qquad 1001\qquad 1110\)
</p>
</div>

<p>
<b>Row 3:</b> same with, say, \(\ul a_3=0100\):
</p>
<div class="center">

<p>
\(0100\qquad 0011\qquad 1111\qquad 1000\)
</p>
</div>

<p>
We obtain the following standard array for the code \(C=\{0000\), \(0111\), \(1011, 1100\}\):
</p>

<p>
\[ \begin {matrix} 0000&amp; 0111 &amp; 1011 &amp; 1100 \\ 0001&amp; 0110&amp; 1010 &amp; 1101 \\ 0010&amp; 0101&amp; 1001&amp; 1110 \\ 0100&amp; 0011&amp; 1111&amp; 1000 \end {matrix} \]
</p>
<!--
...... subsection Standard array: decoding ......
-->
<h5 id="autosec-23">Standard array: decoding</h5>
<a id="lecnotes_html-autopage-23"></a>


<p>
Let \(C\subseteq \F _q^n\) be a linear code. By Proposition <a href="ch4.html#prop:err">4.1</a>, any decoder is given by
</p>

<p>
\[ \Decode (\ul y) = \ul y - \texttt {COSET LEADER}(\ul y+C). \]
</p>

<p>
This suggests the following decoding algorithm for \(C\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-24"></a>
<span class="amsthmnamedefinition">Algorithm</span><span class="amsthmnumberdefinition"> <span class="textup">4.2</span></span><span class="amsthmnotedefinition"> (the standard array decoder)</span>.
</p>

<p>
<i>Preparation</i>.
</p>
<ul style="list-style-type:none">


<li>
<p>
• Construct a standard array for \(C\).
</p>
</li>
</ul>

<p>
<i>Decoding</i>.
</p>
<ul style="list-style-type:none">


<li>
<p>
• Receive a vector \(\ul y\in \F _q^n\).
</p>


</li>
<li>


<p>
• Look up \(\ul y\) in the standard array.
</p>


</li>
<li>


<p>
• Return the topmost vector of the column of \(\ul y\) as \(\Decode (\ul y)\).
</p>
</li>
</ul>

<p>
<b>Justification:</b> the algorithm is correct because, by definition of a standard array,
</p>
<ul style="list-style-type:none">


<li>
<p>
(a) Look-up of \(\ul y\) will succeed as every vector in \(\F _q^n\) is present in the array;
</p>


</li>
<li>


<p>
(b) the row of \(\ul y\) starts with \(\texttt {COSET LEADER}(\ul y+C)\), so
</p>


</li>
<li>


<p>
(c) the top of \(\ul y\)’s column is \(\ul y - \texttt {COSET LEADER}(\ul y+C)\) so this is \(\ul y\) decoded.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Example</span>.
</p>

<p>
Using the standard array decoder for the binary code \(C=\{0000,0111,1011,1100\}\) with the standard array constructed above,
</p>
<ul style="list-style-type:none">


<li>
<p>
• decode the received vectors \(0011\) and \(1100\);
</p>


</li>
<li>


<p>
• give an example of one bit error occurring in a codeword and being corrected;
</p>


</li>
<li>


<p>
• give an example of one bit error occurring in a codeword and not being corrected.
</p>
</li>
</ul>

<p>
<b>Solution.</b> We work with the following standard array for \(C\):
</p>

<p>
\[ \begin {matrix} 0000&amp; 0111 &amp; 1011 &amp; 1100 \\ 0001&amp; 0110&amp; 1010 &amp; 1101 \\ 0010&amp; 0101&amp; 1001&amp; 1110 \\ 0100&amp; 0011&amp; 1111&amp; 1000 \end {matrix} \]
</p>

<p>
The received vector \(0011\) is in the second column, so \(\Decode (0011)=0111\). The received vector \(1100\) is a codeword (in the fourth column), so \(\Decode (1100)=1100\).
</p>

<p>
Suppose that the codeword \(0000\) is sent. If an error occurs in the last bit, the word \(0001\) is received and decoded correctly as \(0000\). If an error occurs in the first bit, the word \(1000\) is received and decoded incorrectly as \(1100\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-26"></a>
<span class="amsthmnamedefinition">Remark</span><span class="amsthmnotedefinition"> (a standard array decoder is not unique)</span>.
</p>

<p>
Recall that there may be more than one possible standard array for the code \(C\). Indeed, in the above example the coset \(0100+C\) has two coset leaders: \(0100\) and \(1000\). Thus, we could construct a different standard array for \(C\):
</p>

<p>
\[ \begin {matrix} 0000&amp; 0111 &amp; 1011 &amp; 1100 \\ 0001&amp; 0110&amp; 1010 &amp; 1101 \\ 0010&amp; 0101&amp; 1001&amp; 1110 \\ 1000&amp; 1111&amp; 0011&amp; 0100 \end {matrix} \]
</p>

<p>
The decoder associated to this standard array is different from the decoder considered above. Both decoders decode the same linear code \(C\). A linear code can have more than one decoder.
</p>

<p>
However, if \(C\) is a perfect linear code, then each coset has only one coset leader, so the decoder is unique. This property of perfect codes appears on the example sheets.
</p>

</li>

</ul>

</div>
<!--
...... subsection Reminder (the number of errors corrected by a code) ......
-->
<h5 id="autosec-27">Reminder (the number of errors corrected by a code)</h5>
<a id="lecnotes_html-autopage-27"></a>


<p>
Recall that a code with minimum distance \(d\) corrects \(t=\left [ (d-1)/2 \right ]\) errors.
</p>

<p>
The code \(C\) in the above example is linear, hence \(d(C)=w(C)=2\) (it is easy to find the minimum weight of the code by inspection). This means that the code corrects \(\left [\frac {2-1}{2}\right ]=0\) errors. That is, \(C\) is not
guaranteed to corect even a single bit error occurring in a codevector. And indeed, we saw in an example how one bit error occurred in a codevector and was not corrected.
</p>

<p>
So, from the point of view of Hamming’s theory, this code \(C\) has no error-correcting capability. It still detects up to one error.
</p>

<p>
But in Shannon’s theory, error-detecting and error-correcting performance of a code are measured probabilistically.
</p>
<!--
...... subsection Error-detecting and error-correcting performance of a linear code: Shannon’s theory point of view ......
-->
<h5 id="autosec-28">Error-detecting and error-correcting performance of a linear code: Shannon’s theory point of view</h5>
<a id="lecnotes_html-autopage-28"></a>
<!--
...... subsection The probability of an undetected error ......
-->
<h5 id="autosec-29">The probability of an undetected error</h5>
<a id="lecnotes_html-autopage-29"></a>


<p>
Shannon’s Information Theory is interested in how likely is it that a transmission error in a codeword is not detected/corrected by a decoder of \(C\).
</p>

<p>
We will answer these questions for a binary linear code \(C\), but we need to have a stochastic model of the noise. Here it is:
</p>

<p>
<b>Assumption.</b> The channel is \(\mathit {BSC}(p)\), the binary symmetric channel with bit error rate \(p\).
</p>

<p>
Recall that this means that one bit (\(0\) or \(1\)), transmitted via the channel, arrives unchanged with probability \(1-p\), and gets flipped with probability \(p\):
</p>
<div class="center">

<p>

<a href="bsc.svg" target="_blank" ><img
    src="bsc.svg"
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>

<p>
When a codeword \(\ul v\) is transmitted, the channel generates a random error vector and adds it to \(\ul v\). By definition of \(\mathit {BSC}(p)\), for a given \(\ul e\in \F _2^n\) one has
</p>

<p>
\[ P(\text {the error vector equals }\ul e) = (1-p)^{n-i}p^i, \qquad \text {where }i=w(\ul e).                  \]
</p>

<p>
It turns out that in determining the probability of an undetected error, the following notion is very useful:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-31"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (the weight enumerator)</span>.
</p>

<p>
The <b><i>weight enumerator</i></b> of a linear code \(C\subseteq \F _q^n\) is
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{0}\)</span>



<!--


                                                                                                         X
                                                                                           WC (x, y) =         xn−w(v) y w(v)
                                                                                                         v∈C

                                                                                                    = A0 xn + A1 xn−1 y + A2 xn−2 y 2 + . . . + An y n



-->



<p>


\begin{align*}
W_C(x,y) &amp; = \sum _{\ul v\in C}x^{n-w(\ul v)}y^{w(\ul v)} \\ &amp; = A_0x^n+A_1x^{n-1}y+A_2x^{n-2}y^{2}+\ldots +A_ny^n
\end{align*}
where \(A_i = \#\{\ul v\in C: w(\ul v)=i\}\). The weight enumerator of \(C\) is a polynomial in two variables \(x,y\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-32"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">4.3</span></span><span class="amsthmnotedefinition"> (\(P_{\mathrm {undetect}}(C)\), the probability of an
undetected error)</span>.   Suppose that a codevector of a binary linear code \(C\) of length \(n\) is transmitted via \(\mathit {BSC}(p)\). Then the probability of an undetected transmission error \(P_{\mathrm {undetect}}(C) =
W_C(1-p,p)-(1-p)^n\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-33"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(\ul v\in C\) be the codevector being transmitted. Recall that an <i>undetected error</i> means that the received vector \(\ul v+\ul e\) is a codevector not equal to \(\ul v\). Note that,
since \(\ul v\in C\) and \(C\) is a vector space,
</p>

<p>
\[ \ul v + \ul e \in C, \ \ul v+\ul e\ne \ul v \quad \iff \quad \ul e \in C, \ \ul e\ne \ul 0.               \]
</p>

<p>
Therefore, <i>an undetected error means that the error vector is a non-zero codevector.</i> We can now calculate
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{0}\)</span>



<!--


                                                                                                                                   X
                                                                                        Pundetect (C) = P (undetected error) =               P (the error vector is e)
                                                                                                                                 e∈C, e̸=0
                                                                                                                                   X
                                                                                                                            =            (1 − p)n−w(e) pw(e) .
                                                                                                                                 e∈C, e̸=0




-->



<p>


\begin{align*}
P_{\mathrm {undetect}}(C) = P(\text {undetected error}) &amp;= \sum _{\ul e\in C,\, \ul e\ne \ul 0} P(\text {the error vector is }\ul e)\\ &amp;=\sum _{\ul e\in C,\, \ul e\ne \ul 0} (1-p)^{n-w(\ul e)}p^{w(\ul e)}.
\end{align*}
This sum is \(W_C(1-p,p)\) without one term. The missing term, excluded by the condition \(\ul e\ne \ul 0\), is exactly
</p>

<p>
\[ (1-p)^{n-w(\ul 0)}p^{w(\ul 0)} = (1-p)^n, \]
</p>

<p>
which gives the expression for \(P_{\mathrm {undetect}}(C) \) as stated. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-34"></a>
<span class="amsthmnamedefinition">Remark</span>.         In general, \(P_{\mathrm {undetect}}(C) \) is calculated assuming that the codeword \(\ul v\) is picked at random from the code, with all codewords equally likely to be picked.
However, our proof shows that for a <i>linear</i> binary code and for the binary <i>symmetric</i> channel the probability is the same for all codevectors.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-35"></a>
<span class="amsthmnamedefinition">Example</span>.         For the binary code \(C=\{0000,0111,1011,1100\}\) as above, the weight enumerator is
</p>

<p>
\[ W_C(x,y)= x^4 + x^2y^2 + 2xy^3, \]
</p>

<p>
because \(C\) has one codeword of weight \(0\), zero codewords of weight \(1\), one codeword of weight \(2\) and two codewords of weight \(3\). If a codeword of \(C\) is transmitted via \(\mathit {BSC}(p)\), then an undetected error occurs with
probability \(P_{\mathrm {undetect}} = (1-p)^2 p^2 + 2(1-p)p^3 \).
</p>

</li>

</ul>

</div>

<p>
<b>Discussion.</b> When is it important to know \(P_{\mathrm {undetect}}(C)\)? A code is used in a situation where the receiver can request retransmission if an error is detected. Assuming this results in a correct transmission (i.e., neglecting
the probability that undetected errors creep up in <i>retransmitted</i> codevectors), \(P_{\mathrm {undetect}}(C)\) is on average the proportion of incorrect codevectors, hence incorrect symbols, accepted by the receiver. A code should be
designed for a particular channel so as to keep this probability below an agreed threshold.
</p>
<!--
...... subsection The probability of correct decoding ......
-->
<h5 id="autosec-36">The probability of correct decoding</h5>
<a id="lecnotes_html-autopage-36"></a>


<p>
We will now find the probability of an error being <i>corrected</i> for \(C\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-37"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">4.4</span></span><span class="amsthmnotedefinition"> (\(P_{\mathrm {corr}}(C)\), the probability of correct
decoding)</span>.   <a id="thm:pcorr"></a> Suppose that a codevector of a binary linear code \(C\) is transmitted via \(\mathit {BSC}(p)\). The probability that the received vector will be decoded corectly is
</p>

<p>
\[ P_{\mathrm {corr}} (C)= \sum _{i=0}^n \alpha _i (1-p)^{n-i}p^i, \]
</p>

<p>
where \(\alpha _i\) denotes the number of cosets where the coset leader is of weight&nbsp;\(i\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-38"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Recall that \(\ul v\in C\) is <i>decoded correctly</i> if \(\Decode (\ul v+\ul e)=\ul v\). By Proposition <a href="ch4.html#prop:err">4.1</a>,
</p>
<span class="hidden"> \(\seteqnumber{0}{4.}{0}\)</span>



<!--



                                                                                                       DECODE(v + e) = v + e − COSET LEADER(v + e)
                                                                                                                    = v + e − COSET LEADER(e).



-->



<p>


\begin{align*}
\Decode (\ul v+\ul e)&amp;=\ul v + \ul e - \texttt {COSET LEADER}(\ul v+\ul e)\\ &amp; = \ul v + \ul e - \texttt {COSET LEADER}(\ul e).
\end{align*}
Therefore, <i>correct decoding occurs whenever the error vector is the chosen coset leader of its coset</i>.
</p>

<p>
We therefore have one good outcome per coset: namely, \(\ul e\) equals the chosen coset leader of the coset. Recall that that happens with probability \((1-p)^{n-i}p^i\) where \(i\) is the weight of the coset leader of the given coset. Summing
over all cosets and gathering the like terms, we obtain the formula for \(P_{\mathrm {corr}} (C)\) as stated (it does not depend on \(\ul v\)). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<b>Discussion.</b> When is it important to know \(P_{\mathrm {corr}}(C)\)? In one-way communication channels there is no retransmission even if an error is detected, hence the decoder is used to produce a best guess as to which codevector
was sent. Thus, \(1-P_{\mathrm {corr}}(C)\) is on average the proportion of incorrect codevectors, hence incorrect symbols, accepted by the receiver in this case. Once again, a code should be designed for a particular channel so as to keep
\(1-P_{\mathrm {corr}}(C)\) below an agreed threshold.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-39"></a>
<span class="amsthmnamedefinition">Example</span>.           Recall the code with a standard array
</p>

<p>
\[ \begin {matrix} 0000&amp; 0111 &amp; 1011 &amp; 1100 \\ 0001&amp; 0110&amp; 1010 &amp; 1101 \\ 0010&amp; 0101&amp; 1001&amp; 1110 \\ 1000&amp; 1111&amp; 0011&amp; 0100 \end {matrix} \]
</p>

<p>
One has \(\alpha _0=1\), \(\alpha _1=3\), \(\alpha _2=\alpha _3=0\), so \(P_{\mathrm {corr}} (C)=(1-p)^4+3(1-p)^3 p\).
</p>

<p>
<b>Approximation.</b> For this code, \(P_{\mathrm {undetect}} = (1-p)^2 p^2 + 2(1-p)p^3\), which is a polynomial of the form \(p^2+o(p^2)\) where \(o(p^2)\) contains powers of \(p\) strictly higher than \(2\). For \(p\ll 1\), that is,
\(p\) very small, the terms in \(o(p^2)\) are negligible compared to \(p^2\). So for practical purposes we may write \(P_{\mathrm {undetect}}\sim p^2\) which means that the average proportion of bad bits in the output goes down from \(p\)
(unencoded information) to \(p^2\) — if we can use error detection and retransmission.
</p>

<p>
However, if error correction is used (e.g., there is no possibility to retransmit if an error is detected), \(1-P_{\mathrm {corr}}(C)=1-(1-p)^4-3(1-p)^3 p=p+o(p)\), i.e., is of order \(p\). There is no substantial improvement over transmitting the
unencoded information where the proportion of bad bits in the output is \(p\).
</p>

<p>
Note that the rate of \(C\) is \(R= 0.5\), so in this case a two-fold increase in the volume of information which needs to be transmitted has no effect on error correction.
</p>

<p>
Shannon theory’s observation about \(C\) is roughly in line with what arises from Hamming’s theory which does not look at specific channels such as \(\mathit {BSC}(p)\): \(C\) detects up to \(1\) error but corrects \(0\) errors.
</p>

<p>
The main reason for such a weak performance is that \(C\) is not a good code.
</p>

<p>


</p>

</li>

</ul>

</div>
<!--
...... subsection Discussion: how can one improve performance of error-correcting codes?                    ......
-->
<h5 id="autosec-40">Discussion: how can one improve performance of error-correcting codes?</h5>
<a id="lecnotes_html-autopage-40"></a>


<p>
1. One can use longer codes (increase \(n\)).
</p>

<p>
However, decoding is going to be a problem. We described the standard array decoding algorithm for linear codes. Its main disadvantage is the <i>storage requirement</i>: the standard array contains <i>all vectors</i> of length \(n\) and must be
stored in memory while the decoder operates. This requires an amount of memory proportional to \(nq^n\).
</p>

<p>
<b>Example:</b> The Voyager 1 and 2 deep space missions used a binary code of length \(24\) to transmit colour photographs of Jupiter and Saturn back to Earth in 1979–81. A standard array decoder for this code would require \(24\times
2^{24}\) bits of memory, which is \(48\) Mbytes. This is little by today’s standards, however, the Voyager 1 spacecraft has recently left the Solar system with \(68\) <i>kilobytes</i> of onboard memory...
</p>

<p>
In the next section, we will introduce an improved technique called <i>syndrome decoding</i>. It will require significantly less memory, but decoding a received vector will require more computation. Syndrome decoding is based on the notion of a
dual code.
</p>

<p>
2. One can use codes which correct more errors.
</p>

<p>
Codes should still be structured, not random, otherwise decoding may not be computationally feasible. In the rest of the course, we will construct several families of codes algebraically.
</p>

<p>
3. One can invent something substantially new, e.g., practical applications of quantum codes.
</p>

<p>
This is an idea for the future, and such material will not be covered in the course this year.
</p>

<p>
<i>End of discussion.</i>
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch4ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-42"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch4ex ......
-->
<h3 id="autosec-43">Chapter&nbsp;<span class="sectionnumber">4&#x2003;</span>Exercises to Chapter 4 </h3>
<a id="lecnotes_html-autopage-43"></a>
<a id="lecnotes_html-autofile-11"></a>

<p>
Version 2022-10-11. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.1</span></span><span class="amsthmnotedefinition"> (important fact about perfect linear codes — needed for
exam)</span>.    Let \(C\) be a linear \([n,k,d]_q\)-code. As usual, let \(t=\left [\frac {d-1}{2}\right ]\). Show:
</p>

<p>
(a) Every vector in \(\F _q^n\) of weight \(\le t\) is a <b>unique coset leader</b> of its coset (<i>i.e., is a coset leader, and its coset has no other coset leaders</i>).
</p>

<p>
(<i>Hint</i>: if \(\ul a_1,\ul a_2\) are coset leaders of a coset, then \(\ul a_1-\ul a_2\) is a codevector of weight \(\le w(\ul a_1)+w(\ul a_2)=2w(\ul a_1)\).)
</p>

<p>
(b) If \(C\) is perfect, the number of distinct cosets equals \(\#S_t(\ul 0)\).
</p>

<p>
(<i>Hint.</i> By the Hamming bound, \(M\times \#S_t(\ul 0)\le q^n\), or is it \(=q^n\)?)
</p>

<p>
(c) Deduce that if \(C\) is perfect, every coset has a unique coset leader, all coset leaders are of weight \(\le t\), and the set of all coset leaders is \(S_t(\ul 0)\).
</p>

</li>

</ul>

</div>

<p>
[<a href="ch4exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.2</span></span>.                     Find standard arrays for binary codes with each of the following generator matrices. For each code,
determine whether every coset has a unique coset leader (i.e., if there is exactly one coset leader in each coset). Find the probability of an undetected / uncorrected error for \(\mathit {BSC}(p)\) and argue whether the code is worth using for this
channel, compared to transmitting unencoded information.
</p>

<p>
\[ G_1=\begin {bmatrix} 1&amp;0 \\ 0&amp;1 \end {bmatrix}, \qquad G_2=\begin {bmatrix} 1&amp;0&amp;1 \\ 0&amp;1&amp;1 \end {bmatrix}, \qquad G_3 = \begin {bmatrix} 1&amp;0&amp;1 &amp;1&amp;0\\
0&amp;1&amp;0&amp;1&amp;1 \end {bmatrix}.         \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
[<a href="ch4exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.3</span></span><span class="amsthmnotedefinition"> (weight enumerators)</span>.   (a) As usual, let \(W_C(x,y)\)
denote the weight enumerator of a \(q\)-ary linear code \(C\). Show that \(W_C(1,0)=1\) and that \(W_C(1,1)=q^k\) where \(k=\dim C\).
</p>

<p>
(b) Show that the weight enumerator of the trivial binary code \(\F _2^n\) is \(W_{\F _2^n}(x,y)=(x+y)^n\). Can you write \(W_{\F _q^n}(x,y)\) in a similar form?
</p>

<p>
(c) Find the weight enumerator of \(\text {Rep}(n,\F _2)\), more generally of \(\text {Rep}(n,\F _q)\).
</p>

<p>
(d) Write down \(W_{E_3}(x,y)\). Can you suggest a compact way to write \(W_{E_n}(x,y)\)?
</p>

<p>
(e) Write down the weight enumerator of the binary simplex code \(\Sigma \), considered earlier.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch4exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch4exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch4exans ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">4&#x2003;</span>Exercises to Chapter 4 — solutions</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-12"></a>

<p>
Version 2022-10-11. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.1</span></span><span class="amsthmnotedefinition"> (important fact about perfect linear codes — needed for
exam)</span>.    Let \(C\) be a linear \([n,k,d]_q\)-code. As usual, let \(t=\left [\frac {d-1}{2}\right ]\). Show:
</p>

<p>
(a) Every vector in \(\F _q^n\) of weight \(\le t\) is a <b>unique coset leader</b> of its coset (<i>i.e., is a coset leader, and its coset has no other coset leaders</i>).
</p>

<p>
(<i>Hint</i>: if \(\ul a_1,\ul a_2\) are coset leaders of a coset, then \(\ul a_1-\ul a_2\) is a codevector of weight \(\le w(\ul a_1)+w(\ul a_2)=2w(\ul a_1)\).)
</p>

<p>
(b) If \(C\) is perfect, the number of distinct cosets equals \(\#S_t(\ul 0)\).
</p>

<p>
(<i>Hint.</i> By the Hamming bound, \(M\times \#S_t(\ul 0)\le q^n\), or is it \(=q^n\)?)
</p>

<p>
(c) Deduce that if \(C\) is perfect, every coset has a unique coset leader, all coset leaders are of weight \(\le t\), and the set of all coset leaders is \(S_t(\ul 0)\).
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E4.1. </b> [<a href="ch4ex.html#.">These exercises without answers</a>]
</p>

<p>
Let \(\ul a\in \F _q^n\). We show that if \(w(\ul a)&lt;d/2\), then \(\ul a\) has strictly minimal weight in its coset \(\ul a+C=\{\ul a+\ul c\mid \ul c\in C\}\).
</p>

<p>
Indeed, using the triangle inequality: \(w(\ul a+\ul c)+w(\ul a) = d(\ul a+\ul c,\ul 0)+d(\ul 0, \ul a) \ge d(\ul a+\ul c, \ul a)=w(\ul a+\ul c - \ul a) = w(\ul c)\). If \(\ul c\ne \ul 0\), we have \(w(\ul a+\ul c)\ge w(\ul
c) -w(\ul a) \ge d - d/2=d/2\) so \(w(\ul a + \ul c)&gt;w(\ul a)\) as claimed.
</p>

<p>
(b) \(C\) is perfect iff \(\#C=\dfrac {q^n}{\#S_t(\ul 0)}\) (the right-hand side is the Hamming bound). Then the number of cosets is \(\dfrac {q^n}{\#C}=\#S_t(\ul 0)\).
</p>

<p>
(c) By (a), the vectors \(\ul y\in S_t(\ul 0)\) are unique coset leaders of \(\#S_t(\ul 0)\) distinct cosets. By (b), these are all possible cosets, so we are done.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.2</span></span>.                       Find standard arrays for binary codes with each of the following generator matrices. For each code,
determine whether every coset has a unique coset leader (i.e., if there is exactly one coset leader in each coset). Find the probability of an undetected / uncorrected error for \(\mathit {BSC}(p)\) and argue whether the code is worth using for this
channel, compared to transmitting unencoded information.
</p>

<p>
\[ G_1=\begin {bmatrix} 1&amp;0 \\ 0&amp;1 \end {bmatrix}, \qquad G_2=\begin {bmatrix} 1&amp;0&amp;1 \\ 0&amp;1&amp;1 \end {bmatrix}, \qquad G_3 = \begin {bmatrix} 1&amp;0&amp;1 &amp;1&amp;0\\
0&amp;1&amp;0&amp;1&amp;1 \end {bmatrix}.          \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<b>Answer to E4.2. </b> [<a href="ch4ex.html#.">These exercises without answers</a>]
</p>

<p>
\(G_1\) generates the trivial binary code of length \(2\). Because the code is the whole space \(\F _2^2\), its standard array consists of one row:
</p>

<p>
\[ 00 \quad 01 \quad 10 \quad 11 \]
</p>

<p>
(the order of the codevectors after \(00\) is arbitrary). The only coset is the trivial coset which has only one coset leader, \(00\).
</p>

<p>
\(G_2\) generates \(E_3\), the even weight code of length \(3\). It has \(4\) codevectors and \(2\) cosets:
</p>

<p>
\[ \begin {matrix} 000 &amp; 101 &amp; 011 &amp; 110 \\ 001 &amp; 100 &amp; 010 &amp; 111 \end {matrix} \]
</p>

<p>
Note that the non-trivial coset has three coset leaders; any of them could be put in column&nbsp;1.
</p>

<p>
\(G_3\): list all the \(4\) codevectors and then use the algorithm for constructing the standard array. One possible answer is given below:
</p>

<p>
\[ \begin {matrix} 00000&amp;10110&amp;01011&amp;11101\\ 10000&amp;00110&amp;11011&amp;01101\\ 01000&amp;11110&amp;00011&amp;10101\\ 00100&amp;10010&amp;01111&amp;11001\\ 00010&amp;10100&amp;01001&amp;11111\\
00001&amp;10111&amp;01010&amp;11100\\ 11000&amp;01110&amp;10011&amp;00101\\ 01100&amp;11010&amp;00111&amp;10001 \end {matrix} \]
</p>

<p>
Coset leaders of weight \(0\) and \(1\) are the only coset leaders in their cosets. Coset leaders of weight \(2\) are not unique: e.g., \(11000\) and \(00101\) are coset leaders of the same coset.
</p>

<p>
<b>Error probabilities.</b> <b>The code generated by \(G_1\)</b> is the trivial code, so using it is the same as sending unencoded information.
</p>

<p>
<b>The code generated by \(G_2\)</b> has weight enumerator \(W_{E_3}(x,y)=x^3+3xy^2\). Hence an undetected error occurs with probability \(P_{\mathrm {undetect}}(E_3)=W_{E_3}(1-p,p)-(1-p)^3 = 3(1-p)p^2 \sim 3p^2\). Note that
this is of the same order as \(p^2\) but at a rate of \(2/3\) (recall the code considered in the chapter with worse rate \(1/2\)).
</p>

<p>
The probability of an uncorrected error here is \(1-P_{\mathrm {corr}}(E_3) = 1 - (\alpha _0 (1-p)^3+\alpha _1p(1-p)^2)\) where \(\alpha _0=1\) (one coset leader of weight \(0\)) and \(\alpha _1=1\) (one coset leader of weight \(1\)) .
We have \(1-P_{\mathrm {corr}}(E_3) =1-((1-p)^3+ p(1-p)^2)=1-(1-p+p)(1-p)^2= 1-(1-p)^2\sim 2p\).
</p>

<p>
The code \(E_3\) does not improve the probability of incorrect decoding. Indeed, Hamming’s theory says that \(E_3\) has no error-correcting capability and can only be used for error detection.
</p>

<p>
<b>The code generated by \(G_3\)</b> has weight enumerator \(x^5+2x^2y^3+xy^4\). Hence \(P_{\mathrm {undetect}}=2(1-p)^2p^3 + (1-p)p^4 \sim 2p^3\). If \(p=0.01\), this is \(\approx 2\times 10^{-6}\), which is 10,000 times better
than without encoding.
</p>

<p>
The \(1-P_{\mathrm {corr}}\) is left as an exercise: show that if \(p=0.01\), incorrect decoding occurs with probability \(\approx 8\times 10^{-4}\), which is \(12.5\) times better than without encoding.
</p>

<p>
Of course, this improvement in reliability comes at a price: the rate of the code is only \(0.4\), meaning that we have to transmit \(2.5\) times as much information.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">4.3</span></span><span class="amsthmnotedefinition"> (weight enumerators)</span>.                      (a) As usual, let \(W_C(x,y)\)
denote the weight enumerator of a \(q\)-ary linear code \(C\). Show that \(W_C(1,0)=1\) and that \(W_C(1,1)=q^k\) where \(k=\dim C\).
</p>

<p>
(b) Show that the weight enumerator of the trivial binary code \(\F _2^n\) is \(W_{\F _2^n}(x,y)=(x+y)^n\). Can you write \(W_{\F _q^n}(x,y)\) in a similar form?
</p>

<p>
(c) Find the weight enumerator of \(\text {Rep}(n,\F _2)\), more generally of \(\text {Rep}(n,\F _q)\).
</p>

<p>
(d) Write down \(W_{E_3}(x,y)\). Can you suggest a compact way to write \(W_{E_n}(x,y)\)?
</p>

<p>
(e) Write down the weight enumerator of the binary simplex code \(\Sigma \), considered earlier.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E4.3. </b> [<a href="ch4ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) Recall \(W_C(x,y)=\sum _{\ul c \in C} x^{n-w(\ul c)}y^{w(\ul c)}\). If \(y=0\), the only non-zero term in this sum is the term without \(y\) which corresponds to the (unique) zero codevector of the linear code \(C\); thus,
\(W_C(x,0)=x^n\) and \(W_C(1,0)=1\). Also, \(W_C(1,1)=\sum _{\ul c\in C}1=\#C=q^k\).
</p>

<p>
(b) To work out \(W_{\F _q^n}(x,y)\), write it in the form \(W_{\F _q^n}(x,y)=\sum _{i=0}^n A_ix^{n-i}y^{i}\) where \(A_i=\#\{\ul v\in \F _q^n:           w(\ul v)=i\}\). Note that \(w(\ul v)=d(\ul v,\ul 0)\), and in the proof of the
Hamming bound we calculated the number of words at distance \(i\) from \(\ul 0\) (or from any other fixed vector) to be \(\binom ni(q-1)^i\). Hence
</p>

<p>
\[ W_{\F _q^n}(x,y) = \sum _{i=0}^n \binom ni (q-1)^i x^{n-i}y^{i} = (x+(q-1)y)^n.             \]
</p>

<p>
(c) \(\text {Rep}(n,\F _2)\) has one codevector of weight \(0\) and one codevector of weight \(n\). Hence \(W_{\text {Rep}(n,\F _2)}(x,y)=x^n+y^n\).
</p>

<p>
<b>Exercise:</b> show that \(W_{\text {Rep}(n,\F _q)}(x,y)=x^n + (q-1) y^n\).
</p>

<p>
(d) The even weight code \(E_3\) is \(\{000,011,101,110\}\), so that \(W_{E_3}(x,y)=x^3+3xy^2\). The weight enumerator of \(E_n\) will be obtained in the lectures as an application of the MacWilliams identity.
</p>

<p>
(e) The code \(\Sigma \) of length 7 contains \(\ul 0\) and seven codevectors of weight \(4\), hence \(W_\Sigma (x,y)=x^7+7x^3y^4\).
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch5.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch5 ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">5&#x2003;</span>The dual code. Syndrome decoding</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-13"></a>

<p>
Version 2022-10-18. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>Every linear code \(C\) has a dual code, \(C^\perp \), and check matrices. While a generator matrix \(G\) is used to encode messages into codevectors, a check matrix \(H\) serves to detect errors — and to correct them using
syndrome decoding.</i>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-8"></a>
<span class="amsthmnamedefinition">Discussion</span>.
</p>

<p>
Without a complete list of codevectors of a linear code \(C\), it is not clear how to detect errors. Given a received vector \(\ul y\), how to test whether \(\ul y\in C\)? Error correction seems to require a whole standard array. Neither is an option
for codes of large length and dimension, whose use is dictated by modern applications to low-noise channels; in this case, generator matrices are of not much help.
</p>

<p>
Some codes, however, are defined by a single <i>checksum</i> — recall the even weight code and the ISBN-10 code. Extending this approach, we introduce a <i>check matrix</i> which generates the <i>dual code</i>.
</p>

<p>


</p>

</li>

</ul>

</div>
<!--
...... section The inner product of two vectors ......
-->
<h4 id="autosec-9">The inner product of two vectors</h4>
<a id="lecnotes_html-autopage-9"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-10"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (inner product)</span>.            For \(\ul u, \ul v \in \F _q^n\), the scalar (element of \(\F _q\)) defined as \(\ul u \cdot \ul v =\sum _{i=1}^n
u_i v_i \) is called the <b><i>inner product</i></b> of the vectors \(\ul u\) and \(\ul v\).
</p>

</li>

</ul>

</div>

<p>
<b>Example:</b> in \(\F _2^3\), the inner product of the vector \(111\) with itself is \(111\cdot 111=1+1+1=1\) (it is an element of \(\F _2\)).
</p>

<p>
<b>Notation:</b> if \(C\subset \F _q^n\) is a set, \(\ul v\in \F _q^n\), we may write \(\ul v \cdot C\) to denote the set \(\{\ul v \cdot \ul c \mid \ul c\in C\}\). Furthermore, for two sets \(C,D\subseteq \F _q^n\) we may write
\(C\cdot D\) for the set \(\{\ul c \cdot \ul d\mid \ul c\in C,\ul d\in D\}\).
</p>
<!--
...... subsection Properties of the inner product ......
-->
<h5 id="autosec-11">Properties of the inner product</h5>
<a id="lecnotes_html-autopage-11"></a>


<p>
(1) <b>Expression as a matrix product:</b> \(\ul u \cdot \ul v = \ul u \,\ul v^T\).
</p>

<p>
<b>Explanation:</b> we write elements of \(\F _q^n\) as row vectors. Thus, \(\ul u\) is a row vector \((u_1,\ldots ,u_n)\), and \(\ul v^T\) is the transpose of \(\ul v\), so a column vector \(\left (\begin {smallmatrix} v_1\\ v_2 \\
\vdots \\ v_n \end {smallmatrix}\right )\). Multiplying \(\ul u\) and \(\ul v^T\) as matrices (an \(1\times n\) matrix by an \(n\times 1\) matrix), we obtain a \(1\times 1\) matrix, which we identify with a scalar in \(\F _q\).
</p>

<p>
(2) <b>Symmetry:</b> \(\ul u\cdot \ul v=\ul v \cdot \ul u\).
</p>

<p>
<b>Explanation:</b> is easily seen from the definition.
</p>

<p>
(3) <b>Bilinearity:</b> for a scalar \(\lambda \in \F _q\) we have \((\ul u + \lambda \ul w) \cdot \ul v = \ul u \cdot \ul v + \lambda (\ul w \cdot \ul v)\) and \(\ul u\cdot (\ul v + \lambda w) = \ul u \cdot \ul v +
\lambda (\ul u \cdot \ul w)\).
</p>

<p>
<b>Explanation:</b> we know from linear algebra that the matrix product in \(\ul u \,\ul v ^T\) is bilinear.
</p>

<p>
(4) <b>Non-degeneracy:</b> \(\ul u\cdot \F _q^n=\{0\}\), if and only if \(\ul u=0\).
</p>

<p>
<b>Explanation:</b> let \(\ul \epsilon _i=(0,\ldots ,0,1,0,\ldots ,0)\) be the vector whose \(i\)th symbol is \(1\) and all other symbols are \(0\). Then \(\ul u\cdot \ul \epsilon _i=u_i\). So if \(\ul u\cdot \F _q^n=\{0\}\), then
in particular \(\ul u\cdot \ul \epsilon _i=0\) hence \(u_i=0\), for all \(i\) — meaning that \(\ul u\) is the zero vector. And of course if \(\ul u=\ul 0\), then \(\ul u\cdot \ul c=0\) for all \(\ul c\in \F _q^n\).
</p>
<!--
...... section The dual code ......
-->
<h4 id="autosec-12">The dual code</h4>
<a id="lecnotes_html-autopage-12"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-13"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (dual code)</span>.         Given a code \(C \subseteq \F _q^n\), we define the <b><i>dual code</i></b> \(C^\perp \) as
</p>

<p>
\[ C^\perp = \{\ul v \in \F _q^n \mid \ul v \cdot C = \{0\}\} .        \]
</p>

<p>
We can say that \(C^\perp \) consists of all vectors <i><b>orthogonal</b></i> to the code \(C\) (where \(\ul v\) orthogonal to \(C\) means \(\ul v\cdot C=\{0\}\)).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-14"></a>
<span class="amsthmnamedefinition">Exercise</span>.   Using bilinearity of the inner product, show that \(C^\perp \) is a <i>linear</i> code.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (the dual code of the binary repetition code)</span>.       We work out the code \(\text {Rep}(n,2)^\perp \) using the definition. Recall that \(\text
{Rep}(n,2)=\{00\ldots 0, 11\ldots 1\}\subseteq \F _2^n\) is the binary repetition code of length \(n.\)
</p>

<p>
By definition, \(\text {Rep}(n,2)^\perp = \{\ul v\in \F _2^n \mid \ul v \cdot 00\ldots 0=0, \ \ul v\cdot 11\ldots 1=0\}\). The first condition, \(\ul v\cdot 00\ldots 0=0\) is vacuous (holds for all vectors \(\ul v\in \F _2^n\)).
The second condition, \(\ul v\cdot 11\ldots 1\), means \(v_1+v_2+\ldots +v_n=0\) in \(\F _2\), i.e., \(\ul v\in E_n\), the binary even weight code of length&nbsp;\(n\). Thus, \(\text {Rep}(n,2)^\perp = E_n\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-16"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (check matrix)</span>.
</p>

<p>
A <b><i>check matrix</i></b> for a linear code \(C\) means a generator matrix for \(C^\perp \).
</p>

<p>
One sometimes says <i>parity check matrix</i> (the term arose decades ago from applications of binary codes).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-17"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">5.1</span></span>.   <a id="thm:dual-prop"></a> If \(C\subseteq \F _q^n\) is a linear code of dimension \(k\), then:
</p>
<ul style="list-style-type:none">


<li>
<p>
i. \(\dim C^\perp =n-k\);
</p>


</li>
<li>


<p>
ii. \(C=\{\ul v\in \F _q^n:   \ul v H^T=\ul 0\}\) for any check matrix \(H\) of \(C\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-18"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> We recall the <i>Rank-Nullity Theorem</i> from Linear Algebra: if \(M\) is a matrix with \(n\) columns, then
</p>

<p>
\[ \mathrm {rank}(M)+\dim \mathrm {Nullspace}(M)=n, \]
</p>

<p>
where \(\mathrm {rank}(M)\) is the dimension of the span of the rows of \(M\), and \(\mathrm {Nullspace}(M)\) can be written as \(\{\ul v\in \F _q^n:    M\ul v^T=\overline 0\}\).
</p>

<p>
i. Consider the matrix \(\begin {bmatrix}C\end {bmatrix}\) made up of <i>all</i> codevectors of \(C\) used as rows. The \(\mathrm {Nullspace}(\begin {bmatrix}C\end {bmatrix})\) is the set \(\{\ul v:         \begin {bmatrix}C\end
{bmatrix}\ul v^T=\overline 0\}\). Note that the column vector \(\begin {bmatrix}C\end {bmatrix}\ul v^T\) is \(\begin {bmatrix} \ul c_1 \ul v^T \\ \ul c_2 \ul v^T \\ \vdots \end {bmatrix} = \begin {bmatrix} \ul c_1 \cdot
\ul v \\ \ul c_2 \cdot \ul v\\ \vdots \end {bmatrix}\), which is zero if and only if the inner product \(\ul c \cdot \ul v\) is \(0\) for all rows \(\ul c\) of \(\begin {bmatrix} C \end {bmatrix}\), i.e., for all codevectors \(\ul c\) of
\(C\). By definition of the dual code, this happens exactly when \(\ul v\in C^\perp \), so \(\mathrm {Nullspace}(\begin {bmatrix}C\end {bmatrix}) = C^\perp \). By rank-nullity, \(\dim C^\perp = n - \mathrm {rank}(\begin
{bmatrix}C\end {bmatrix})\). Since the rows of \(\begin {bmatrix}C\end {bmatrix}\) span \(C\), one has \(\mathrm {rank}(\begin {bmatrix}C\end {bmatrix})=\dim C=k\) and so \(\dim C^\perp = n - k\).
</p>

<p>
ii. By definition \(H\) generates the code \(C^\perp \); so by i., \(H\) has \(n-k\) rows, \(H=\begin {bmatrix} \ul r_1 \\ \vdots \\ \ul r_{n-k} \end {bmatrix}\). Thus, \(\mathrm {rank}(H)=\dim C^\perp =n-k\), and so by rank-nullity,
\(\dim \mathrm {Nullspace}(H)=n-(n-k)=k\). Note that \(C\subseteq \mathrm {Nullspace}(H)\): indeed, if \(\ul c\in C\), then \(\ul r_i \ul c^T = \ul r_i \cdot \ul c = 0\) for all \(i\) because \(\ul r_i\in C^\perp \), which means
that \(H\ul c^T=\overline 0\). Since \(\dim C = \dim \mathrm {Nullspace}(H)\), it follows that \(C=\mathrm {Nullspace}(H)\), which is \(\{\ul v:       H\ul v^T=\overline 0\}\).
</p>

<p>
Using the law \((AB)^T=B^TA^T\) for product of matrices, \((\ul vH^T)^T=H\ul v^T\), and so \(H\ul v^T\) is zero iff \(\ul vH^T\) is. Thus, \(C=\{\ul v\in \F _q^n:   \ul v H^T=\ul 0\}\) as claimed. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... section Syndrome decoding ......
-->
<h4 id="autosec-19">Syndrome decoding</h4>
<a id="lecnotes_html-autopage-19"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (syndrome)</span>.
</p>

<p>
Let \(H\) be a check matrix for a linear code \(C\subseteq \F _q^n\). Let \(\ul y\in \F _q^n\). The vector
</p>

<p>
\[ S(\ul y)=\ul y H^T \]
</p>

<p>
is called the <b><i>syndrome</i></b> of \(\ul y\). The linear map
</p>

<p>
\[ S\colon \F _q^n \to \F _q^{n-k} \]
</p>

<p>
is the <b><i>syndrome map</i></b>.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">5.2</span></span>.   Let \(S\) be a syndrome map for a linear code \(C\subseteq \F _q^n\). If \(\ul v,\ul y\in \F
_q^n\),
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(S(\ul v)=S(\ul y)\) \(\iff \) \(\ul v,\ul y\) are in the same coset of \(C\);
</p>


</li>
<li>


<p>
• \(S(\ul v)=\ul 0\) \(\iff \) \(\ul v\in C\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-22"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> \(\ul yH^T=\ul vH^T\) \(\iff \) \((\ul y - \ul v)H^T=\ul 0\) \(\iff \) \(\ul y-\ul v\in C\). By definition of cosets, this means that \(\ul v\) is in the coset of \(\ul y\). In particular,
\(S(\ul v)=\ul 0\) means \(\ul v\in \ul 0+C=C\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection The use of syndromes in error detection ......
-->
<h5 id="autosec-23">The use of syndromes in error detection</h5>
<a id="lecnotes_html-autopage-23"></a>


<p>
If \(S(\ul y)\ne 0\), \(\ul y\) is not a codevector, so the syndrome map can <i>detect</i> errors in the received vector.
</p>
<!--
...... subsection The use of syndromes in error correction ......
-->
<h5 id="autosec-24">The use of syndromes in error correction</h5>
<a id="lecnotes_html-autopage-24"></a>


<p>
To correct errors, we need to construct a decoder for the linear code \(C\). If we know a check matrix \(H\) for \(C\), we can improve the standard array decoder for \(C\). We will write the same decoder differently; it will require much less memory
but more calculations.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Algorithm</span><span class="amsthmnumberdefinition"> <span class="textup">5.3</span></span><span class="amsthmnotedefinition"> (the syndrome decoder)</span>.
</p>

<p>
<i>Preparation</i>. Construct a <i>table of syndromes</i>, with \(q^{n-k}\) rows, of the form
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:          1px solid black; border-right:      1px solid black"></td>
<td class="tdc tvertbarr" style="border-right:        1px solid black"></td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:          1px solid black; border-right:      1px solid black">Coset leader \(\ul a_i\)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(S(\ul a_i)\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:          1px solid black; border-right:      1px solid black"></td>
<td class="tdc tvertbarr" style="border-right:        1px solid black"></td>
</tr>


</table>

</div>

<p>
The top row contains the codeword \(\ul 0\) and its syndrome \(S(\ul 0)=\ul 0\).
</p>

<p>
At each step, choose a vector \(\ul a_i\in \F _q^n\) of smallest weight such that \(S(\ul a_i)\) does not appear in the table; then \(\ul a_i\) is a coset leader of a new coset.
</p>

<p>
<i>Decoding</i>.
</p>
<ul style="list-style-type:none">


<li>
<p>
• Receive a vector \(\ul y\in \F _q^n\).
</p>


</li>
<li>


<p>
• Calculate \(S(\ul y)=\ul y H^T\).
</p>


</li>
<li>


<p>
• In the table, find \(\ul a_i\) with \(S(\ul a_i)=S(\ul y)\). Then \(\ul a_i\) is the coset leader of the coset of&nbsp;\(\ul y\).
</p>


</li>
<li>


<p>
• Return \(\Decode (\ul y)=\ul y-\ul a_i\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Remark</span>.
</p>

<p>
The syndrome decoder is based on a choice of one coset leader in every coset. This is the same as for the standard array decoder.
</p>

<p>
In fact, if the same coset leaders are chosen in both decoders, both decoders with yield <i>the same</i> function \(\Decode \colon \F _q^n \to C\). They differ only in the way this function is computed.
</p>

<p>
The number of arithmetic operations required to calculate the syndrome \(S(\ul y)=\ul y H^T\) can be of order \(n^2\), whereas the standard array decoder requires \(\sim n\) operations to look up a vector. On the other hand, the amount of
memory required by the syndrome decoder is proportional to \(q^{n-k}\) which is better than \(q^n\) for the standard array. The advantage is especially significant for codes with high code rate \(\dfrac kn\).
</p>

<p>
Nevertheless, for codes which have more algebraic structure (than just linear codes), decoding algorithms exist which require even less storage, but the computation complexity is higher compared to syndrome decoding. Some examples will appear
from the next chapter onwards.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-29"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (example of syndrome decoding)</span>.
</p>

<p>
Let \(C\) be the binary linear code with check matrix \(H=\left [\begin {array}{cc|cccc} 0&amp;0&amp;1&amp;0&amp;0&amp;0\\ 1&amp;0&amp; 0&amp;1&amp;0&amp;0 \\ 1&amp;1&amp;0&amp;0&amp;1&amp;0\\
0&amp;1&amp;0&amp;0&amp;0&amp;1 \end {array}\right ]\).
</p>
<ul style="list-style-type:none">


<li>
<p>
(a) Construct the table of syndromes for \(D\) using the matrix \(H\).
</p>
</li>
<li>


<p>
(b) Using the table of syndromes, decode the received vector \(\ul y=111111\).
</p>
</li>
</ul>

<p>
<b>Solution.</b>
</p>

<p>
(a) When calculating syndromes, it is useful to observe that the syndrome of a vector \(0\ldots 010\ldots 0\) (with \(1\) in position \(i\) and \(0\)s elsewhere) is equal to the \(i\)th column of \(H\), transposed.
</p>

<p>
The syndrome map is linear, so the syndrome of a sum of two vectors is the sum of their syndromes, etc.
</p>

<p>
For example, \(S(011000) = 0011+1000=1011\) (the sum of the second and the third columns of \(H\), transposed).
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">vector</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">syndrome</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">leader?</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(000000\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0000\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes                                 </td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(000001\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0001\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(000010\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0010\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(000100\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0100\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(001000\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(1000\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(010000\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0011\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:            1px solid black; border-right:       1px solid black">\(100000\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(0110\)</td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">yes</td>
</tr>
</table>

</div>

<p>
All vectors of weight \(1\) have different syndromes, so they all are coset leaders. We need more coset leaders, hence we start looking at vectors of weight \(2\), then weight \(3\):
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">         </td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">             </td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">          </td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(000011\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(0011\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">no, syndrome already in the table</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(000101\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(0101\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(001001\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1001\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(001010\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1010\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(001100\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1100\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(010100\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(0111\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(011000\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1011\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(101000\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1110\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(001101\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1101\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:       1px solid black">\(011100\)</td>
<td class="tdc tvertbarr" style="border-right:         1px solid black">\(1111\)</td>
<td class="tdl tvertbarr" style="border-right:         1px solid black">yes</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdl"></td>
</tr>
</table>

</div>

<p>
When we try a vector, say of weight \(2\), and find that is syndrome is already in the table, we ignore that vector and try another one.
</p>

<p>
We found \(16=2^{6-2}\) coset leaders so we stop.
</p>

<p>
(b) \(S(111111)=1010\) which is the syndrome of the coset leader \(001010\) in the table. Therefore, \(\Decode (111111)=111111-001010=110101\).
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch5ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-35"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch5ex ......
-->
<h3 id="autosec-36">Chapter&nbsp;<span class="sectionnumber">5&#x2003;</span>Exercises to Chapter 5 </h3>
<a id="lecnotes_html-autopage-36"></a>
<a id="lecnotes_html-autofile-14"></a>

<p>
Version 2022-10-18. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.1</span></span>.   Let \(C\) be a linear code of length \(n\) and weight 1. Show: \(C^\perp \) has no codevectors of
weight&nbsp;\(n.\)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch5exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.2</span></span>.   <a id="ex:dualdual"></a>Use Theorem&nbsp;<a href="ch5.html#thm:dual-prop">5.1</a> to
show that \((C^\perp )^\perp =C\) for every linear code \(C.\)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch5exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.3</span></span>.            <a id="ex:self-orthogonal"></a>A linear code \(C\) is called <b><i>self-orthogonal</i></b> if
\(C\subseteq C^\perp ,\) and <b><i>self-dual</i></b> if \(C=C^\perp .\) Clearly, a self-dual code is self-orthogonal.
</p>

<p>
(a) Show: \(C\) is self-orthogonal, if and only if \(\forall \ul v,\ul w\in C,\) \(\ul v\cdot \ul w=0.\)
</p>

<p>
(b) Let \(G\) be a generator matrix for \(C.\) Show: \(C\) is self-orthogonal \(\iff \) \(GG^T=\mathbf 0\) (zero matrix).
</p>

<p>
(c) [<i>2013 exam, B6b</i>] Show that <i>binary</i> self-orthogonal codes have even weight. <i>Hint</i>: if \(\ul c\in C,\) what is \(\ul c \cdot \ul c\)?
</p>

<p>
(d) [<i>2016 B5f</i>] Show that <i>ternary</i> self-orthogonal codes have weight divisible by \(3.\) (Same hint as in (c).)
</p>

<p>
(e) Which of the following codes are self-orthogonal: \(\Rep (n,\F _2),\) \(E_n\)?
</p>

</li>

</ul>

</div>

<p>
[<a href="ch5exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.4</span></span>.
</p>

<p>
(a) Show: a linear \([n,k,d]_q\)-code \(C\) is self-dual \(\iff \) \(C\) is self-orthogonal and \(k=n/2.\) Deduce that self-dual codes have even length.
</p>

<p>
(b) [<i>2013 B6c</i>] Show that a binary code generated by \(\begin {bmatrix}1&amp;0&amp;1&amp;0 \\ 0&amp;1&amp;0&amp;1\end {bmatrix}\) is self-dual.
</p>

<p>
(c) [<i>2015 B4g</i>] Prove that for every even \(n\) there exists a 5-ary self-dual code of length&nbsp;\(n.\) (<i>Hint</i>: look for a matrix.)
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
[<a href="ch5exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch5exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-7"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch5exans ......
-->
<h3 id="autosec-8">Chapter&nbsp;<span class="sectionnumber">5&#x2003;</span>Exercises to Chapter 5 — solutions</h3>
<a id="lecnotes_html-autopage-8"></a>
<a id="lecnotes_html-autofile-15"></a>

<p>
Version 2022-10-18. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.1</span></span>.           Let \(C\) be a linear code of length \(n\) and weight 1. Show: \(C^\perp \) has no codevectors of
weight&nbsp;\(n.\)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E5.1. </b> [<a href="ch5ex.html#.">These exercises without answers</a>]
</p>

<p>
Let \(\ul c= (0,\ldots ,0,\lambda ,0,\ldots ,0)\) be a vector of weight \(1\) in \(C,\) where the only non-zero symbol \(\lambda \) is in \(i\)th position. Then for any \(\ul x=(x_1,\ldots ,x_n)\in C^\perp \) one has \(\ul x \cdot
\ul c = 0\) which reads \(\lambda x_i =0.\) Because \(\lambda \ne 0,\) this is equivalent to \(x_i=0.\) Hence the weight of \(\ul x\) is at most \(n-1,\) because at least one symbol in \(\ul x\) is zero.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.2</span></span>.              Use Theorem&nbsp;<a href="ch5.html#thm:dual-prop">5.1</a> to show that \((C^\perp )^\perp
=C\) for every linear code \(C.\)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E5.2. </b> [<a href="ch5ex.html#.">These exercises without answers</a>]
</p>

<p>
Let \(C\subseteq \F _q^n\) be a linear code of dimension \(k.\) Take \(\ul c\in C\) and \(\ul v\in C^\perp .\) By definition of the dual code, \(\ul c \cdot \ul v=0.\) Since this is true for all \(\ul v\in C^\perp ,\) by definition of the
dual code again, \(\ul c\in (C^\perp )^\perp .\) We proved that \(C\subseteq (C^\perp )^\perp .\) Since \(\dim C = k = n-(n-k)\) which is \(\dim (C^\perp )^\perp \) by Theorem&nbsp;<a href="ch5.html#thm:dual-prop">5.1</a>,
one has \(C=(C^\perp )^\perp .\)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.3</span></span>.                    A linear code \(C\) is called <b><i>self-orthogonal</i></b> if \(C\subseteq C^\perp ,\) and
<b><i>self-dual</i></b> if \(C=C^\perp .\) Clearly, a self-dual code is self-orthogonal.
</p>

<p>
(a) Show: \(C\) is self-orthogonal, if and only if \(\forall \ul v,\ul w\in C,\) \(\ul v\cdot \ul w=0.\)
</p>

<p>
(b) Let \(G\) be a generator matrix for \(C.\) Show: \(C\) is self-orthogonal \(\iff \) \(GG^T=\mathbf 0\) (zero matrix).
</p>

<p>
(c) [<i>2013 exam, B6b</i>] Show that <i>binary</i> self-orthogonal codes have even weight. <i>Hint</i>: if \(\ul c\in C,\) what is \(\ul c \cdot \ul c\)?
</p>

<p>
(d) [<i>2016 B5f</i>] Show that <i>ternary</i> self-orthogonal codes have weight divisible by \(3.\) (Same hint as in (c).)
</p>

<p>
(e) Which of the following codes are self-orthogonal: \(\Rep (n,\F _2),\) \(E_n\)?
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E5.3. </b> [<a href="ch5ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) \(C\) is self-orthogonal iff \(C\subseteq C^\perp ,\) by definition. Recall that \(C^\perp \) is the set of all vectors \(\ul v\) such that \(\forall \ul w\in C,\) \(\ul v \cdot \ul w=0.\) Hence the condition \(C\subseteq C^\perp \) is
equivalent to \(\forall \ul v\in C,\) \(\forall \ul w\in C,\) \(\ul v \cdot \ul w=0,\) as claimed.
</p>

<p>
(b) Recall that \(C=\{\ul uG: \ul u\in \F _q^k\}.\) So by (a), \(C\) is self-orthogonal iff \(\forall \ul u,\ul v \in \F _q^k,\) \((\ul u G)\cdot (\ul v G)=\ul u G G^T \ul v^T = 0.\) The latter is true iff \(GG^T\) is the \(k\times k\)
zero matrix (by taking \(\ul u,\ul v\) to be vector units, \(\ul u G G^T \ul v^T\) can be equal to each entry of \(GG^T\)).
</p>

<p>
(c) Let \(C\subseteq \F _2^n\) be a self-orthogonal binary code. Then in particular, \(\ul c \cdot \ul c=0\) for all \(\ul c \in C,\) see (a). The inner product \(\ul c \cdot \ul c \) rewrites as \(c_1^2+c_2^2 +\dots + c_n^2=0.\) Note
that in the field \(\F _2\) one has \(x^2=x\) for all \(x.\) Hence \(c_1+c_2+\dots +c_n=0\) for all \(\ul c\in C.\) But this says that the vector \(\ul c\) is of even weight. We proved that if \(C\) is self-orthogonal, then all codevectors of \(C\)
are of even weight. In particular, \(w(C),\) the minimum positive weight of a codevector of \(C,\) is even.
</p>

<p>
(d) Let \(\ul c\in C\) be the vector of weight \(w(C).\) Since \(C\) is self-orthogonal, \(\ul c\cdot \ul c =0\) in \(\F _3.\) Note that \(\ul c\cdot \ul c = c_1^2+c_2^2+\dots +c_n^2\) is obtained by adding up the squares of all non-zero
symbols in \(\ul c.\) But the square of any non-zero symbol is 1: \(1^2=2^2=1\) in \(\F _3.\) Hence \(\ul c\cdot \ul c\) is equal to the sum of \(w(C)\) 1s in \(\F _3\); thus, \(w(C)\) is zero in \(\F _3,\) meaning that \(w(C)\) is a multiple
of 3.
</p>

<p>
(e) The repetition code \(\Rep (n,\F _2)\) consists of two vectors, \(\ul 0\) and \(111\dots 11,\) so the code is self-orthogonal iff the vector \(111\dots 11\) (all ones) is orthogonal to itself. Yet the inner product \(111\dots 11\cdot 111\dots
11\) is equal to \(n\) mod \(2.\) Hence \(\Rep (n,\F _2)\) is self-orthogonal, if and only if \(n\) is even.
</p>

<p>
Consider the vectors \(\ul u=1100\dots 00\) and \(\ul v = 0110\dots 00,\) of weight 2, in the even weight code \(E_n.\) Note that the inner product \(\ul u \cdot \ul v\) is \(1.\) Therefore, \(E_n\) is not self-orthogonal... The only gap in
this argument is that to construct such vectors \(\ul u\) and \(\ul v,\) we need \(n\ge 3.\) And if \(n=2,\) \(E_2=\{00,11\}=\Rep (2,\F _2)\) is self-orthogonal. If \(n\ge 3,\) then \(E_n\) is not self-orthogonal.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">5.4</span></span>.
</p>

<p>
(a) Show: a linear \([n,k,d]_q\)-code \(C\) is self-dual \(\iff \) \(C\) is self-orthogonal and \(k=n/2.\) Deduce that self-dual codes have even length.
</p>

<p>
(b) [<i>2013 B6c</i>] Show that a binary code generated by \(\begin {bmatrix}1&amp;0&amp;1&amp;0 \\ 0&amp;1&amp;0&amp;1\end {bmatrix}\) is self-dual.
</p>

<p>
(c) [<i>2015 B4g</i>] Prove that for every even \(n\) there exists a 5-ary self-dual code of length&nbsp;\(n.\) (<i>Hint</i>: look for a matrix.)
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<b>Answer to E5.4. </b> [<a href="ch5ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) Self-orthogonal is equivalent to \(C\subseteq C^\perp .\) Self-dual means \(C=C^\perp \); this is equivalent to \(C\subseteq C^\perp \) AND \(\dim C = \dim C^\perp .\) The equality of dimensions reads \(k=n-k,\) i.e., \(n=2k.\) Thus,
the length of a self-dual code is twice its dimension; in particular, the length is even.
</p>

<p>
(b) The code is self-orthogonal because \(G=\begin {bmatrix}1&amp;0&amp;1&amp;0 \\ 0&amp;1&amp;0&amp;1\end {bmatrix}\) satisfies \(GG^T=\begin {bmatrix} 0&amp;0\\ 0&amp;0\end {bmatrix},\) see&nbsp;(b). We have \(n=2k\) as
\(4=2\times 2\) so by&nbsp;(a) the code is self-dual.
</p>

<p>
(c) Consider the matrix \(G=\begin {bmatrix} &amp; I_k &amp; | &amp; 2I_k &amp; \end {bmatrix}\) over the field \(\F _5,\) where \(n=2k.\) Note that \(GG^T=I_k^2+4I_k^2=5I_k^2=0\) so the code \(C,\) generated by the matrix \(G,\) is
self-orthogonal. Moreover, \(C\) is self-dual as \(n=2k.\)
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch6.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-7"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch6 ......
-->
<h3 id="autosec-8">Chapter&nbsp;<span class="sectionnumber">6&#x2003;</span>The Shannon limit (optional material, not assessed)</h3>
<a id="lecnotes_html-autopage-8"></a>
<a id="lecnotes_html-autofile-16"></a>

<p>
Version 2022-11-02. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>   <a id="ch:Shannon"></a>
</p>

<p>
<b>Synopsis.</b> <i>This chapter is under development.</i>
</p>
<!--
...... subsection What is the main goal of Coding Theory? ......
-->
<h5 id="autosec-9">What is the main goal of Coding Theory?</h5>
<a id="lecnotes_html-autopage-9"></a>


<p>
Here is a way to measure efficiency of a code <i>for a given channel</i>.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-10"></a>
<span class="amsthmnamedefinition">Definition</span>.         Let codewords of a code \(C\) be transmitted via a given channel. The <b><i>probability of correct decoding</i></b> \(P_{\mathrm {corr}}(C)\) is the probability that a codeword
picked at random from \(C\) and sent via the channel is decoded correctly.
</p>

</li>

</ul>

</div>

<p>
It is not difficult to see that, unless the channel cannot transmit any information (e.g., \(\mathit {BSC}(0.5)\)), a code can be chosen so that this probability is arbitrarily close to \(1\). For example, one can use repetition codes \(\text
{Rep}(n,F)\) with large \(n\). However, the rate of \(\text {Rep}(n,F)\) is \(1/n\) which tends to \(0\) as \(n\to \infty \).
</p>

<p>
Shannon proved that it is possible to do much better than that. The following theorem is not examinable:
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">6.1</span></span><span class="amsthmnotedefinition"> (Shannon’s noisy-channel coding theorem)</span>.
</p>

<p>
Each channel has capacity \(\mathit {Cap}\), \(0\le \mathit {Cap}\le 1\), such that, for any \(R&lt;\mathit {Cap}\), there exist a sequence of codes \(C_n\) of rate \(\ge R\) so that \(P_{\mathrm {corr}}(C_n)\) tends to \(1\).
</p>

<p>
For each \(R&apos;&gt;\mathit {Cap}\), there exists a positive \(\epsilon \) such that \(P_{\mathrm {corr}}(C)&lt;1-epsilon\) for all codes \(C\) of rate \(\ge R\).
</p>

</li>

</ul>

</div>

<p>
However, his was an <i>existence proof</i> not giving any constructive way to find the codes. One can create codes \(C_n\) by picking codewords from \(F^n\) at random, but encoding and decoding for such codes are computationally unfeasible
because random codes lack structure.
</p>

<p>
So a specific goal of Coding Theory is to <b>construct</b> sequences of codes which approach <i>Shannon’s limit</i> — at least binary codes for \(\mathit {BSC}(p)\), the capacity of which was calculated by Shannon to be \(\mathcal C =
1-p\log _2p^{-1} - (1-p)\log _2(1-p)^{-1}\). Note that the capacity of \(\mathit {BSC}(0.5)\) is \(0\) (this channel outputs random junk irrespective of the input) but the capacity of \(\mathit {BSC}(p)\) is positive if \(p&lt;0.5\).
</p>

<p>
In fact, constructible codes which come close to Shannon’s limit were only developed at the end of last century, and became part of Ethernet, Wi-Fi etc within the last decade. It took about fifty years to build up mathematical apparatus to achieve
this.
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch7.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-13"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch7 ......
-->
<h3 id="autosec-14">Chapter&nbsp;<span class="sectionnumber">7&#x2003;</span>Hamming codes</h3>
<a id="lecnotes_html-autopage-14"></a>
<a id="lecnotes_html-autofile-17"></a>

<p>
Version 2022-11-02. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>Hamming codes are essentially the first non-trivial family of codes that we shall meet. We give a construction of a \(q\)-ary Hamming code and prove that it is perfect with minimum distance \(3\). We show that syndrome
decoding works for Hamming codes in an especially simple way.</i>
</p>

<p>
Before we can construct Hamming codes, we need to discuss check matrices further and prove a result (the Distance Theorem) which will allow us to find the minimum distance of a linear code from its check matrix.
</p>
<!--
...... section Finding a check matrix ......
-->
<h4 id="autosec-15">Finding a check matrix</h4>
<a id="lecnotes_html-autopage-15"></a>


<p>
The following result allows us to find a generator matrix of \(C^\perp \), assuming that \(C\) has a generator matrix in standard form.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-16"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">7.1</span></span>.          <a id="thm:checkmatrix"></a>
</p>

<p>
Assume that \(C\) has a \(k\times n\) generator matrix \(G=[\,I_k\,|\,A\,]\) in standard form. Then \(C^\perp \) has generator matrix
</p>

<p>
\[ H = [\,-A^T\, |\, I_{n-k}\, ].    \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-17"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> \(H\) has \(n-k\) rows which are linearly independent (due to \(I_{n-k}\) present). It is enough to show that each row \(\ul r\) of \(H\) is a codevector of&nbsp;\(C^\perp \): indeed, we have
\(n-k\) linearly independent vectors in \(C^\perp \), and \(n-k\) is the dimension of \(C^\perp \) by Theorem&nbsp;<a href="ch5.html#thm:dual-prop">5.1</a>, so a linearly independent set of \(n-k\) vectors must be a basis of \(C^\perp \).
</p>

<p>
Thus, we need to show that for each codevector \(\ul uG\) of&nbsp;\(C\), the inner product \(\ul uG\cdot \ul r=\ul uG\ul r^T\) is \(0\). Enough to show: \(G\ul r^T=\overline 0\), equivalently \(\ul rG^T =\ul 0\), and so we need to show
that \(HG^T\) is the zero matrix. Indeed,
</p>

<p>
\[ [\,-A^T\, |\, I_{n-k}\, ] \left [\begin {smallmatrix}&amp;I_k&amp; \\ &amp; -\!\!-\!\!-&amp; \\ &amp;A^T &amp;\end {smallmatrix}\right ] = -A^T I_k + I_{n-k}A^T = -A^T+A^T=0.\qedhere \]
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
How can one find a check matrix of \(C\) if \(C\) has no generator matrix in standard form? We address this question below.
</p>
<!--
...... section Linearly equivalent codes ......
-->
<h4 id="autosec-18">Linearly equivalent codes</h4>
<a id="lecnotes_html-autopage-18"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-19"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (linearly equivalent codes)</span>.   Two linear codes \(C,C&apos;\subseteq \F _q^n\) are <b><i>linearly equivalent</i></b>, if \(C&apos;\)
can be obtained from \(C\) by a sequence of linear transformations of the following types:
</p>
<ul style="list-style-type:none">


<li>
<p>
(C1) choose indices \(i\), \(j\); in every codeword, swap symbols \(x_i\) and \(x_j\);
</p>


</li>
<li>


<p>
(C2) choose index \(i\) and non-zero \(\lambda \in \F _q\); in every codeword, multiply \(x_i\) by \(\lambda \).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Exercise</span>.   Linearly equivalent codes have the same length, dimension and weight. They have the same weight enumerator. (<i>Reason</i>: (C1) and (C2) do not change the weight of any vector.)
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Fact</span><span class="amsthmnotedefinition"> (from linear algebra)</span>.
</p>

<p>
<i>Every</i> generator matrix can be brought into the standard form by using row operations (R1), (R2), (R3) considered above and column operations (C1).
</p>

<p>
<i>Reason:</i> any matrix can be brought to reduced row echelon form by (R1)–(R3); since generator matrices have linearly independent rows, the resulting reduced row echelon form will not have zero rows and will have a leading entry \(1\) in
each of the \(k\) rows; each one of the \(k\) columns which contain the leading entries is a column of the identity matrix of size \(k\); if necessary use (C1) to move all these columns to the left.
</p>

<p>
<i>Conclusion</i>: we can always find a generator matrix in standard form for a linearly equivalent code.
</p>

</li>

</ul>

</div>
<!--
...... section The Distance Theorem ......
-->
<h4 id="autosec-22">The Distance Theorem</h4>
<a id="lecnotes_html-autopage-22"></a>


<p>
We already know how to read the length and the dimension of a linear code \(C\) off a check matrix \(H\) of \(C\):
</p>
<ul style="list-style-type:none">

<li>
<p>
• the number of columns of \(H\) is the length of \(C\);
</p>


</li>
<li>


<p>
• the number of columns minus the number of rows of \(H\) is the dimension of \(C\).
</p>
</li>
</ul>

<p>
The following theorem tells us how to determine the minimum distance of \(C\) using \(H\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-23"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">7.2</span></span><span class="amsthmnotedefinition"> (Distance Theorem for Linear Codes)</span>.                           <a
id="thm:distance"></a>
</p>

<p>
Let \(C\subseteq \F _q^n\) be a linear code with check matrix \(H\). Then \(d(C ) = d\) if and only if every set of \(d - 1\) columns of \(H\) is linearly independent and some set of \(d\) columns of \(H\) is linearly dependent.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-24"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(e\) be the size of a smallest linearly dependent subset of the set \(\{\co h_1,\ldots ,\co h_n\}\) of columns of \(H\). The theorem claims that \(e=d(C)\). Note that \(e\) is the minimum
positive number of non-zero coefficients \(x_i\) in the linear combination
</p>

<span class="hidden"> \(\seteqnumber{0}{7.}{0}\)</span>

<!--



                                                                                                        x1 h1 + x2 h2 + . . . + xn hn = 0,

-->

<p>


\begin{equation*}
x_1 \co h_1+x_2\co h_2+\ldots +x_n \co h_n=\co 0,
\end{equation*}


</p>

<p>
i.e., the minimum weight of a non-zero \(\ul x =(x_1,\dots ,x_n)\) such that \(\ul x H^T = \ul 0\). By Theorem <a href="ch5.html#thm:dual-prop">5.1</a>, such vectors \(\ul x\) are exactly the codevectors of \(C\), so \(e=w(C)=d(C)\) as
claimed. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Example ......
-->
<h5 id="autosec-25">Example</h5>
<a id="lecnotes_html-autopage-25"></a>


<p>
Use the Distance Theorem to find the minimum distance of the ternary linear code with check matrix \(H=\left [\begin {matrix}1&amp;1&amp;1&amp;0 \\ 1&amp;2&amp;0&amp;1\end {matrix}\right ]\).
</p>

<p>
<b>Solution.</b> <i>Step 1.</i> \(H\) has no zero columns. Hence every set of \(1\) column is linearly independent (a one-element set is linearly dependent iff that element is zero). So \(d\ge 2\).
</p>

<p>
<i>Step 2.</i> Any two columns of \(H\) are linearly independent, because no two columns are proportional to each other. So \(d\ge 3\).
</p>

<p>
<i>Step 3.</i> There are three linearly dependent columns in \(H\): for example, columns 1, 3 and 4 form linear combination \(\begin {bmatrix}1\\1\end {bmatrix} - \begin {bmatrix}1\\0\end {bmatrix} - \begin {bmatrix}0\\1\end
{bmatrix}=\co 0\). Therefore, \(d=3\).
</p>

<p>
<b>Remark:</b> although, for small matrices, the algorithm for finding \(d\) can be used in practice, it requires a lot of computations for large \(n\). Essentially, one needs to check all possible sets of columns of \(H\) for linear dependence. The
required number of operations is exponential in&nbsp;\(n\).
</p>
<!--
...... subsection Hamming codes: the construction ......
-->
<h5 id="autosec-26">Hamming codes: the construction</h5>
<a id="lecnotes_html-autopage-26"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-27"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (line, representative vector, projective space)</span>.
</p>

<p>
A <em><b>line</b></em> is a \(1\)-dimensional subspace of the vector space \(\F _q^n\).
</p>

<p>
A <i><b>representative vector</b></i> of a line is a non-zero vector \(\ul u\) from that line. The line is then given by \(\{\lambda \ul u\mid \lambda \in \F _q\}\).
</p>

<p>
The <i><b>projective space</b></i> \(\PP _{n-1}(\F _q)\) is the set of all lines in \(\F _q^n\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Remark</span>.           The terminology comes from euclidean geometry — in the euclidean plane, the set of all vectors proportional to a given non-zero vector is a straight line through the origin. Moreover,
projective spaces over the field \(\mathbb R\) of real numbers are well-studied geometric objects.
</p>

<p>
For example, \(\PP _1(\mathbb R)\) — the set of all lines through the origin in the euclidean plane — can be thought of as the unit circle with antipodes identified. We are working over a finite field \(\F _q\) where these notions are less intuitive.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-29"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (Hamming codes)</span>.
</p>

<p>
Let \(r \ge 2\) be given. We let \(\mathrm {Ham}(r, q)\) denote an \(\F _q\)-linear code whose check matrix has columns which are representatives of the lines in \(P_{r-1}(\F _q )\), exactly one representative vector from each line.
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-30"></a>
<span class="amsthmnamedefinition">Remark</span>.          \(\Ham (r,q)\) is defined up to a linear equivalence. Indeed, we can:
</p>
<ul style="list-style-type:none">


<li>
<p>
• multiply a column by non-zero scalar to get another representative of the same line;
</p>


</li>
<li>


<p>
• put columns in any order.
</p>
</li>
</ul>

<p>
This means that \(\mathrm {Ham}(r,q)\) is not just one code but a class of linearly equivalent codes. We will therefore say “<i>a \(\mathrm {Ham}(r,q)\) code</i>” to mean any of the linearly equivalent codes.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-31"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (\(\mathrm {Ham}(3,2)\))</span>.
</p>

<p>
To construct a parity check matrix for \(\mathrm {Ham}(3,2)\), we need to take one non-zero column from each line in \(\F _2^3\). Note that for binary vectors, a line \(\{\lambda \ul u\mid \lambda \in \F _2\}\) consists only of two points,
\(\ul 0\) and \(\ul u\). Therefore, \(\PP _{r-1}(\F _2)\) is the same as the set of all non-zero binary column vectors of size \(r\).
</p>

<p>
We start filling in the parity check matrix by putting the identity columns at the end. We do this to obtain a parity check matrix in what is called standard form for check matrices, \(H=[-A^T \mid I_{n-k}]\). In total, we can find \(7\) non-zero
binary vectors of size \(3\):
</p>

<p>
\[ H=\left [\begin {array}{cccc|ccc} 1&amp; 1&amp; 1&amp;0&amp;1&amp;0&amp;0\\ 1&amp; 1&amp; 0&amp;1&amp;0&amp;1&amp;0\\ 1&amp; 0&amp; 1&amp;1&amp;0&amp;0&amp;1 \end {array}\right ] \]
</p>

<p>
From this parity check matrix, we can reconstruct the generator matrix \(G=[I_k \mid A]\):
</p>

<p>
\[ G=\left [\begin {array}{cccc|ccc} 1&amp; 0&amp; 0&amp;0&amp;1&amp;1&amp;1\\ 0&amp; 1&amp; 0&amp;0&amp;1&amp;1&amp;0\\ 0&amp; 0&amp; 1&amp;0&amp;1&amp;0&amp;1\\ 0&amp; 0&amp; 0&amp;1&amp;0&amp;1 &amp;1 \end
{array}\right ] \]
</p>

<p>
This is, up to linear equivalence, the generator matrix of the original \([7,4,3]_2\) code invented by Hamming.
</p>

</li>

</ul>

</div>
<!--
...... subsection A historical remark ......
-->
<h5 id="autosec-32">A historical remark</h5>
<a id="lecnotes_html-autopage-32"></a>


<p>
Despite their name, the \(q\)-ary Hamming codes for \(q&gt;2\) were not invented by Hamming. Richard Hamming told Claude Shannon (who he shared an office with at Bell Labs) about his binary \([7,4,3]\)-code, and Shannon mentioned it in
his paper of 1948. That paper was read by <b>Marcel J. E. Golay</b> (1902–1989), a Swiss-born American mathematician and electronics engineer, who then suggested the \(\Ham (r,q)\) construction in his paper published in 1949. Golay went
further and constructed two perfect codes which are not Hamming codes. He asked whether there are any more perfect codes.
</p>

<p>
We will see the Golay codes, and will learn about an answer to Golay’s question about perfect codes, later in the course.
</p>

<p>
We considered an example of a \(\Ham (3,2)\) code, which — by looking at its generator matrix — turns out to be a \([7,4,d]_2\) code. It is not difficult to see directly that \(d=3\). By explicitly computing the Hamming bound, one can show
that all \([7,4,3]_2\)-codes are perfect.
</p>

<p>
We will now generalise this and show that all Hamming codes are perfect.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-33"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">7.3</span></span><span class="amsthmnotedefinition"> (properties of Hamming codes)</span>.   \(\Ham (r,q)\) is a
perfect \([n,k,d]_q\) code where \(n=\dfrac {q^r-1}{q-1}, \quad k=n-r,\quad d=3 \).
</p>

</li>

</ul>

</div>

<p>
<b>Remark:</b> \(\dfrac {q^r-1}{q-1}=q^{r-1}+q^{r-2}+\ldots +q+1\); the right-hand side is obviously an integer.
</p>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-34"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> The length \(n\) of the code is equal to the number of columns in the check matrix, which is \(\#\mathbb P_{r-1}(\F _q)\), the number of lines in \(\F _q^r\).
</p>

<p>
Observe that two lines intersect only at one point, namely \(\co 0\). The set \(\F _q^r\setminus \{\co 0\}\) is therefore a disjoint union of lines. Each line \(\{\lambda \co u:\lambda \in F\}\) contains \(q-1\) non-zero points.
</p>

<p>
So the number of lines in \(\F _q^r\) can be found as \(\dfrac {\#(\F _q^r\setminus \{\co 0\})}{q-1} =\dfrac {q^r-1}{q-1}\).
</p>

<p>
Note that \(k=\dim \Ham (r,q)=n-r\) because by construction, the check matrix \(H\) has \(r\) rows.
</p>

<p>
To find the minimum distance, we use the Distance Theorem for linear codes. Note that any two columns of \(H\) are linearly independent because they are from different lines in \(\F _q^r\). (Two vectors can be linearly dependent only if they are
proportional to each other, i.e., belong to the same line.) Therefore, \(d\ge 3\).
</p>

<p>
On the other hand, \(H\) has columns \((a,0,0,\ldots ,0)^T\), \((0,b,0,\ldots ,0)^T\) and \((c,c,0,\ldots ,0)^T\), from three different lines (where \(a,b,c\in \F _q\setminus \{0\}\)). These three different columns are linearly
dependent:
</p>

<p>
\[ a^{-1}\begin {bmatrix}a\\0\\\vdots \\0\end {bmatrix} + b^{-1}\begin {bmatrix}0\\b\\\vdots \\0\end {bmatrix} -c^{-1}\begin {bmatrix}c\\c\\\vdots \\0\end {bmatrix} =\co 0.                          \]
</p>

<p>
So \(d=3\) by the Distance Theorem.
</p>

<p>
It remains to show that \(\Ham (r,q)\) is perfect. We compute the Hamming bound (in logarithmic form): \(t=[d-1)/2]=[2/2]=1\) hence we need to check that \(k=n-\log _q\left ( \binom n0 + \binom n1 (q-1)\right ) = n-\log _q\left
( 1 + n(q-1) \right )\), but by the above \(n(q-1)=q^r-1\) so the equation becomes \(k=n-\log _q(q^r)=n-r\) — already proved to be true. Thus, \(\Ham (r,q)\) is perfect. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Decoding a Hamming code ......
-->
<h5 id="autosec-35">Decoding a Hamming code</h5>
<a id="lecnotes_html-autopage-35"></a>


<p>
Next, we work out a decoding algorithm for a Hamming code. It is based on the general syndrome decoder, seen in the previous chapter. However, there is an extra simplification due to the fact that we know all the possible coset leaders.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-36"></a>
<span class="amsthmnamedefinition">Algorithm</span><span class="amsthmnumberdefinition"> <span class="textup">7.4</span></span><span class="amsthmnotedefinition"> (Decoding algorithm for a Hamming code)</span>.
</p>

<p>
Let a Hamming code be given by its check matrix \(H\). Suppose that a vector \(\ul y\) is received.
</p>
<ul style="list-style-type:none">


<li>
<p>
• Calculate \(S(\ul y)=\ul y H^T\).
</p>


</li>
<li>


<p>
•
</p>
<p>
Find a column of \(H\) such that \(S(\ul y)=\lambda \ \times \) that column. &#x2003;(\(i\)th column)
</p>
</li>
<li>


<p>
• Subtract \(\lambda \) from the \(i\)th position in \(\ul y\). The result is the codevector \(\Decode (\ul y)\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-37"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><b>Proof of validity of the algorithm</b>.</span> Recall from the previous chapter that by <i>Syndrome decoding</i>, \(\Decode (\ul y)=\ul y- \ul a\) where \(\ul a\) is a coset leader with \(S(\ul
a)=S(\ul y)\).
</p>

<p>
It was shown (see example sheets) that for a perfect linear code, the coset leaders are exactly the vectors of weight \(\le t\). For a Hamming code, \(t=1\) hence the coset leaders are the vector \(\ul 0\) and all the vectors of weight \(1\).
</p>

<p>
<i>Syndromes of coset leaders:</i> let \(\lambda \ul e_i=(0,\ldots ,0,\lambda ,0,\ldots ,0)\) be a coset leader, where \(\lambda \) is in position \(i\); the syndrome of \(\lambda \ul e_i\) is \(S(\lambda \ul e_i)=\lambda \ul e_i H^T
=\lambda \times \,[\,\)the \(i\)th column of \(H\,]^T\).
</p>

<p>
Thus, the syndrome \(S(\ul y)\) will be of the form \(\lambda \times \,[\,\)the \(i\)th column of \(H\,]^T\). In the special case \(S(\ul y)=\ul 0\), \(\ul y\) is a codevector so put \(\lambda =0\) and return \(\Decode (\ul y)=\ul y\).
Otherwise, \(S(\ul y)=S(\lambda \ul e_i)\) so \(\Decode (\ul y)=\ul y-\lambda \ul e_i\). It remains to note that the vector \(\ul y-\lambda \ul e_i\) is obtained from \(\ul y\) by subtracting \(\lambda \) from the \(i\)th symbol of
\(\ul y\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch7ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-39"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch7ex ......
-->
<h3 id="autosec-40">Chapter&nbsp;<span class="sectionnumber">7&#x2003;</span>Exercises to Chapter 7 </h3>
<a id="lecnotes_html-autopage-40"></a>
<a id="lecnotes_html-autofile-18"></a>

<p>
Version 2022-11-02. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Notation:</b> let \(\mathcal H\) denote a \(\Ham (3,2)\) code. It is a \([7,4,3]_2\) linear code.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.1</span></span>.               (a) Use a parity check matrix of \(\mathcal H\) to show: \(\mathcal H\ni 1111111\).<br />
(<i>In fact, every binary Hamming code \(\Ham (r,2)\) contains \(11\dots 1\), see the end of the next chapter or alternatively B5, 2015 exam</i>.)
</p>

<p>
(b) (<i>from Section B of the 2013 exam</i>) Find \(\max \{d(\ul x,\ul y):     \ul x,\ul y\in \mathcal H\}\), that is, the <em>maximum</em> distance between two codevectors in \(\mathcal H\). Justify your answer.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch7exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.2</span></span>.               In this exercise, we find the weight enumerator of \(\mathcal H\) in two ways.
</p>

<p>
(a) Construct a generator matrix for \(\mathcal H\). Hence write all the codevectors of \(\mathcal H\) and find the weight enumerator \(W_{\mathcal H}(x,y)\) of \(\mathcal H\).
</p>

<p>
(b) Show that all linear \([7,4,3]_2\)-codes which contain \(1111111\) have the same weight enumerator. Find this weight enumerator (using only the parameters \([7,4,3]_2\) and the fact that \(1111111\) is a codevector).
</p>

</li>

</ul>

</div>

<p>
[<a href="ch7exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.3</span></span>.              <a id="ex:hamselfdual"></a> (a) If \(\ul v=(x_1,x_2,\ldots ,x_n)\) is a binary vector, we
extend \(\ul v\) to obtain the vector \(\widehat {\ul v}\) \(=(x_1,\ldots ,\) \(x_n,x_{n+1})\) where \(x_{n+1}=x_1+\ldots +x_n\) in \(\F _2\). That is, a vector is extended by appending one bit so that the resulting vector has even weight.
</p>

<p>
If \(C\) is a binary linear code, we define the <b>extended code</b> \(\widehat C =\{\widehat {\ul c}:    \ul c\in C\}\).
</p>

<p>
By looking at \(W_{\mathcal H}\), argue that the weight enumerator of the <i>extended Hamming code</i> \(\widehat {\mathcal H}\) is \(W_{\widehat {\mathcal H}}(x,y)=y^8+14x^4y^4 + x^8\). Determine the length, dimension and weight
of \(\widehat {\mathcal H}\).
</p>

<p>
(b) Show: if \(\ul u\), \(\ul v\in \F _2^n\) are such that \(w(\ul u),w(\ul v),w(\ul u+\ul v)\) are divisible by \(4\), then \(\ul u\cdot \ul v=0\).
</p>

<p>
(c) Deduce from (a) and (b) that \(\widehat {\mathcal H}\) is a self-dual code.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch7exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch7exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch7exans ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">7&#x2003;</span>Exercises to Chapter 7 — solutions</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-19"></a>

<p>
Version 2022-11-02. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Notation:</b> let \(\mathcal H\) denote a \(\Ham (3,2)\) code. It is a \([7,4,3]_2\) linear code.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.1</span></span>.                  (a) Use a parity check matrix of \(\mathcal H\) to show: \(\mathcal H\ni 1111111\).<br />
(<i>In fact, every binary Hamming code \(\Ham (r,2)\) contains \(11\dots 1\), see the end of the next chapter or alternatively B5, 2015 exam</i>.)
</p>

<p>
(b) (<i>from Section B of the 2013 exam</i>) Find \(\max \{d(\ul x,\ul y):       \ul x,\ul y\in \mathcal H\}\), that is, the <em>maximum</em> distance between two codevectors in \(\mathcal H\). Justify your answer.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E7.1. </b> [<a href="ch7ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) \(1111111 \times H^T\) is the sum of columns of the check matrix \(H\) of \(\mathcal H\). To show that this is zero, note that all (non-zero) binary vectors are columns of \(H\). The sum of all columns can be calculated as follows: \(\left
[\begin {smallmatrix}1\\ 1\\ 1\end {smallmatrix}\right ]\), \(\left [\begin {smallmatrix}0\\ 0\\ 1\end {smallmatrix}\right ] + \left [\begin {smallmatrix}1\\ 1\\ 0\end {smallmatrix}\right ] = \left [\begin
{smallmatrix}1\\ 1\\ 1\end {smallmatrix}\right ]\), \(\left [\begin {smallmatrix}0\\ 1\\ 0\end {smallmatrix}\right ] + \left [\begin {smallmatrix}1\\ 0\\ 1\end {smallmatrix}\right ]= \left [\begin {smallmatrix}1\\
1\\ 1\end {smallmatrix}\right ]\), \(\left [\begin {smallmatrix}1\\ 0\\ 0\end {smallmatrix}\right ] + \left [\begin {smallmatrix}0\\ 1\\ 1\end {smallmatrix}\right ]= \left [\begin {smallmatrix}1\\ 1\\ 1\end
{smallmatrix}\right ]\) (i.e., we split all columns into pairs of complementary columns). The total is \(4\times \left [\begin {smallmatrix}1\\ 1\\ 1\end {smallmatrix}\right ]=\left [\begin {smallmatrix}0\\ 0\\ 0\end
{smallmatrix}\right ]\).
</p>

<p>
(b) \(d(\ul x,\ul y)=w(\ul x-\ul y)\). Since \(\mathcal H\) is linear, we are looking for the maximum weight of a codeword in \(\mathcal H\). Recall that \(\mathcal H\) is a code of length \(7\). Hence the codevector \(1111111\) of weight
\(7\), contained in \(\mathcal H\) by (a), has the maximum weight. Thus, the answer is 7, and the maximum distance is attained at, say, \(d(0000000,1111111)\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.2</span></span>.               In this exercise, we find the weight enumerator of \(\mathcal H\) in two ways.
</p>

<p>
(a) Construct a generator matrix for \(\mathcal H\). Hence write all the codevectors of \(\mathcal H\) and find the weight enumerator \(W_{\mathcal H}(x,y)\) of \(\mathcal H\).
</p>

<p>
(b) Show that all linear \([7,4,3]_2\)-codes which contain \(1111111\) have the same weight enumerator. Find this weight enumerator (using only the parameters \([7,4,3]_2\) and the fact that \(1111111\) is a codevector).
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E7.2. </b> [<a href="ch7ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) Let us use the following parity check matrix for \(\mathcal H\): \(H=\begin {bmatrix} 1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0 \\ 1&amp;1&amp;0&amp;1&amp;0&amp;1&amp;0 \\ 1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;1 \end
{bmatrix}\). (Any other check matrix for a \(\mathrm {Ham}(3,2)\) code is obtained from this one by permuting columns.) This allows us to construct the corresponding generator matrix for \(\mathcal H\):<br />
\(G = \begin {bmatrix} 1&amp;0&amp;0&amp;0&amp; 1&amp;1&amp;1 \\ 0&amp;1&amp;0&amp;0&amp; 1&amp;1&amp;0 \\ 0&amp;0&amp;1&amp;0&amp; 1&amp;0&amp;1 \\ 0&amp;0&amp;0&amp;1&amp; 0&amp;1&amp;1\end {bmatrix}\), hence the
code consists of \([0000]G=0000000\);
</p>
<span class="hidden"> \(\seteqnumber{0}{7.}{0}\)</span>


<!--



                                                                                 [0001]G = 0001011, [0010]G = 0010101, [0011]G = 0011110,
                                                                                 [0100]G = 0100110, [0101]G = 0101101, [0110]G = 0110011, [0111]G = 0111000,
                                                                                 [1000]G = 1000111, [1001]G = 1001100, [1010]G = 1010010, [1011]G = 1011001,
                                                                                 [1100]G = 1100001, [1101]G = 1101010, [1110]G = 1110100,



-->


<p>

\begin{align*}
&amp;[0001]G=0001011, \ [0010]G = 0010101, \ [0011]G=0011110, \\ &amp;[0100]G=0100110, \ [0101]G = 0101101, \ [0110]G = 0110011, \ [0111]G=0111000, \\ &amp;[1000]G=1000111, \ [1001]G = 1001100, \ [1010]G = 1010010,
\ [1011]G=1011001,\\ &amp;[1100]G=1100001, \ [1101]G = 1101010, \ [1110]G = 1110100,
\end{align*}
\([1111]G = 1111111\). One codevector has weight 0, seven have weight 3, seven have weight 4 and one has weight 7. Hence the weight enumerator is
</p>

<p>
\[ W_{\mathcal H}(x,y) = y^7+7x^3y^4+7x^4y^3+x^7.       \]
</p>

<p>
(b) Since \(1111111\in C\), for every codevector \(\ul c\in C\) its complementary vector \(1111111-\ul c\), of weight \(7-w(\ul c)\), also lies in \(C\). This means that \(A_i=A_{7-i}\) where \(A_i=\#\{\ul c\in C: w\ul c)=i\}\). We know
that \(A_1=A_2=0\) since \(w(C)=3\), so \(A_6=A_5=0\) and the weight enumerator \(W_{C}=\sum _{i=0}^7 A_i x^i y^{7-i}\) is \(y^7+A_3x^3y^4+A_4x^4y^3+x^7\). Finally, \(A_3=A_4\) and \(W_{C}(1,1)=1+A_3+A_4+1=\#C=2^4=16\), which gives
\(W_{C}=y^7+7x^3y^4+7x^4y^3+x^7\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">7.3</span></span>.                 <a id="ex:hamselfdual"></a> (a) If \(\ul v=(x_1,x_2,\ldots ,x_n)\) is a binary vector, we
extend \(\ul v\) to obtain the vector \(\widehat {\ul v}\) \(=(x_1,\ldots ,\) \(x_n,x_{n+1})\) where \(x_{n+1}=x_1+\ldots +x_n\) in \(\F _2\). That is, a vector is extended by appending one bit so that the resulting vector has even weight.
</p>

<p>
If \(C\) is a binary linear code, we define the <b>extended code</b> \(\widehat C =\{\widehat {\ul c}:       \ul c\in C\}\).
</p>

<p>
By looking at \(W_{\mathcal H}\), argue that the weight enumerator of the <i>extended Hamming code</i> \(\widehat {\mathcal H}\) is \(W_{\widehat {\mathcal H}}(x,y)=y^8+14x^4y^4 + x^8\). Determine the length, dimension and weight
of \(\widehat {\mathcal H}\).
</p>

<p>
(b) Show: if \(\ul u\), \(\ul v\in \F _2^n\) are such that \(w(\ul u),w(\ul v),w(\ul u+\ul v)\) are divisible by \(4\), then \(\ul u\cdot \ul v=0\).
</p>

<p>
(c) Deduce from (a) and (b) that \(\widehat {\mathcal H}\) is a self-dual code.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E7.3. </b> [<a href="ch7ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) By the extended code construction, \(\widehat {\mathcal H}\) has length \(8\) and cardinality equal to \(\# \mathcal H\), hence dimension \(4\).
</p>

<p>
If \(\ul x\in \mathcal H\) is a codevector of weight \(3\) or \(4\) (there are \(14\) such vectors in \(\mathcal H\)), \(\widehat {\ul x}\) will be of weight \(4\). Hence \(\widehat {\mathcal H}\) contains \(\ul 0\), fourteen vectors of weight
\(4\) and \(11111111\) of weight \(8\). So the weight enumerator is as claimed.
</p>

<p>
(b) Let \(K\) denote the set of indices \(i\) where \(x_i=y_i=1\). Then \(\ul x\cdot \ul y=\#K\text { mod }2\). On the other hand, the vector \(\ul x+\ul y\) has zero bits in positions \(i\) when \(i\in K\), hence the \(1\)s in the vector
\(\ul x+\ul y\) come from the \(w(\ul x)-\#K\) “ones” in the vector \(\ul x\) and \(w(\ul y)-\#K\) “ones” in the vector \(\ul y\). We obtain:
</p>

<p>
\[ w(\ul x+\ul y) = (w(\ul x)-\#K) + (w(\ul y)-\#K) \quad \implies \quad 2\#K = w(\ul x)+w(\ul y)-w(\ul x+\ul y).                  \]
</p>

<p>
But \(w(\ul x)+w(\ul y)-w(\ul x+\ul y)\) is divisible by \(4\), hence \(\#K\) is even and \(\ul x\cdot \ul y=0\).
</p>

<p>
(c) If \(\ul x\) and \(\ul y\) are codevectors of \(\widehat {\mathcal H}\), then \(\ul x+\ul y\) is also a codevector of \(\widehat {\mathcal H}\), and (a) tells us that the weights of all codevectors are divisible by \(4\). Hence by (b) \(\ul
x\cdot \ul y=0\). This means that \(\widehat {\mathcal H}\subseteq {\widehat {\mathcal H}}^\perp \). The dimension of both codes is \(4\), hence they are equal.
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch8.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch8 ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">8&#x2003;</span>The MacWilliams identity. The Average Weight Equation. Plotkin bound. Simplex codes</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-20"></a>

<p>
Version 2022-11-11. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>It turns out that the weights of codevectors of the dual code \(C^\perp \) are completely determined by weights of codevectors of \(C\). This remarkable fact was proved by <b>Florence Jessie MacWilliams</b> (1917–1990),
an English-born American mathematician who spent most of her career at Bell Labs and Harvard in the United States. We state the general case of the MacWilliams identity. We prove it for codes over \(\F _p\) where \(p\) is a prime (the proof is
not examinable). As an example of an application, we deduce a formula called the Average Weight Equation, as well as the Plotkin bound. (These two facts are also proved independently of the MacWilliams identity.) We can use the MacWilliams
identity to study Hamming codes by analysing their dual codes, called <b>simplex codes.</b></i>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-8"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">8.1</span></span><span class="amsthmnotedefinition"> (The MacWilliams identity)</span>.   <a
id="thm:macwilliams"></a> If \(C\) is a \(q\)-ary linear code, \(W_{C^\perp }(x,y)= \dfrac {1}{\#C} W_C(x+(q-1)y, \, x-y)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-9"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname"><b><i>Proof for prime \(q=p\). This proof is not examinable</i></b>.</span>
</p>

<p>
Since \(p\) is a prime, the field \(\F _p\) consists of elements \(0,1,\dots ,p-1\) (residues of integers modulo \(p\)). Being able to explicitly list the field elements — not possible for a general prime power \(q\) — simplifies the proof.
</p>

<p>
Let \(C\subseteq \F _p^n\) be linear. We fix the complex number \(\omega = e^{2\pi i/p}\), a primitive \(p\)th root of&nbsp;\(1\). We have \(\omega ^p=1\) and \(\omega ,\omega ^2,\ldots ,\omega ^{p-1}\ne 1\). We can write \(\omega
^a\) if \(a\in \F _p\) — this complex number is well-defined, even though \(a\) is only defined modulo \(p\).
</p>

<p>
Given \(\ul c\in C\), \(\ul v\in \F _p^n\), denote
</p>

<p>
\[ \Phi (\ul c,\ul v)=\omega ^{\ul c \cdot \ul v} x^{n-w(\ul v)} y^{w(\ul v)}.                    \]
</p>

<p>
We will compute \(\sum \limits _{\ul c\in C,\ \ul v\in \F _p^n} \Phi (\ul c,\ul v)\) in two different ways.
</p>

<p>
<span class="underline"><i>Way 1</i></span>. If \(\ul v\in C^\perp \), then \(\ul c \cdot \ul v=0\) for all \(\ul c\in C\), so \(\Phi (\ul c,\ul v)= x^{n-w(\ul v)} y^{w(\ul v)}\).
</p>

<p>
If, however, \(\ul v\notin C^\perp \), there is a codevector \(\ul d\in C\) such that \(\ul d \cdot \ul v=a\ne 0\) in \(\F _p\). Observe that \(\Phi (\ul d+\ul c,\ul v)=\omega ^{\ul d \cdot \ul v}\Phi (\ul c,\ul v)=\omega ^a
\Phi (\ul c,\ul v)\). We know that \(\ul d+C=C\), so
</p>

<p>
\[ \sum _{\ul c\in C}\Phi (\ul c,\ul v) = \sum _{\ul c\in C}\Phi (\ul d+\ul c,\ul v) = \omega ^a \sum _{\ul c\in C}\Phi (\ul c,\ul v) \quad \implies \quad (\omega ^a-1)\sum _{\ul c\in C}\Phi (\ul c,\ul v)=0.                                    \]
</p>

<p>
Simce \(\omega ^a\ne 1\), we have
</p>

<p>
\[ \sum _{\ul c\in C}\Phi (\ul c,\ul v)=0 \quad \text {for }\ul v\notin C^\perp .                      \]
</p>

<p>
We conclude that
</p>

<p>
\[ \sum \limits _{\ul c\in C,\ \ul v\in \F _p^n} \Phi (\ul c,\ul v) =\sum \limits _{\ul c\in C,\ \ul v\in C^\perp } \Phi (\ul c,\ul v) =\#C \sum _{\ul v\in C^\perp } x^{n-w(\ul v)} y^{w(\ul v)} =(\#C)W_{C^\perp
}(x,y).      \]
</p>

<p>
<span class="underline"><i>Way 2</i></span>. If \(v\) is a symbol, \(v\in \F _p\), we introduce the “weight of \(v\)”, \(w(v)\), as follows: \(w(v)=1\) if \(v\ne 0\) and \(w(v)=0\) if \(v=0\). Surely, for a vector \(\ul v\in \F _p^n\) we
have \(w(\ul v)=w(v_1)+\dots +w(v_n)\). We then rewrite
</p>
<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>



<!--



                                                                                                        Φ(c, v) = ω c1 v1 +···+cn vn x1−w(v1 ) y w(v1 ) . . . x1−w(vn ) y w(vn )
                                                                                                                 = ω c1 v1 x1−w(v1 ) y w(v1 ) . . . ω cn vn x1−w(vn ) y w(vn ) .



-->



<p>


\begin{align*}
\Phi (\ul c,\ul v) &amp; = \omega ^{c_1v_1+\dots +c_nv_n} x^{1-w(v_1)}y^{w(v_1)}\dots x^{1-w(v_n)}y^{w(v_n)} \\ &amp; = \omega ^{c_1v_1}x^{1-w(v_1)}y^{w(v_1)}\dots \omega ^{c_nv_n}x^{1-w(v_n)}y^{w(v_n)}.
\end{align*}
We now sum over \(\ul v\in \F _p^n\) first: each coordinate of \(\ul v\) runs over \(\F _p=\{0,1,\ldots ,p-1\}\). So, for a fixed \(\ul c\in C\),
</p>
<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>



<!--


                                                                                                                   p−1           p−1
                                                                                             X                     X             X
                                                                                                       Φ(c, v) =           ···           Φ(c, v)
                                                                                             v∈Fn
                                                                                                p                  v1 =0         vn =0

                                                                                                                   p−1                                        p−1
                                                                                                                   X                                          X
                                                                                                               =           ω c1 v1 x1−w(v1 ) y w(v1 ) · · ·           ω cn vn x1−w(vn ) y w(vn ) .                                                      (*)
                                                                                                                   v1 =0                                      vn =0




-->



<p>


\begin{align*}
\sum _{\ul v\in \F _p^n} \Phi (\ul c,\ul v) &amp; = \sum _{v_1=0}^{p-1} \dots \sum _{v_n=0}^{p-1} \Phi (\ul c,\ul v) \\ &amp; =\sum _{v_1=0}^{p-1} \omega ^{c_1v_1}x^{1-w(v_1)}y^{w(v_1)} \dots \sum
_{v_n=0}^{p-1}\omega ^{c_nv_n}x^{1-w(v_n)}y^{w(v_n)}.             \tag {*}
\end{align*}
Let us analyse the first factor in the product on the right-hand side of (*):
</p>

<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>

<!--


                                                                                                               p−1                                              p−1
                                                                                                               X                                                X
                                                                                                                       ω c1 v1 x1−w(v1 ) y w(v1 ) = x +                 ω c1 v1 y.
                                                                                                                                                                               
                                                                                                               v1 =0                                            v1 =1


-->

<p>


\begin{equation*}
\sum _{v_1=0}^{p-1}\omega ^{c_1v_1}x^{1-w(v_1)}y^{w(v_1)} = x+\bigl (\sum _{v_1=1}^{p-1} \omega ^{c_1v_1} \bigr )y.
\end{equation*}


</p>

<p>
If \(c_1=0\), the coefficient of \(y\) is clearly \(1+1+\dots +1=p-1\), whereas if \(c_1\ne 0\), the coefficient of \(y\) is the sum of a geometric progression
</p>

<p>
\[ \sum _{v_1=1}^{p-1} \omega ^{c_1v_1} = -1 + \sum _{v_1=0}^{p-1} \omega ^{c_1v_1} =-1+\frac {1-(\omega ^{c_1})^p}{1-\omega ^{c_1}} = -1+ \frac {0}{1-\omega ^{c_1}} = -1 \]
</p>

<p>
since \((\omega ^{c_1})^p=1\). Hence the first factor on the right-hand side of (*) is
</p>

<p>
\[ \left \{ \begin {array}{rl} x+(p-1)y, &amp; \text { if }c_1=0, \\ x-y, &amp; \text { if }c_1\ne 0 \end {array} \right .                                                    \]
</p>

<p>
The same applies to the second, ..., \(n\)th factor in (*), hence (*) has \(w(\ul c)\) factors equal to \(x-y\) and \(n-w(\ul c)\) factors equal to \(x+(p-1)y\). In other words, (*) evaluates as \((x+(p-1)y)^{n-w(\ul c)}(x-y)^{w(\ul c)}\).
Therefore,
</p>

<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>

<!--


                                                                                     XX                        X
                                                                                                  Φ(c, v) =          (x + (p − 1)y)n−w(c) (x − y)w(c) = WC (x + (p − 1)y, x − y).
                                                                                     c∈C   v∈Fn
                                                                                              p                c∈C


-->

<p>


\begin{equation*}
\sum _{\ul c\in C}\sum _{\ul v\in \F _p^n} \Phi (\ul c,\ul v) = \sum _{\ul c\in C} (x+(p-1)y)^{n-w(\ul c)}(x-y)^{w(\ul c)} =W_C(x+(p-1)y,\, x-y).
\end{equation*}


</p>

<p>
Comparing <i>Way 2</i> and <i>Way 1</i>, we conclude that \(W_C(x+(p-1)y,\, x-y)=(\#C)W_{C^\perp }(x,y)\). This is the MacWilliams identity for \(q=p\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-10"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (the weight enumerator of \(E_n\))</span>.
</p>

<p>
The binary MacWilliams identity allows us to immediately obtain a short formula for the weight enumerator of the even weight code \(E_n\). Indeed, \(E_n=\text {Rep}(n,2)^\perp \), and the binary repetition code has weight enumerator
\(W_{\text {Rep}(n,2)}(x,y)=x^n+y^n\) (see example sheets). Also, \(\#\text {Rep}(n,2)=2\). Hence
</p>

<p>
\[ W_{E_n}(x,y)=\frac {1}{\#\text {Rep}(n,2)}W_{\text {Rep}(n,2)}(x+y,x-y)=\frac 12((x+y)^n+(x-y)^n).                    \]
</p>

<p>
Using the binomial formula, we can expand this sum as \(x^n + \binom n2 x^{n-2}y^2 + \binom n4 x^{n-4}y^4+\ldots \) In particular, this proves that \(w(E_n)=d(E_n)=2\) as the lowest positive power of \(x\) in this polynomial is two.
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
The proof of the following result involves a surprising use of the MacWilliams identity. (An alternative approach is also given.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">8.2</span></span><span class="amsthmnotedefinition"> (The Average Weight Equation)</span>.                <a
id="thm:awe"></a> If \(C\) is a \(q\)-ary linear code, the average of the weights of all the codevectors of \(C\) is \((n-z)(1-q^{-1})\), where \(z\) is the number of zero columns in a generator matrix of \(C\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-12"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> If the \(i\)th column of a generator matrix of \(C\) is zero, the \(i\)th symbol of every codevector of \(C\) is zero. We can then shorten the code by deleting the \(i\)th coordinate — this does not
change the weight of any codevector because only zeros are deleted. We repeat this operation \(z\) times so that the generator matrix has no more zero columns and obtain a code of length \(n-z\) with the same average weight. Hence it is enough to
prove that a code \(C\) of length \(n\) generated by \(G\) without zero columns has average weight \(n(1-q^{-1})\).
</p>

<p>
Assume now that \(G\) has no zero columns. Since \(G\) is a check matrix for the dual code \(C^\perp \), by Distance Theorem&nbsp;<a href="ch7.html#thm:distance">7.2</a> \(w(C^\perp )&gt;1\). Note that the coefficient of \(t\) in the
polynomial \(W_{C^\perp }(1,t)\) is the number of weight \(1\) vectors in \(C^\perp \), hence zero. As with any polynomial in \(t\), this coefficient can be obtained&nbsp;as
</p>

<p>
\[ \bigl .\dfrac {d}{dt}W_{C^\perp }(1,t)\bigr |_{t=0}.         \]
</p>

<p>
By the MacWilliams identity, the equation \(0=\bigl .\dfrac {d}{dt}W_{C^\perp }(1,t)\bigr |_{t=0}\) rewrites as
</p>
<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>



<!--



                                                                                        d 1
                                                                                    0=        WC (1 + (q − 1)t, 1 − t) t=0
                                                                                        dt #C
                                                                                         1    ∂                         ∂
                                                                                                                                           
                                                                                      =         WC (x, y) × (q − 1) +      WC (x, y) × (−1)
                                                                                        #C ∂x                          ∂x                       x=1+(q−1)t, y=1−t, t=0
                                                                                         1    ∂                         ∂
                                                                                                                                           
                                                                                      =         WC (x, y) × (q − 1) +      WC (x, y) × (−1)
                                                                                        #C ∂x                          ∂x                       x=1, y=1
                                                                                         1 X             ∂      ∂  n−w(c) w(c)
                                                                                                                                
                                                                                      =          (q − 1)    −      x        y
                                                                                        #C               ∂x    ∂y                   x=1, y=1
                                                                                              c∈C

                                                                                         1 X                                          1 X
                                                                                      =      (q − 1)(n − w(c)) − w(c) = (q − 1)n − q      w(c).
                                                                                        #C                                           #C
                                                                                             c∈C                                                c∈C




-->



<p>


\begin{align*}
0&amp;=\bigl .\frac {d}{dt} \frac {1}{\#C} W_C(1+(q-1)t,1-t)\bigr |_{t=0} \\ &amp;= \frac {1}{\#C}\Bigl .\Bigl (\frac {\partial }{\partial x}W_C(x,y)\times (q-1) + \frac {\partial }{\partial x}W_C(x,y)\times (-1)
\Bigr ) \Bigr |_{x=1+(q-1)t,\ y=1-t,\ t=0} \\ &amp;= \frac {1}{\#C}\Bigl .\Bigl (\frac {\partial }{\partial x}W_C(x,y)\times (q-1) + \frac {\partial }{\partial x}W_C(x,y)\times (-1) \Bigr ) \Bigr |_{x=1,\ y=1} \\
&amp;= \frac {1}{\#C}\Bigl .\Bigl ( \sum _{\ul c\in C} \bigl ((q-1)\frac {\partial }{\partial x}- \frac {\partial }{\partial y}\bigr ) x^{n-w(\ul c)} y^{w(\ul c)} \Bigr ) \Bigr |_{x=1,\ y=1} \\ &amp;= \frac
{1}{\#C}\sum _{\ul c\in C} (q-1)(n-w(\ul c))-w(\ul c) = (q-1)n -q\frac {1}{\#C}\sum _{\ul c\in C}w(\ul c).
\end{align*}
It follows that the average weight, \(\frac {1}{\#C}\sum \limits _{\ul c\in C}w(\ul c)\), is equal to \((q-1)n/q\) as claimed. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-13"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">An alternative proof of Theorem <a href="ch8.html#thm:awe">8.2</a> without the MacWilliams identity.</span> In the same way as in the previous proof, we conclude that it is enough to prove that a code \(C\)
of length \(n\) generated by \(G\) without zero columns has average weight \(n(1-q^{-1})\).
</p>

<p>
Assume that \(C\) is generated by \(G\) without zero columns. Consider a matrix \([C]\) where the rows are <i>all</i> the codevectors of \(C\).
</p>

<p>
For a symbol \(a\in \F _q\), let \(\mathcal R_i(a)\) denote the set of rows of \([C]\) which have the symbol \(a\) in position \(i\). We claim that \(\#\mathcal R_i(0)=\#\mathcal R_i(a)\) for all \(i=1,\dots ,n\) and for all \(a\in \F
_q\). We prove this claim for \(i=1\), the proof for other \(i\) is similar.
</p>

<p>
Since column \(1\) of \(G\) is not a zero column, there is a row \(\ul r\) of \(G\) which has a non-zero symbol \(b\) in position \(1\). Let \(\ul v=(ab^{-1})\ul r\), and note that \(\ul r\in C\) (all rows of \(G\) are codevectors) and so \(\ul
v\in C\). Consider the map \(R_1(0)\to R_1(a)\) given by \(\ul c \mapsto \ul v + \ul c.\) This map indeed sends a vector which begins with \(0\) to a vector which begins with \(a\), and it is clear that this is a bijection (the inverse map
being \(\ul c \mapsto \ul c - \ul v\)). Hence \(\#\mathcal R_1(0)=\#\mathcal R_1(a),\) as claimed.
</p>

<p>
But this means that every symbol of \(\F _q\) occurs in column \(i\) of \([C]\) the same number of times. Since there are \(\#C\) symbols in the \(i\)th column of \([C]\), each of the \(q\) symbols occurs \(q^{-1}\#C\) times in the \(i\)th
column. Hence each symbol occurs \(nq^{-1}\#C\) times in the matrix \([C].\)
</p>

<p>
To prove the Average Weight Equation, we observe that \(\sum _{\ul c \in C} w(\ul c)\) is the total number of non-zero symbols in \([C]\). Each of the \(q-1\) non-zero symbols occurs \(nq^{-1}\#C\) times, so this sum must be
\((q-1)nq^{-1}\#C=n(1-q^{-1})\#C.\) We conclude that \(\frac {1}{\#C}\sum _{\ul c \in C} w(\ul c) =\frac {1}{\#C}n(1-q^{-1})\#C=n(1-q^{-1}).\) <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-14"></a>
<span class="amsthmnamedefinition">Example</span>.        The easiest case where we can explicitly verify the Average Weight Equation is \(C=\text {Rep}(n,q)\), the \(q\)-ary repetition code of length \(n\). The code consists of the zero vector
and \(q-1\) vectors of the form \(aa\dots a\) where \(a\in \F _q\setminus \{0\}\), of weight \(n\). The total number of codevectors is \(q\). The average weight of a codevector of \(\text {Rep}(n,q)\) is therefore
</p>

<p>
\[ \frac {1\times 0 + (q-1)\times n}{q} = n(1-q^{-1}), \]
</p>

<p>
which agrees with the Average Weight Equation because \(z=0\): the one-row generator matrix \(\begin {bmatrix}1&amp;1&amp;\dots &amp;1\end {bmatrix}\) of the code does not contain a zero column.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Exercise</span>.   Verify the Average Weight Equation by explicit calculation for the trivial code \(\F _q^n\).
</p>

</li>

</ul>

</div>
<!--
...... subsection Simplex codes ......
-->
<h5 id="autosec-16">Simplex codes</h5>
<a id="lecnotes_html-autopage-16"></a>


<p>
What is the weight enumerator of \(\mathrm {Ham}(r,q)\)? This question can be answered using the MacWilliams identity. In the particular case \(q=2\), the answer can be explored further to give the probability \(P_{\mathrm {undetect}}\) for
the binary Hamming code (we do not pursue this here).
</p>

<p>
Recall from the previous chapter that the Hamming codes are defined via an interesting check matrix whose columns form <i>a maximal set of columns where no two columns are proportional</i>. What is the code <i>generated</i> by this matrix?
We analyse these codes in the rest of this chapter.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-17"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (simplex code)</span>.   A <b><i>simplex code</i></b> \(\Sigma (r,q)\) is defined as \(\mathrm {Ham}(r,q)^\perp \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-18"></a>
<span class="amsthmnamedefinition">Remark</span>.           Recall that a <i>regular simplex</i> in an \(n\)-dimensional euclidean space \(\mathbb R^n\) is a convex polytope whose vertices are \(n+1\) points with the same distance between each
pair of points. Thus, a 2-dimensional regular simplex is an equilateral triangle, and a 3-dimensional regular simplex is a regular tetrahedron. The following result motivates our terminology.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-19"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">8.3</span></span><span class="amsthmnotedefinition"> (properties of a simplex code)</span>.   <a
id="thm:simplex"></a> The simplex code \(\Sigma (r,q)\) has length \(n=(q^r-1)/(q-1)\) and dimension \(r\). The Hamming distance between each pair of codewords is \(q^{r-1}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-20"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> The length and dimension of \(\Sigma (r,q)=\mathrm {Ham}(r,q)^\perp \) are dictated by the parameters of the Hamming code. It remains to calculate the distances.
</p>

<p>
Since \(\Sigma (r,q)\) is a linear code, it is enough to show that the weight of every non-zero \(\ul v\in \Sigma (r,q)\) is \(q^{r-1}\).
</p>

<p>
By linear algebra, there is a basis of \(\Sigma (r,q)\) which contains \(\ul v\), hence \(\ul v\) is the first row of some generator matrix \(H&apos;\) of \(\Sigma (r,q)\).
</p>

<p>
Since \(H&apos;\) is a check matrix for \(\Ham (r,q)\) and \(d(\Ham (r,q))=3\), by the Distance Theorem no two columns of \(H&apos;\) are proportional, hence the columns of \(H&apos;\) represent distinct lines in \(\F _q^r\). Therefore, the
weight of \(\ul v\) (the first row of \(H&apos;\)) is the number of lines where the <i>first</i> entry of a representative vector is not zero.
</p>

<p>
The total number of possible columns of size \(r\) with non-zero top entry is \((q-1)\) (choices for the top entry) \(\times q^{r-1}\) (choices for the other entries which are unrestricted). But \((q-1)\) non-zero columns form a line, hence the
number of required lines is \((q-1)q^{r-1}/(q-1)=q^{r-1}\). Hence \(w(\ul v)=q^{r-1}\) as claimed. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection The weight enumerator of a binary Hamming code ......
-->
<h5 id="autosec-21">The weight enumerator of a binary Hamming code</h5>
<a id="lecnotes_html-autopage-21"></a>


<p>
By Theorem <a href="ch8.html#thm:simplex">8.3</a>, the weight enumerator of the simplex code \(\Sigma (r,q)\) is
</p>

<p>
\[ W_{\Sigma (r,q)}(x,y) = x^n + (q^r-1)x^{n-q^{r-1}}y^{q^{r-1}} \]
</p>

<p>
where \(n=\dfrac {q^r-1}{q-1}\). This formula reflects the fact that there is one codevector of weight \(0\) and \(q^r-1\) codevectors of weight \(q^{r-1}\) in \(\Sigma (r,q)\).
</p>

<p>
The weight enumerator of \(\mathrm {Ham}(r,q)=\Sigma (r,q)^\perp \) can then be obtained using the MacWilliams identity. We do this for a binary Hamming code.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-22"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">8.4</span></span><span class="amsthmnotedefinition"> (the weight enumerator of \(\mathrm
{Ham}(r,2)\))</span>.   <a id="prop:WHam"></a>
</p>

<p>
\[ W_{\mathrm {Ham}(r,2)}(x,y) = \dfrac {1}{n+1}\left ( (x+y)^n + n(x+y)^{(n-1)/2}(x-y)^{(n+1)/2}\right ) \]
</p>

<p>
where \(n=2^r-1\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-23"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> The MacWilliams identity, which is Theorem <a href="ch8.html#thm:macwilliams">8.1</a>, in the case of binary codes gives \(W_{C^\perp }(x,y)=\frac {1}{\#C}W_C(x+y,x-y)\). We put
\(C=\Sigma (r,2)\) so that \(C^\perp =\Ham (r,2)\). Then \(q^r-1=2^r-1=n\) so that \(\#C=2^r=n+1\) and the weight of each non-zero codevector in \(\Sigma (r,2)\) is \(q^{r-1}=2^{r-1}=\frac {n+1}2\). We also have \(n-q^{r-1} =
n-\frac {n+1}{2}=\frac {n-1}{2}\).
</p>

<p>
Substituting these in the MacWilliams identity, we obtain the formula for \(W_{\Ham (r,2)}\) as stated. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Example ......
-->
<h5 id="autosec-24">Example</h5>
<a id="lecnotes_html-autopage-24"></a>


<p>
The original Hamming code \(\mathrm {Ham}(3,2)\) has weight enumerator
</p>

<p>
\[\frac 18\left ( (x+y)^7 + 7(x+y)^3(x-y)^4 \right ) = x^7+7 x^4 y^3+7 x^3 y^4+y^7.   \]
</p>
<!--
...... subsection Exercise ......
-->
<h5 id="autosec-25">Exercise</h5>
<a id="lecnotes_html-autopage-25"></a>


<p>
Prove the above formula by explicitly expanding the left-hand side.
</p>
<!--
...... subsection Exercise ......
-->
<h5 id="autosec-26">Exercise</h5>
<a id="lecnotes_html-autopage-26"></a>


<p>
Use Proposition&nbsp;<a href="ch8.html#prop:WHam">8.4</a> to show that every binary Hamming code contains the vector \(111\ldots 1\) (all bits equal to \(1\)).
</p>
<!--
...... subsection The Plotkin Bound ......
-->
<h5 id="autosec-27">The Plotkin Bound</h5>
<a id="lecnotes_html-autopage-27"></a>


<p>
The Plotkin bound was obtained by Morris Plotkin in 1960 for arbitrary (not necessarily linear) binary codes. It applies to codes with very large minimum distance: \(d&gt;n/2\) where \(n\) is the length of the code. A proof of the general case of
the bound by a direct counting argument can be found in the literature. We will only prove the statement for linear codes, which will serve as an example of the power of the MacWilliams identity and its corollary, the Average Weight Equation.
(<i>Historical note</i>: the MacWilliams identity was proved in 1961, i.e., after the Plotkin bound.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Proposition</span><span class="amsthmnumberdefinition"> <span class="textup">8.5</span></span><span class="amsthmnotedefinition"> (The Plotkin bound for binary linear codes)</span>.   If
\(C\subseteq \F _2^n\) is a linear code such that \(d=d(C)&gt;n/2\), then \(\#C \le \dfrac {d}{d-n/2}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-29"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Let \(M=\#C\). The code \(C\) contains the zero vector, \(\ul 0\), and \(M-1\) vectors of weight <i>at least</i> \(d\). Then the average weight of a codevector of \(C\) is <i>at least</i>
</p>

<p>
\[ \frac {1\times 0 + (M-1)\times d}{M} = \bigl (1-\frac {1}{M}\bigr )d.          \]
</p>

<p>
So from the Average Weight Equation (where \(z\) is the number of zero columns in a generator matrix of \(C\)) we obtain
</p>

<p>
\[ (n-z)\bigl (1-\frac 12\bigr ) \ge \bigl (1-\frac 1M\bigr )d \quad \implies \quad \frac n2\ge \bigl (1-\frac 1M\bigr )d \quad \iff \quad \frac {n}{2d} \ge 1-\frac 1M \]
</p>

<p>
so that \(1/M\ge 1-n/(2d)=(2d-n)/(2d)\) and \(M\le 2d/(2d-n)\), as claimed. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch8ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-31"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch8ex ......
-->
<h3 id="autosec-32">Chapter&nbsp;<span class="sectionnumber">8&#x2003;</span>Exercises to Chapter 8 </h3>
<a id="lecnotes_html-autopage-32"></a>
<a id="lecnotes_html-autofile-21"></a>

<p>
Version 2022-11-09. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.1</span></span>.   Deduce from the Plotkin bound that every binary linear code \(C\) of length \(n\) with
\(d(C)&gt;\dfrac 23 n\) is one-dimensional.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch8exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.2</span></span>.           Let \(\widehat {\mathcal H}\) be the extended Hamming \([8,4,4]_2\)-code \(\widehat {\Ham
}(3,2)\). Recall from Ex.<a href="ch7exans.html#ex:hamselfdual">7.3</a> that \(\widehat {\mathcal H}\) is a self-dual code with weight enumerator \(W_{\widehat {\mathcal H}}(x,y)=x^8+14x^4y^4 + y^8\).
</p>

<p>
Verify directly that \(W_{\widehat {\mathcal H}}(x,y) = (\# \widehat {\mathcal H})^{-1} W_{\widehat {\mathcal H}}(x+y,x-y)\).
</p>

<p>
(<i>Of course, this must be true by the MacWilliams identity, given that \(\widehat {\mathcal H}={\widehat {\mathcal H}}^\perp \).</i>)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch8exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.3</span></span><span class="amsthmnotedefinition"> (advanced — a construction of the simplex code \(\Sigma
(3,2)\) using the Fano plane)</span>.     A <b><i>finite projective plane</i></b> is a finite set \(\mathbb P\) (whose elements are called “projective points” or ppoints) together with a set of subsets of \(\mathbb P\) called “projective lines” or
plines such that: (1) every two ppoints belong to a unique pline; (2) every two plines intersect at one ppoint.
</p>

<p>
(a) Show that \(\mathbb P_2(\F _q)\), introduced in the course, becomes a projective plane where the ppoints of \(\mathbb P_2(\F _q)\) are the lines in \(\F _q^3\), and a pline in \(\mathbb P_2(\F _q)\) is a 2-dimensional subspace of \(\F
_q^3\). A ppoint lies on a pline exactly when there is \(\subseteq \) between the subspaces.
</p>

<p>
(b) List the ppoints and the plines of \(\mathbb P_2(\F _2)\). Try to draw a realistic diagram where ppoints are shown by vertices and plines by curved segments which pass through ppoints. If you are stuck, look up the <i>Fano plane</i>.
</p>

<p>
(c) Write down a binary matrix with rows labelled by plines and columns labelled by ppoints of \(\mathbb P_2(\F _2)\), and the entry \((\ell ,p)\) is 1 iff the ppoint \(p\) <b>does not</b> lie on the pline \(\ell \). Check that the rows of this
matrix are codevectors of \(\Sigma (3,2)\).
</p>

</li>

</ul>

</div>

<p>
[<a href="ch8exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch8exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch8exans ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">8&#x2003;</span>Exercises to Chapter 8 — solutions</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-22"></a>

<p>
Version 2022-11-09. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.1</span></span>.          Deduce from the Plotkin bound that every binary linear code \(C\) of length \(n\) with
\(d(C)&gt;\dfrac 23 n\) is one-dimensional.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E8.1. </b> [<a href="ch8ex.html#.">These exercises without answers</a>]
</p>

<p>
Assume that \(C\) is a linear \((n,M,d)_2\)-code with \(d&gt;\dfrac 23n\), then \(M\le \dfrac {d}{d-n/2} =\dfrac {1}{1-n/(2d)} &lt; \dfrac {1}{1-3/4}=4\) so that \(\dim C = \log _2M&lt;2\). Since \(\dim C\) is an integer, it follows
that \(\dim C=1\). (The case \(\dim C=0\), i.e., \(C=\{\ul 0\}\), is excluded because \(d\) is not defined for the zero code.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.2</span></span>.                        Let \(\widehat {\mathcal H}\) be the extended Hamming \([8,4,4]_2\)-code \(\widehat {\Ham
}(3,2)\). Recall from Ex.<a href="ch7exans.html#ex:hamselfdual">7.3</a> that \(\widehat {\mathcal H}\) is a self-dual code with weight enumerator \(W_{\widehat {\mathcal H}}(x,y)=x^8+14x^4y^4 + y^8\).
</p>

<p>
Verify directly that \(W_{\widehat {\mathcal H}}(x,y) = (\# \widehat {\mathcal H})^{-1} W_{\widehat {\mathcal H}}(x+y,x-y)\).
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<b>Answer to E8.2. </b> [<a href="ch8ex.html#.">These exercises without answers</a>]
</p>

<p>
Instead of expanding \(W_{\widehat {\mathcal H}}(x+y,x-y)\) by “brute force”, which is of course possible if less insightful, we will use an approach due to Andrew M.&nbsp;Gleason who supervised Jessie MacWilliams’ PhD thesis. Observe what
happens with the following polynomials under the substitution \((x,y) \mapsto (x+y,x-y)\):
</p>

<p>
\[ \begin {array}{l|l|l} \phantom {A=}f(x,y) &amp; f(x+y,x-y) &amp; \text {comment} \\[1ex] \hline A = x(x+y) &amp; 2x(x+y) &amp; (x+y)((x+y)+(x-y)) = (x+y)\times 2x \\ B=(x-y)y &amp; 2(x-y)y &amp; \text
{similar}\\ C=x^2 + y^2 &amp; 2(x^2+y^2) &amp; C=A-B \end {array} \]
</p>

<p>
We can see that \(A(x+y,x-y)=2A(x,y)\); the same identity holds for \(B\) and for \(C\). We now rewrite \(W_{\widehat {\mathcal H}}(x,y)\) in terms of the elementary quadratic polynomials \(A,B,C\):
</p>
<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>


<!--


                                                                                              8   8     4 4    2   2 4    6 2    4 4    2 6     4 4
                                                                                   b(x, y) = x + y + 14x y = (x + y ) − 4x y − 6x y − 4x y + 14x y
                                                                                  WH
                                                                                                               = (x2 + y 2 )4 − 4x2 y 2 (x4 − 2x2 y 2 + y 4 )
                                                                                                               = (x2 + y 2 )4 − 4x2 y 2 (x2 − y 2 )2
                                                                                                               = (x2 + y 2 )4 − 4x2 y 2 (x − y)2 (x + y)2



-->


<p>

\begin{align*}
W_{\widehat {\mathcal H}}(x,y) = x^8+y^8+14x^4y^4 &amp; = (x^2+y^2)^4 -4x^6y^2 -6x^4y^4 -4x^2y^6 + 14x^4y^4 \\ &amp; = (x^2+y^2)^4 -4 x^2y^2 (x^4 - 2x^2y^2+y^4) \\ &amp; = (x^2+y^2)^4 -4 x^2y^2 (x^2-y^2)^2 \\ &amp;
= (x^2+y^2)^4 -4 x^2y^2 (x-y)^2(x+y)^2
\end{align*}
which is equal to \(C^4 -4 A^2B^2\). Hence
</p>
<span class="hidden"> \(\seteqnumber{0}{8.}{0}\)</span>


<!--



                                                                                     b + y, x − y) = C(x + y, x − y)4 − 4A(x + y, x − y)2 B(x + y, x − y)2
                                                                                     H(x
                                                                                                                4                2              2
                                                                                                    = 2C(x, y)       − 4 2A(x, y)      2B(x, y)
                                                                                                    = 16H(x,
                                                                                                        b y),



-->


<p>

\begin{align*}
{\widehat {\mathcal H}}(x+y,x-y) &amp; = C(x+y,x-y)^4 -4A(x+y,x-y)^2B(x+y,x-y)^2 \\ &amp;= \bigl (2C(x,y)\bigr )^4 - 4\bigl (2A(x,y)\bigr )^2 \bigl (2B(x,y)\bigr )^2 \\ &amp; = 16{\widehat {\mathcal H}}(x,y),
\end{align*}
as required.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">8.3</span></span><span class="amsthmnotedefinition"> (advanced — a construction of the simplex code \(\Sigma
(3,2)\) using the Fano plane)</span>.     A <b><i>finite projective plane</i></b> is a finite set \(\mathbb P\) (whose elements are called “projective points” or ppoints) together with a set of subsets of \(\mathbb P\) called “projective lines” or
plines such that: (1) every two ppoints belong to a unique pline; (2) every two plines intersect at one ppoint.
</p>

<p>
(a) Show that \(\mathbb P_2(\F _q)\), introduced in the course, becomes a projective plane where the ppoints of \(\mathbb P_2(\F _q)\) are the lines in \(\F _q^3\), and a pline in \(\mathbb P_2(\F _q)\) is a 2-dimensional subspace of \(\F
_q^3\). A ppoint lies on a pline exactly when there is \(\subseteq \) between the subspaces.
</p>

<p>
(b) List the ppoints and the plines of \(\mathbb P_2(\F _2)\). Try to draw a realistic diagram where ppoints are shown by vertices and plines by curved segments which pass through ppoints. If you are stuck, look up the <i>Fano plane</i>.
</p>

<p>
(c) Write down a binary matrix with rows labelled by plines and columns labelled by ppoints of \(\mathbb P_2(\F _2)\), and the entry \((\ell ,p)\) is 1 iff the ppoint \(p\) <b>does not</b> lie on the pline \(\ell \). Check that the rows of this
matrix are codevectors of \(\Sigma (3,2)\).
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E8.3. </b> [<a href="ch8ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) A 1-dimensional subspace of \(\F _q^r\) is spanned by its representative vector \(0\ne \ul u\in \F _q^r\). Two 1-dimensional subspaces belong to one two-dimensional subspace, spanned by \(\ul u\) and \(\ul v\). Thus, two ppoints of
\(\mathbb P_{r-1}(\F _q)\) define a unique pline.
</p>

<p>
To show that two plines intersect at a unique ppoint, it is essential to put \(r=3\). It is an exercise in linear algebra to show that in a 3-dimensional space, the intersection of two distinct 2-dimensional subspaces is always a 1-dimensional space.
</p>

<p>
(b,c) Note that a ppoint is a 1-dimensional subspace of \(\F _2^3\). Hence it consists of two vectors: \(\ul 0 = \left [\begin {smallmatrix} 0\\0\\0\end {smallmatrix}\right ]\) and the representative vector \(\ul u\). On our diagram,
ppoints will be labelled by \(\ul u\) only. A pline is a 2-dimensional space, hence it consists of four vectors: \(\ul 0,\ul u,\ul v,\ul u+\ul v\). It follows that each pline contains three ppoints.
</p>

<p>
Here is a diagram where dots represent the seven ppoints and each segment or circle represents one of the seven plines. Next to it is a matrix where the columns are labelled by the ppoints listed in specific order. It turns out that the rows of the
matrix — which correspond to the seven plines on \(\mathbb P_2(\F _2)\) — are the non-zero codevectors of a \(\Sigma (3,2)\) code.
</p>
<div class="center">
<div class="minipage" style="vertical-align:bottom ; justify-content:flex-start ; width:236pt ; ">

<a id="lecnotes_html-autopage-6"></a>

<p>

<a href="FanoPlane.svg" target="_blank" ><img
    src="FanoPlane.svg"
    class="inlineimage"
    alt="(image)"
></a>
</p>


</div>

<span style="width:18pt; display:inline-block"><!----></span>
<div class="minipage" style="vertical-align:bottom ; justify-content:flex-start ; width:236pt ; ">

<a id="lecnotes_html-autopage-7"></a>

<span style="width:18pt; display:inline-block"><!----></span>

<p>
\(\newcommand {\tc }[3]{\left [\begin {smallmatrix}#1\\#2\\#3\end {smallmatrix}\right ]^{\vphantom {X}}_{\vphantom {X}}} \begin {array}{ccccccc} \hline \tc 001 &amp; \tc 011 &amp; \tc 100 &amp; \tc 101 &amp; \tc
110 &amp; \tc 010 &amp; \tc 111 \\ \hline \\ \color {red}\textbf 1&amp;\color {red}\textbf 1&amp;\color {red}\textbf 1&amp;\color {red}\textbf 0 &amp;\color {red}\textbf 1&amp;\color {red}\textbf 0&amp;\color
{red}\textbf 0 \\ \color {orange}\textbf 0&amp;\color {orange}\textbf 1&amp;\color {orange}\textbf 1&amp;\color {orange}\textbf 1 &amp;\color {orange}\textbf 0&amp;\color {orange}\textbf 1&amp;\color
{orange}\textbf 0 \\ \color {yellow}\textbf 0&amp;\color {yellow}\textbf 0&amp;\color {yellow}\textbf 1&amp;\color {yellow}\textbf 1&amp;\color {yellow}\textbf 1 &amp;\color {yellow}\textbf 0&amp;\color
{yellow}\textbf 1 \\ \color {green}\textbf 1&amp;\color {green}\textbf 0&amp;\color {green}\textbf 0&amp;\color {green}\textbf 1&amp;\color {green}\textbf 1&amp;\color {green}\textbf 1 &amp;\color {green}\textbf 0
\\ \color {cyan}\textbf 0&amp;\color {cyan}\textbf 1&amp;\color {cyan}\textbf 0&amp;\color {cyan}\textbf 0&amp;\color {cyan}\textbf 1&amp;\color {cyan}\textbf 1&amp;\color {cyan}\textbf 1 \\ \color {blue}\textbf
1&amp;\color {blue}\textbf 0&amp;\color {blue}\textbf 1&amp;\color {blue}\textbf 0&amp;\color {blue}\textbf 0 &amp;\color {blue}\textbf 1&amp;\color {blue}\textbf 1 \\ \color {violet}\textbf 1&amp;\color
{violet}\textbf 1&amp;\color {violet}\textbf 0&amp;\color {violet}\textbf 1&amp;\color {violet}\textbf 0&amp;\color {violet}\textbf 0 &amp;\color {violet}\textbf 1 \\ \hline \end {array}\)
</p>


</div>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch9.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-9"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch9 ......
-->
<h3 id="autosec-10">Chapter&nbsp;<span class="sectionnumber">9&#x2003;</span>Cyclic codes</h3>
<a id="lecnotes_html-autopage-10"></a>
<a id="lecnotes_html-autofile-23"></a>

<p>
Version 2022-11-16. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>Cyclic codes form a subclass of linear codes. Cyclic codes are easy to define, but to reveal their advantages, one needs to study them using polynomials. We identify \(\F _q^n\) with the space \(R_n\) of polynomials in \(\F
_q[x]\) of degree less than \(n\), so that a linear code of length \(n\) becomes a subspace of \(R_n\). We prove that cyclic codes are subspaces of very special form: a cyclic code \(C\) consists of all multiples, in \(R_n\), of its generator polynomial
\(g(x)\). We also define a check polynomial of \(C\). We can classify cyclic codes of length \(n\) by listing all monic divisors of the polynomial \(x^n-1\) in \(\F _q[x]\). Theory and applications of cyclic codes are underpinned by the Division
Theorem for polynomials and the long division algorithm, which we review here.</i>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (cyclic shift, cyclic code)</span>.     For a vector \(\ul a = (a_0,a_1,\ldots ,a_{n-1})\in \F _q^n\), we denote \(s(\ul a)=
(a_{n-1},a_0,\ldots ,a_{n-2})\) and call the vector \(s(\ul a)\) the <b><em>cyclic shift</em></b> of \(\ul a\).
</p>

<p>
A <b><i>cyclic code</i></b> in \(\F _q^n\) is a linear code \(C\) such that
</p>

<p>
\[ \ul a\in C \qquad \implies \qquad s(\ul a) \in C. \]
</p>

<p>
Equivalently, a cyclic code is a linear code \(C\) such that \(s(C)=C\).
</p>

</li>

</ul>

</div>

<p>
<b>Remark:</b> We can iterate the cyclic shift, so if a cyclic code \(C\) contains the vector \((a_0,a_1,\ldots ,a_{n-1})\), then \(C\) also contains \((a_{n-2},a_{n-1},a_0,\ldots ,a_{n-3})\), \(\dots \), \((a_1,\ldots ,a_{n-1},a_0)\).
</p>
<!--
...... subsection Vectors as polynomials ......
-->
<h5 id="autosec-12">Vectors as polynomials</h5>
<a id="lecnotes_html-autopage-12"></a>


<p>
To study cyclic codes, we will identify <b>vectors of length \(n\)</b> with <b>polynomials of degree \(&lt;n\)</b> with coefficients in the field \(\F _q\):
</p>

<p>
\[ \ul a=(a_0,a_1,\ldots ,a_{n-1}) \quad \mapsto \quad a(x) = a_0+a_1x+\ldots +a_{n-1}x^{n-1} \quad \in \F _q[x] \]
</p>

<p>
Here \(\F _q[x]\) is the <b>ring of polynomials</b> in one variable, \(x\), with coefficients in \(\F _q\).
</p>

<p>
<i>Notation</i>: if \(n\) is given and \(a(x)\) is a polynomial of degree less than \(n\), \(\ul a\) (same letter, underlined) will denote the vector which corresponds to \(a(x)\) in&nbsp;\(\F _q^n.\)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-13"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (\(E_3\))</span>.
</p>

<p>
Consider the binary even weight code
</p>

<p>
\[ E_3 = \{000, 110, 011, 101\} \subseteq \F _2^3.          \]
</p>

<p>
It is a linear code, and is closed under the cyclic shift: \(000\) is invariant under the cyclic shift, and \(110 \to 011 \to 101\). Hence \(E_3\) is a cyclic code. It consists of the following <b><i>code polynomials</i></b>:
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>


<tr>
<td colspan="2" class="tdc tvertbarr" style="border-right:            1px solid black">Codevector</td>
<td colspan="2" class="tdc tvertbarr" style="border-right:            1px solid black">Code polynomial</td>
<td class="tdl">Remark</td>
</tr>


<tr class="hline">
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(000\)</td>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(0\)</td>
<td class="tdl"></td>
</tr>


<tr>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(110\)</td>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(1+x\)</td>
<td class="tdl"></td>
</tr>


<tr>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(011\)</td>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(x+x^2\)</td>
<td class="tdl">\(= x(1+x)\)</td>
</tr>


<tr>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(101\)</td>
<td class="tdr"></td>
<td class="tdl tvertbarr" style="border-right:          1px solid black">\(1+x^2\)</td>
<td class="tdl">\(= (1+x)(1+x)\)</td>
</tr>
</table>

</div>

<p>
Note that <b>multiplication of polynomials</b> is an extremely important operation on \(\F _q[x]\) which is not “visible” in \(\F _q^n\). Our goal in this chapter will be to make sense of this operation in coding theory — in particular, we will
explain the mysterious fact that all the code polynomials of \(E_3\) are multiples of \(1+x\).
</p>

</li>

</ul>

</div>
<!--
...... subsection The Division Theorem for polynomials ......
-->
<h5 id="autosec-16">The Division Theorem for polynomials</h5>
<a id="lecnotes_html-autopage-16"></a>


<p>
In general we cannot divide \(f(x)\) by \(g(x)\) in \(\F _q[x]\) and expect to get a polynomial. However, just as the ring \(\mathbb Z\) of integers, the ring \(\F _q[x]\) has an extra operation called <b><i>division with remainder</i></b>,
as per the following
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-17"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">9.1</span></span><span class="amsthmnotedefinition"> (Division Theorem for polynomials)</span>.                    For all
\(f(x)\in \F _q[x]\), \(g(x)\in \F _q[x]\setminus \{0\}\), there exist unique \(Q(x),r(x)\in \F _q[x]\) such that
</p>

<p>
\[ f(x) = g(x)Q(x)+r(x)\qquad \text {and}\qquad \deg r(x)&lt;\deg g(x) \ (\text {possibly }r(x)=0).             \]
</p>

<p>
In this case the polynomial \(Q(x)\) is the <b><i>quotient</i></b>, and \(r(x)\) the <b><i>remainder</i></b>, of \(f(x)\) when divided by \(g(x)\).
</p>

</li>

</ul>

</div>

<p>
We will <b>not</b> prove the Division Theorem but we will note and use the practical algorithm for finding the quotient and the remainder, known as <b>long division of polynomials</b>. Example of long division: divide \(x^5+1\) by
\(x^2+x+1\) in \(\F _2[x]\), finding the quotient and the remainder.
</p>
<div class="center">

<p>

<a href="PolynomialLongDivision.svg" target="_blank" ><img
    src="PolynomialLongDivision.svg"
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>

<p>
Hence \(x^5+1=(x^2+x+1)Q(x)+r(x)\) in \(\F _2[x]\), with \(Q(x)=x^3+x^2+1\) and \(r(x)=x\).
</p>

<p>
This example shows long division of polynomials over \(\F _2\). Division by a fixed binary polynomial is widely implemented in electronic circuits at hardware level, by means of shift feedback registers. We will soon see why such implementations
are needed.
</p>
<!--
...... subsection The generator polynomial of a cyclic code ......
-->
<h5 id="autosec-19">The generator polynomial of a cyclic code</h5>
<a id="lecnotes_html-autopage-19"></a>


<p>
To every cyclic code in \(C\subseteq R_n\) we associate a polynomial as follows.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Definition</span>.        A <b><i>generator polynomial</i></b> of a cyclic code \(C\subseteq R_n\), \(C\ne \{\ul 0\}\}\) is a monic polynomial of least degree in \(C\). By convention, the generator
polynomial of the zero code, \(\{0\}\subseteq R_n\), is \(x^n-1\).
</p>

<p>
(<em>Monic</em> means: the coefficient of the highest power of \(x\) in \(g\) is \(1\).)
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Lemma</span><span class="amsthmnumberdefinition"> <span class="textup">9.2</span></span>.   <a id="lem:generator_unique"></a> Every cyclic code \(C\) has a unique generator polynomial
\(g(x)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-22"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> <i>Existence</i>: If \(C=\{0\}\), by definition \(x^n-1\) is the unique generator polynomial of \(\{0\}\). So we assume \(C\ne \{0\}\). Take \(g(x)\in C\) to be a non-zero polynomial of lowest
degree in \(C\). Make \(g(x)\) monic by dividing it by its leading coefficient. This does not change the degree, so we now have a monic polynomial of lowest degree in \(C\). Existence is proved.
</p>

<p>
<i>Uniqueness</i>: Let now \(g_1(x)\in C\) be another generator polynomial, then by definition \(g_1(x)\) is monic and has the same degree as \(g(x)\). So \(f(x)=g_1(x)-g(x)\) has degree less than \(\deg g(x)\) (because the leading term
\(x^{\deg g}\) cancels due to subtraction). Note that \(f(x)\in C\) because \(C\) is linear. If \(f(x)\ne 0\), divide \(f(x)\) by its leading coefficient and obtain a monic polynomial, again in \(C\), of degree less than \(\deg g\). This contradicts
the choice of \(g(x)\). Hence \(f(x)\) must be \(0\), and \(g_1(x)=g(x)\). Uniqueness is proved. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-23"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">9.3</span></span>.   <a id="thm:generator"></a> Let \(C\subseteq R_n\) be a cyclic code with generator polynomial
\(g(x)\). Write \(\deg g=n-k\). Then
</p>
<ul style="list-style-type:none">


<li>
<p>
1. \(C=\{u(x)g(x):   u(x)\in R_k\}\), i.e., the code polynomials of \(C\) are multiples of \(g(x)\) of degree less than \(n\).
</p>


</li>
<li>


<p>
2. \(g(x)\) is a monic factor of the polynomial \(x^n-1\) in \(\F _q[x]\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-24"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Both claims are trivially true when \(C=\{\ul 0\}\) and \(g(x)=x^n-1\), so we assume \(C\ne \{\ul 0\}\).
</p>

<p>
1. Observe that, writing elements of \(C\) as vectors, we have
</p>

<p>
\[ \ul g = (g_0,g_1,\dots ,g_{n-k},\underbrace {0,0,\dots ,0}_{k-1 \text { zeros}}) \]
</p>

<p>
and, as long as \(i\le k-1\),
</p>

<p>
\[ \ul {x^i g} = (\underbrace {0,\dots ,0}_{i \text { zeros}},g_0,g_1,\dots ,g_{n-k},\underbrace {0,\dots ,0}_{k-1-i \text { zeros}}).                   \]
</p>

<p>
That is, \(\ul {x^i g}\) is obtained from \(\ul g\) by applying the cyclic shift \(i\) times. Since \(C\) is cyclic, this means that \(xg(x),\dots ,x^{k-1}g(x)\in C.\)
</p>

<p>
Now, every polynomial \(u(x)\in R_k\) — that is, a polynomial of degree less than \(k\) — is written as \(u_0+u_1x+\dots + u_{k-1}x^{k-1}\) for some \(u_0,\dots ,u_{k-1}\in \F _q.\) Hence \(u(x)g(x)\) is a linear combination of the
polynomials \(g(x)\), \(xg(x),\dots ,x^{k-1}g(x)\) which are in \(C\), and, since \(C\) is linear, \(u(x)g(x)\in C\). We proved that \(C\supseteq \{u(x)g(x):       u(x)\in R_k\}\).
</p>

<p>
Let us show that \(C\supseteq \{u(x)g(x):      u(x)\in R_k\}\). Take \(f(x)\in C\) and apply the Division Theorem for polynomials to write \(r(x) = f(x)-g(x)Q(x)\) where \(\deg r(x)&lt;\deg g(x)\). Observe that we will get \(\deg
Q=\deg f - \deg g &lt;n-(n-k)=k\) and so, by what has already been proved, \(g(x)Q(x)\in C\). Then by linearity \(r(x)\in C\). We have seen already that there cannot be a non-zero polynomial in \(C\) of degree strictly less than \(\deg g\),
so \(r(x)=0\) and \(f(x)=g(x)Q(x)\) is a multiple of \(g(x)\), as claimed. Part 1 of the Theorem is proved.
</p>

<p>
2. Continuing from the above, observe that
</p>

<p>
\[ s(\ul {x^{k-1}g}) = (g_{n-k},\underbrace {0,\dots ,0}_{k-1 \text { zeros}},g_0,g_1,\dots ,g_{n-k-1}) \]
</p>

<p>
where \(s\) is the cyclic shift. Hence the vector \(s(\ul {x^{k-1}g})\) corresponds to the polynomial
</p>

<p>
\[ g_{n-k}+x^k(g_0+g_1x+\dots + g_{n-k-1}x^{n-k-1}) = g_{n-k}+x^k g(x) - g_{n-k} x^n = x^k g(x) - (x^n-1), \]
</p>

<p>
as \(g_{n-k}=1\) given that \(g(x)\) is monic. Since \(C\) is cyclic, \(s(\ul {x^{k-1}g})\in C\) and so \(x^k g(x) - (x^n-1)\in C\). Then by Part 1, \(x^k g(x) - (x^n-1)=u(x)g(x)\) for some polynomial \(u(x)\), and so
\(x^n-1=(x^k-u(x))g(x)\) which shows that \(g(x)\) is indeed a factor of \(x^n-1\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnotedefinition"> (\(E_3\) continued)</span>.
</p>

<p>
Recall that the code \(E_3\), viewed as a subspace of \(R_3\), consists of polynomials \(0\), \(1+x\), \(x+x^2=x(1+x)\) and \(1+x^2=(1+x)^2\), of degree \(&lt;3\). The monic code polynomial of lowest degree is \(1+x\) — this is the generator
polynomial of \(E_3\). Observe that all the code polynomials are multiples of \(1+x\).
</p>

</li>

</ul>

</div>
<!--
...... subsection Error detection by a cyclic code ......
-->
<h5 id="autosec-26">Error detection by a cyclic code</h5>
<a id="lecnotes_html-autopage-26"></a>


<p>
Theorem <a href="ch9.html#thm:generator">9.3</a> means that if \(C\) is a cyclic code, there is no need to store a check matrix for <i>error detection</i>. To determine whether the received vector \(\ul y\) is a codevector, divide the
polynomial \(y(x)\) by the generator polynomial \(g(x)\); the remainder is \(0\), if and only if \(\ul y\in C\).
</p>

<p>
This is how error detection is implemented in practice for binary codes (e.g., in Ethernet networks). Long division by \(g(x)\) is implemented by circuitry.
</p>

<p>
Nevertheless, for theoretical purposes we would like to have generator and check matrices for a cyclic code with a given generator polynomial.
</p>
<!--
...... subsection The check polynomial ......
-->
<h5 id="autosec-27">The check polynomial</h5>
<a id="lecnotes_html-autopage-27"></a>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-28"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (check polynomial)</span>.         Let \(g(x)\) be the generator polynomial of a cyclic code \(C\). The polynomial \(h(x)\) such that
\(g(x)h(x)=x^n-1\) is called the <b><i>check polynomial</i></b> of \(C\). If \(\deg g(x)=n-k\), then \(\deg h(x)=k\), and \(h\) is monic.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-29"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">9.4</span></span><span class="amsthmnotedefinition"> (a generator matrix and a check matrix for a cyclic
code)</span>.   <a id="thm:gen-check"></a> Let \(C\subseteq \F _q^n\) be a cyclic code with generator polynomial \(g(x)=g_0+g_1x +\ldots +g_{n-k} x^{n-k}\) and check polynomial \(h(x)=h_0+h_1x+\ldots +h_kx^k\).
</p>

<p>
• the vector \(\ul g=[g_0 \ g_1 \ \ldots \ g_{n-k} \ 0 \ \ldots \ 0]\in \F _q^n\) which corresponds to \(g(x)\), and its next \(k-1\) cyclic shifts, form a generator matrix for \(C\):
</p>

<p>
\[ G=\left [\begin {matrix} g_0 &amp; g_1 &amp; \ldots &amp; \ldots &amp; g_{n-k} &amp; 0 &amp; \ldots &amp; 0 \\ 0 &amp; g_0 &amp; g_1 &amp; \ldots &amp; \ldots &amp; g_{n-k} &amp; \ddots &amp; 0 \\ \vdots &amp;
\ddots &amp; \ddots &amp; &amp; &amp; &amp; &amp; \ddots &amp; \\ 0 &amp; \ldots &amp; 0 &amp; g_0 &amp; \ldots &amp; \ldots &amp; &amp; g_{n-k} \end {matrix}\right ] \qquad (k\text { rows}); \]
</p>

<p>
• the vector corresponding to the polynomial
</p>

<p>
\[ \overleftarrow h(x) = h_k + h_{k-1}x + \ldots + h_0 x^k, \]
</p>

<p>
obtained from \(h(x)\) by reversing the order of the coefficients, i.e., the vector \(\ul {\overleftarrow h} = \) \([ h_k \ h_{k-1} \ \ldots \ h_0 \ 0 \ \ldots \ 0 ]\), and its next \(n-k-1\) shifts form a check matrix for&nbsp;\(C\):
</p>

<p>
\[ H=\left [\begin {matrix} 1 &amp; h_{k-1} &amp; \ldots &amp; \ldots &amp; h_1 &amp; h_0 &amp; 0 &amp; \ldots &amp; 0 \\ \vdots &amp; \ddots &amp; \ddots &amp; &amp; &amp; &amp; &amp; \ddots &amp; &amp; \\ 0 &amp;
\ddots &amp; 1 &amp; h_{k-1} &amp; \ldots &amp; \ldots &amp; h_1 &amp; h_0 &amp; 0 \\ 0 &amp; \ldots &amp; 0 &amp; 1 &amp; \ldots &amp; \ldots &amp; &amp; h_1 &amp; h_0 \end {matrix}\right ]\qquad (n-k\text {
rows}).   \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-30"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> Observe that the rows of \(G\) are linearly independent and the rows of \(H\) are linearly independent. This is obvious for \(H\) because \(H\) is a matrix in a row echelon form, with no zero rows.
This is clear for \(G\) as well, because it is also in row echelon form up to scaling its rows by a non-zero scalar \(g_0\): note that \(g_0h_0 = g(0)h(0)=0^n-1\ne 0\).
</p>

<p>
Now, by definition, \(C=\{u(x)g(x):    \deg (u(x)g(x))&lt;n\}=\{u(x)g(x):\deg u(x)&lt;n-r=k\}\), so \(C\) is spaned by \(g(x),xg(x),\ldots ,x^{k-1}g(x)\). Written as vectors, these are exactly the cyclic shifts of \(\ul g\) listed above.
We proved that the rows of \(G\) span \(C\), and, since they are linearly independent, they form a basis for \(C\) and so \(G\) is a generator matrix for \(C\).
</p>

<p>
Since \(H\) has \(n-k\) linearly independent rows and \(\dim C^\perp =n-k\), to show that \(H\) is a check matrix it is enough to show that \(HG^T=0\), in the same way as in the proof of Theorem&nbsp;<a
href="ch7.html#thm:checkmatrix">7.1</a>. We rely on the following observation linking the inner product of vectors and their representation as polynomials: if \(\ul a,\ul b\in \F _q^n\), then
</p>

<p>
\[ \ul a \cdot \ul {\overleftarrow b} = \text {coefficient of }x^{n-1} \text { in }a(x)b(x).                 \]
</p>

<p>
Indeed, with \(\ul a=(a_0,a_1,\dots ,a_{n-1})\) and \(\ul {\overleftarrow b}=(b_{n-1},\dots ,b_1,b_0)\) one has \(\ul a \cdot \ul {\overleftarrow b}=a_0b_{n-1} + \dots + a_{n-1}b_0\) which is exactly the coefficient of
\(x^{n-1}\) in the product of the polynomials \(a(x)\) and \(b(x)\).
</p>

<p>
It remains to observe that the rows of \(G\) correspond to polynomials \(x^i g(x)\) for \(i=0,1,\dots ,k-1\), while the rows of \(H\) are obtained by writing backwards the vectors which correspond to polynomials \(x^j h(x)\) for \(j=0,1,\dots
,n-k-1\). The \((j,i)\)-entry of \(HG^T\) is the inner product of the \(i\)th row of \(G\) and the \(j\)th row of \(H\), hence is the coefficient of \(x^{n-1}\) in \(x^i g(x)x^j h(x)=x^{n+i+j}-x^{i+j}\). But since \(n+i+j&gt;n-1\) and
\(i+j&lt;n-1\), this coefficient is zero, proving \(HG^T=0\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-31"></a>
<span class="amsthmnamedefinition">Remark</span>.   This is not the only generator matrix (resp., check matrix) for \(C\). As we know, a generator matrix is not unique. Moreover, these matrices are not usually in standard form. Note that a
generator polynomial of \(C\) is unique.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-32"></a>
<span class="amsthmnamedefinition">Corollary</span><span class="amsthmnumberdefinition"> <span class="textup">9.5</span></span>.      The Theorem implies that \(C^\perp \) is also a cyclic code with generator polynomial
\(h_0^{-1}\overleftarrow h(x)\). Scaling by \(h_0^{-1}\) is necessary because the generator polynomial must by definition be monic.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-33"></a>
<span class="amsthmnamedefinition">Example</span>.             Use Theorem <a href="ch9.html#thm:generator">9.3</a> and Theorem <a href="ch9.html#thm:gen-check">9.4</a> to find all the cyclic binary codes of length&nbsp;\(3\).
</p>

<p>
<b>Solution.</b> Generator polynomials are <i>monic factors of \(x^n-1\) in \(\F _q[x]\)</i>. The first step is to factorise \(x^n-1\) into <b>irreducible monic polynomials</b> in \(\F _q[x]\). A polynomial is irreducible if it cannot be
written as a product of two polynomials of positive degree.
</p>

<p>
Note that the polynomial \(x^n-1\) is <b>not</b> irreducible in \(\F _q[x]\), for all \(n&gt;1\) and for all \(q\). Indeed, \(x^n-1=(x-1)(x^{n-1}+\dots +x+1)\).
</p>

<p>
We work over the field \(\F _2\) and observe:
</p>

<p>
\[ x^3-1 = (x - 1)(x^2+ x + 1).         \]
</p>

<p>
The polynomial \(x-1=x+1\) is irreducible, because it is of degree \(1\).
</p>

<p>
Can we factorise the polynomial \(x^2+x+1\) in \(\F _2[x]\)? If we could, we would have a factorisation \((x+a)(x+b)\). But then \(ab=1\) which means \(a=b=1\) in \(\F _2\). Note that \((x+1)^2=x^2+1\) in \(\F _2[x]\). We have shown that
\(x^2+x+1\) is irreducible in \(\F _2[x]\).
</p>

<p>
So the possible monic factors of \(x^3-1\) in \(\F _2[x]\) are:
</p>

<p>
\[ 1; \qquad 1 + x; \qquad 1+x+x^2; \qquad 1+x^3.             \]
</p>

<p>
We can now list all the cyclic codes in \(\F _2^3\) as ideals of \(R_3\) generated by each of the above polynomials. For each code we give a generator matrix \(G\), state the minimum distance \(d\) and a well-known name of the code, and point out
its dual code (which is also cyclic).
</p>
<ul style="list-style-type:none">


<li>
<p>
• \(g(x) = 1\), \(G=\begin {bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end {bmatrix}\) which corresponds to the <i>trivial binary code</i> of length&nbsp;\(3\): \(\{000,100,010,001,110,101,011,111\}=\F _2^3\) with
\(d=1\). The dual code of \(\F _2^3\) is the zero code (see below).
</p>


</li>
<li>


<p>
• \(g(x) = 1+x\), \(G=\begin {bmatrix}1&amp;1&amp;0\\0&amp;1&amp;1\end {bmatrix}\). This is \(\{000,110,011,101\}=E_3\), the binary even weight code of length \(3\) which has \(d=2\). The dual of \(E_3\) is \(\text {Rep}(3,2)\) (see
below).
</p>


</li>
<li>


<p>
• \(g(x)=1+x+x^2\), \(G=\begin {bmatrix}1&amp;1&amp;1 \end {bmatrix}\). This is \(\{000,111\}=\text {Rep}(3,2)\), the binary repetition code of length&nbsp;\(3\) with \(d=3\). This code is \((E_3)^\perp \).
</p>


</li>
<li>


<p>
• \(g(x)=1+x^3\). Theorem <a href="ch9.html#thm:gen-check">9.4</a> returns matrix \(G\) with \(k=3-3=0\) rows, \(G=[\ \ \ \ \ \ ]\). And indeed, by definition \(1+x^3\) is the generator polynomial of the zero code, \(\{000\}\), which
has empty generator matrix. It is a useless code but formally it is a linear and cyclic code, so we have to allow it for reasons of consistency. The minimum distance of the zero code is undefined. This code is \((\F _2^3)^\perp \).
</p>
</li>
</ul>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch9ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-35"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch9ex ......
-->
<h3 id="autosec-36">Chapter&nbsp;<span class="sectionnumber">9&#x2003;</span>Exercises to Chapter 9 </h3>
<a id="lecnotes_html-autopage-36"></a>
<a id="lecnotes_html-autofile-24"></a>

<p>
Version 2022-11-16. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.1</span></span>.
</p>

<p>
Find all cyclic codes of weight 1 in \(\F _q^n\).
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
[<a href="ch9exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.2</span></span>.   Let \(C\subseteq \F _2^n\) be a binary cyclic code with generator polynomial \(g(x).\) Prove that
the following are equivalent: (i) \(g(1)=0\); (ii) the vector \(\ul g\in \F _2^n\) has even weight; (iii) \(C\subseteq E_n.\)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch9exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.3</span></span>.                      A <i>burst</i> of length \(\le l\) is defined as a vector in \(\F _q^n\) with chosen \(l\)
consecutive symbols such that all non-zeros occur only within the chosen \(l\) symbols.
</p>

<p>
(a) Explain why a burst of length \(\le l\) has weight at most \(l\), but not every vector of weight \(l\) or less is a burst of length \(\le l.\)
</p>

<p>
(b) Let \(C\subseteq \F _q^n\) be a cyclic code with generator polynomial of degree \(r.\) Show that \(C\) can detect all burst errors of length \(\le r.\) (<i>That is, a burst of length \(\le r\) is not a codeword.</i>)<br />
<i>Hint</i>: if a burst \(\ul b\ne \ul 0\) is a codeword, then all vectors obtained from \(\ul b\) by cyclic shifts are also codewords. Shift \(\ul b\) to positions \(0,1,\ldots ,r-1\) so that the polynomial \(b(x)\) is of degree \(\le r-1.\)
Show that a polynomial of degree \(\le r-1\) cannot be a codeword.
</p>

<p>
(<i>Informally: this means that burst error detection by cyclic codes is better than “generic” error detection. Cyclic codes are used for encoding information stored on CDs and memory cards and transmitted via Ethernet networks where the errors that
occur are likely to be burst errors — scratches, electrical noise etc.</i>)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch9exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.4</span></span>.                 Data read from an SD memory card is encoded by CRC-16-CCITT which is a binary cyclic code
\(C\) with generator polynomial \(g(x)=x^{16}+x^{12}+x^{5}+1.\) The smallest \(n\) for which \(g(x)\) divides the polynomial \(x^n-1\) in \(\F _2[x]\) is \(n=32767\); accordingly, \(C\) is of length 32767.
</p>

<p>
(a) What is the number of rows and columns in the generator matrix of \(C\)? In the check matrix of \(C\)? What is the degree of the parity check polynomial of \(C\)?
</p>

<p>
(b) What is the rate of \(C\)?
</p>

<p>
(c) Show that \(C\) detects all burst errors of length up to 16.
</p>

<p>
(d) Explain why \(d(C)\) is not greater than 4. Show that \(d(C)\) is even. Prove that \(d(C)=4.\)
</p>

</li>

</ul>

</div>

<p>
[<a href="ch9exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch9exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-7"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch9exans ......
-->
<h3 id="autosec-8">Chapter&nbsp;<span class="sectionnumber">9&#x2003;</span>Exercises to Chapter 9 — solutions</h3>
<a id="lecnotes_html-autopage-8"></a>
<a id="lecnotes_html-autofile-25"></a>

<p>
Version 2022-11-16. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.1</span></span>.
</p>

<p>
Find all cyclic codes of weight 1 in \(\F _q^n\).
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<b>Answer to E9.1. </b> [<a href="ch9ex.html#.">These exercises without answers</a>]
</p>

<p>
If \(C\) is of weight \(1\), \(C\) contains a vector \((0,\ldots ,0,\lambda ,0,\ldots ,0)\) where \(\lambda \) is the only non-zero symbol; hence by linearity also \((0,\ldots ,0,1,0,\ldots ,0)\). Cyclic shifts of this vector span the space
\(\F _q^n\), so \(C\) must contain all vectors of length \(n\). Hence \(C\) is trivial. Trivial codes are the only cyclic codes of weight \(1\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.2</span></span>.                       Let \(C\subseteq \F _2^n\) be a binary cyclic code with generator polynomial \(g(x).\) Prove that
the following are equivalent: (i) \(g(1)=0\); (ii) the vector \(\ul g\in \F _2^n\) has even weight; (iii) \(C\subseteq E_n.\)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E9.2. </b> [<a href="ch9ex.html#.">These exercises without answers</a>]
</p>

<p>
(i) \(\iff \) (ii): the value of the polynomial \(g(x)=x^{d_1}+x^{d_2}+\dots +x^{d_w}\) at 1 is the number, \(w\), of non-zero terms in \(g(x)\), taken modulo 2 (because it is in the field \(\F _2\)). This is the same as the number of non-zero
bits in the vector \(\ul g\) — the weight of \(\ul g\) — taken modulo 2. Hence \(g(1)=w(\ul g)\) mod 2.
</p>

<p>
(ii) \(\implies \) (iii): by Theorem, a basis of \(C\) is formed by \(\ul g\) and its cyclic shifts, which all have the same even weight. Since the basis of \(C\) lies in \(E_n\) and \(E_n\) is a vector space, the whole of \(C\) is a subspace of \(E_n.\)
</p>

<p>
(iii) \(\implies \) (ii): let \(C\subseteq E_n.\) Since \(\ul g\) is a codevector of \(C\), \(\ul g\in E_n.\) Hence \(w(\ul g)\) is even.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.3</span></span>.                      A <i>burst</i> of length \(\le l\) is defined as a vector in \(\F _q^n\) with chosen \(l\)
consecutive symbols such that all non-zeros occur only within the chosen \(l\) symbols.
</p>

<p>
(a) Explain why a burst of length \(\le l\) has weight at most \(l\), but not every vector of weight \(l\) or less is a burst of length \(\le l.\)
</p>

<p>
(b) Let \(C\subseteq \F _q^n\) be a cyclic code with generator polynomial of degree \(r.\) Show that \(C\) can detect all burst errors of length \(\le r.\) (<i>That is, a burst of length \(\le r\) is not a codeword.</i>)<br />
<i>Hint</i>: if a burst \(\ul b\ne \ul 0\) is a codeword, then all vectors obtained from \(\ul b\) by cyclic shifts are also codewords. Shift \(\ul b\) to positions \(0,1,\ldots ,r-1\) so that the polynomial \(b(x)\) is of degree \(\le r-1.\)
Show that a polynomial of degree \(\le r-1\) cannot be a codeword.
</p>

<p>
(<i>Informally: this means that burst error detection by cyclic codes is better than “generic” error detection. Cyclic codes are used for encoding information stored on CDs and memory cards and transmitted via Ethernet networks where the errors that
occur are likely to be burst errors — scratches, electrical noise etc.</i>)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E9.3. </b> [<a href="ch9ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) Let \(l\ge 2.\) The vector \(1,\underbrace {0,\ldots ,0}_{l-1\text { zeros}},1,0,\ldots ,0\) is of weight \(2\le l\) but is not a burst of length \(\le l.\)
</p>

<p>
(b) Let \(\ul b\ne 0\) be a burst of length \(\le r.\) Assume for contradiction that \(\ul b\) is a codeword of \(C.\) Since \(C\) is a cyclic code, all vectors obtained from \(\ul b\) by cyclic shifts are in \(C.\) In particular, the following vector
can be obtained from \(\ul b\) by cyclic shifts:
</p>

<p>
\[ \ul b&apos;= \underbrace {b_0\, b_1 \,\ldots \, b_{r-1}}_{r\text { symbols}}\,0\,0\,\ldots \, 0, \]
</p>

<p>
where the last \(n-r\) symbols are zero.
</p>

<p>
The codevector \(\ul b&apos;\) corresponds to the code polynomial \(b_0+b_1x+\ldots +b_{r-1}x^{r-1}\) which must then be divisible by \(g(x).\) But a non-zero polynomial of degree \(\le r-1\) cannot be divisible by a polynomial of degree
\(r\), a contradiction.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">9.4</span></span>.                     Data read from an SD memory card is encoded by CRC-16-CCITT which is a binary cyclic code
\(C\) with generator polynomial \(g(x)=x^{16}+x^{12}+x^{5}+1.\) The smallest \(n\) for which \(g(x)\) divides the polynomial \(x^n-1\) in \(\F _2[x]\) is \(n=32767\); accordingly, \(C\) is of length 32767.
</p>

<p>
(a) What is the number of rows and columns in the generator matrix of \(C\)? In the check matrix of \(C\)? What is the degree of the parity check polynomial of \(C\)?
</p>

<p>
(b) What is the rate of \(C\)?
</p>

<p>
(c) Show that \(C\) detects all burst errors of length up to 16.
</p>

<p>
(d) Explain why \(d(C)\) is not greater than 4. Show that \(d(C)\) is even. Prove that \(d(C)=4.\)
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E9.4. </b> [<a href="ch9ex.html#.">These exercises without answers</a>]
</p>

<p>
(a) The generator matrix of \(C\) has \(n-\deg g=32751\) rows and \(n=32767\) columns. The parity check matrix of \(C\) has \(16\) rows and \(32767\) columns. The parity check polynomial \(h\) has degree \(32751.\)
</p>

<p>
(b) The rate is \(k/n=32751/32767\approx 0.9995.\)
</p>

<p>
(c) Follows from part (b) of the previous question.
</p>

<p>
(d) It is easy to see that the weight of \(C\) is at most \(4\), because the codevector \(\ul g\) which corresponds to the generator polynomial of \(C\) has weight \(4.\)
</p>

<p>
The weight of every codevector of \(C\) is even — see an earlier exercise. In particular, let \(\ul f\) be a codevector of weight \(w(C)\); it must have even weight, so \(w(C)=d(C)\) is even.
</p>

<p>
Finally, to prove that \(w(C)=4\), assume for contradiction that \(w(\ul f)&lt;4.\) Then \(w(\ul f)=2\) (because it is even) and, up to a cyclic shift, the vector \(\ul f\) (which has two non-zero bits) corresponds to code polynomial of the form
\(1+x^d\) for some \(d&lt;32767.\) But all code polynomials are divisible by \(g(x)\), and we are given that \(g(x)\) divides \(1+x^n\) for \(n=32767\) but not for any smaller \(n.\) This is a contradiction.
</p>

<p>
<b>General remark:</b> <i>Although the generator matrix and the parity check matrix of this code are large, the encoding and error detection algorithms are based on polynomial division with remainder. This has efficient hardware and software
implementations.</i>
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch10.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-7"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch10 ......
-->
<h3 id="autosec-8">Chapter&nbsp;<span class="sectionnumber">10&#x2003;</span>Golay codes. Classification of perfect codes</h3>
<a id="lecnotes_html-autopage-8"></a>
<a id="lecnotes_html-autofile-26"></a>

<p>
Version 2022-11-22. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>

<p>
<b>Synopsis.</b> <i>One can explore cyclic codes of a given length over a given finite field in an attempt to find codes with interesting/useful properties. In fact, all types of codes we have considered so far will arise as cyclic codes. In this chapter,
we define two new linear equivalence classes of codes called Golay codes. In our approach, these arise as cyclic codes, however, historically they were found in a different way. We give without proof a complete classification of perfect codes over
alphabets of prime power size up to parameter equivalence, conjectured by Golay and proved by Tieta&#x0308;va&#x0308;inen and van Lint.</i>
</p>

<p>
The following two remarks aim to highlight useful features of cyclic codes.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-9"></a>
<span class="amsthmnamedefinition">Remark</span>.
</p>

<p>
Recall that:
</p>
<ul style="list-style-type:none">


<li>
<p>
• the only way to specify a general non-linear code in \(\F _q^n\) is to list all the codewords, which consist of a total of \(q^k\times n\) symbols;
</p>


</li>
<li>


<p>
• a linear code can be specified by a generator matrix, which has \(k\times n\) entries;
</p>


</li>
<li>


<p>
• a cyclic code can be specified in an even more compact way — by giving its generator polynomial, which corresponds to a single codeword! We only need to specify \(n-k\) coefficients of the generator polynomial (its degree is \(n-k\) and its
leading coefficient is \(1\)).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-10"></a>
<span class="amsthmnamedefinition">Remark</span>.        <b>What do we use check matrices for?</b> For example, to find the minimum distance of a linear code.
</p>

<p>
<b>Strategy of searching for interesting/perfect/etc codes:</b>
</p>

<p>
Look for divisors of \(x^n-1\) and hope that the cyclic codes they generate have a large minimum distance. <b>For example,</b> among the cyclic codes in \(\mathbb F_2^7\), there are two perfect, Hamming codes (<i>Exercise</i>).
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-11"></a>
<span class="amsthmnamedefinition">Example</span><span class="amsthmnumberdefinition"> <span class="textup">10.1</span></span><span class="amsthmnotedefinition"> (two new perfect codes — the Golay codes)</span>.
</p>

<p>
The following two codes were found by Marcel Golay in 1949. They are known as the <i>binary Golay code</i> and the <i>ternary Golay code</i>, respectively.
</p>

</li>

</ul>
<!--
......   subsection The binary Golay code        ......
-->
<h5 id="autosec-12">The binary Golay code \(G_{23}\)</h5>
<a id="lecnotes_html-autopage-12"></a>



<p>
In \(\F _2[x]\), \(x^{23}-1=(x-1)g(x)\overleftarrow g(x)\), where \(g(x)=x^{11}+x^{10}+x^6+x^5+x^4+x^2+1\) and \(\overleftarrow g(x)=x^{11}+x^9+x^7+x^6+x^5+x+1.\) (<i>Exercise</i>: check this! You may use a computer algebra
system but it is always instructive to do this by hand.)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-13"></a>
<span class="amsthmnamedefinition">Definition</span>.   Define a <b><i>binary Golay code</i></b> to be the cyclic code in \(\mathbb F_2^{23}\) generated by \(g(x)\), or any code linearly equivalent to it.
</p>

<p>
(Any) binary Golay code is denoted \(G_{23}.\)
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-14"></a>
<span class="amsthmnamedefinition">Remark</span>.          The cyclic code generated by \(g_1(x)\) is seen to be linearly equivalent to the cyclic code generated by \(g(x)\); the linear equivalence is by writing all the codevectors backwards.
</p>

<p>
The above definition does not reflect how the code was originally found (see below) but suggests a practical way to construct a \(G_{23}\) code if need be: factorise \(x^{23}-1\) over \(\mathbb F_2\) into irreducible factors (e.g., using a computer
algebra system) and take one such factor of degree greater than \(1\) to be the generator polynomial of a cyclic code.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-15"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">10.2</span></span>.   <a id="thm:G23"></a> \(G_{23}\) is a perfect \([23,12,7]_2\)-code.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="lecnotes_html-autopage-16"></a>

<ul style="list-style-type:none">



<li>
<p>
<span class="amsthmproofname">Proof.</span> (<i>partially computer-aided</i>) The code is binary of length \(n=23\) by construction. The dimension is \(23-\deg g=12.\) We will <span class="underline">not</span> formally prove that
\(d=7\) (although an algebraic proof can be found in the literature, it is beyond the scope of this course). Observe that \(d\le 7\): indeed, the vector \(\ul g\in G_{23}\) is \(10101110001100000000000\), of weight&nbsp;\(7.\)
</p>

<p>
The minimum weight of \(G_{23}\) can be found using a computer — consider for example the following code written for the computer algebra system <a href="https://www.sagemath.org/" target="_blank" ><b>SageMath</b></a>:
</p>
<pre class="verbatim">
sage: R.<x>=GF(2)[]
sage: factor(x^23 - 1)
(x+1)*(x^11+x^9+x^7+x^6+x^5+x+1)*(x^11+x^10+x^6+x^5+x^4+x^2+1)
sage: g = factor(x^23 - 1)[1][0]
sage: messagepolynomials = R.monics( max_degree=23-g.degree()-1 )
sage: codepolynomials = [ u*g for u in messagepolynomials ]
sage: min([ len(c.coefficients()) for c in codepolynomials ])
7

</pre>

<p>
To show that \(G_{23}\) is perfect, write the Hamming bound for a binary code in in logarithmic form: \(k\le n-\log _2\left (\binom n0 +\dots +\binom nt\right ).\) Here \(t=[(7-1)/2]=3\) so the expression under the logarithm is
\(1+\binom {23}{1}+\binom {23}{2}+\binom {23}{3}= 1+23+23\times \frac {22}{2}+23\times \frac {22}{2}\times \frac {21}{3} =1+23(1+11+77)=2048.\) One has \(12 = 23-\log _2 2048\) hence the Hamming bound is attained. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
......   subsection Trivia ......
-->
<h5 id="autosec-18">Trivia</h5>
<a id="lecnotes_html-autopage-18"></a>



<p>
The code \(G_{23}\) was used by Voyager 1 &amp; 2 spaceships (NASA, Jupiter and Saturn, 1979–81). More precisely, the Golay code was used in a version extended to \(24\) bits by adding a parity check bit to each codevector, see Exercise&nbsp;<a
href="ch10exans.html#ex:G24">10.1</a>. This increased the minimum distance to \(8\) thereby improving error detection (not affecting error correction). But the extended \(24\) bit code \(G_{24}:=\widehat G_{23}\) is no longer perfect.
</p>
<!--
......   subsection The ternary Golay code   ......
-->
<h5 id="autosec-19">The ternary Golay code \(G_{11}\)</h5>
<a id="lecnotes_html-autopage-19"></a>



<p>
In \(\F _3[x]\), \(x^{11}-1=(x-1)g(x)g_1(x)\) where \(g(x)=x^5+x^4+2 x^3+x^2+2\) and \(g_1(x) =-\overleftarrow g(x) = x^5+2x^3+x^2+2x+2.\)
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-20"></a>
<span class="amsthmnamedefinition">Definition</span>.   A <b><i>ternary Golay code</i></b> is the the cyclic code in \(\mathbb F_3^{11}\) generated by \(g(x)\), or any code linearly equivalent to it. (<i>Notation</i>: \(G_{11}.\))
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-21"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">10.3</span></span>.   <a id="thm:G11"></a> \(G_{11}\) is a perfect \([11,6,5]_3\) code.
</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-22"></a>
<span class="amsthmnamedefinition">Exercise</span>.   Prove Theorem <a href="ch10.html#thm:G11">10.3</a>, modifying the computer code provided in the proof of Theorem&nbsp;<a href="ch10.html#thm:G23">10.2</a> to calculate the
weight of \(G_{11}.\)
</p>

</li>

</ul>

</div>
<!--
......   subsection Historical notes ......
-->
<h5 id="autosec-23">Historical notes</h5>
<a id="lecnotes_html-autopage-23"></a>



<p>
Golay found his two perfect codes in 1949, before cyclic codes were discovered. He defined the codes \(G_{23}\) and \(G_{11}\) by writing their check matrices. Crucially, Golay observed that \(\binom {23}{0}+\binom {23}{1}+\binom
{23}{2}+\binom {23}{3}\) is a power of two. From the proof of perfectness above one can see that the condition \(\binom {n}{0}+\dots +\binom {n}{t}=2^r\) is necessary for the existence of a perfect \(t\)-error-correcting binary code of length
\(n.\) This condition is not sufficient: e.g., in his 1949 paper Golay also observes that \(\binom {90}{0}+\binom {90}{1}+\binom {90}{2}=2^{12}\) but this does not lead to any perfect binary code of length 90.
</p>

<p>
Amazingly, Golay’s 1949 paper where he constructs all the Hamming codes and the two Golay codes, is barely half a page long.
</p>

</div>

<p>
Now we can state the classification theorem about perfect codes. It was proved in 1973, more than twenty years since Golay gave a conjecturally complete list of perfect codes in alphabets of prime power size. We will not give its proof here, but you
should learn the statement of the theorem.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-24"></a>
<span class="amsthmnamedefinition">Definition</span><span class="amsthmnotedefinition"> (parameter equivalence)</span>.
</p>

<p>
We say that two codes are <i>parameter equivalent</i>, if they both are \([n,k,d]_q\)-codes for some \(n, k, d\) and \(q.\)
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-25"></a>
<span class="amsthmnamedefinition">Theorem</span><span class="amsthmnumberdefinition"> <span class="textup">10.4</span></span><span class="amsthmnotedefinition"> (Tieta&#x0308;va&#x0308;inen – van Lint, 1973;
classification of perfect codes where \(q\) is a prime power)</span>.
</p>

<p>
Let \(q\) be a power of a prime number. A perfect \([n,k,d]_q\)-code is parameter equivalent to one of the following:
</p>
<ul style="list-style-type:none">


<li>
<p>
• a trivial code: \(n\) arbitrary, \(k=n\), \(d=1\), \(q\) any prime power;
</p>


</li>
<li>


<p>
• a binary repetition code of odd length: \(n\) odd, \(k=1\), \(d=n\), \(q=2\);
</p>


</li>
<li>


<p>
• a Hamming code \(\Ham (r,q)\): \(n=\dfrac {q^r-1}{q-1}\), \(k=n-r\), \(d=3\), \(q\) any prime power;
</p>


</li>
<li>


<p>
• the Golay code \(G_{23}\), which is a \([23,12,7]_2\)-code;
</p>


</li>
<li>


<p>
• the Golay code \(G_{11}\) which is an \([11,6,5]_3\)-code.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-26"></a>
<span class="amsthmnamedefinition">Remark</span>.   Classification of perfect codes over alphabets of size not equal to a prime power is, in general, an open problem.
</p>

</li>

</ul>

</div>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch10ex.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-28"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch10ex ......
-->
<h3 id="autosec-29">Chapter&nbsp;<span class="sectionnumber">10&#x2003;</span>Exercises to Chapter 10 </h3>
<a id="lecnotes_html-autopage-29"></a>
<a id="lecnotes_html-autofile-27"></a>

<p>
Version 2022-11-22. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.1</span></span><span class="amsthmnotedefinition"> (the extended binary Golay code)</span>.   <a
id="ex:G24"></a>The code \(G_{24}\) as defined as \(\widehat {G}_{23}\), that is, by <i>extending</i> the binary Golay code defined earlier.
</p>

<p>
(a) Determine the parameters \([n,k,d]_q\) of \(G_{24}.\) State how many bit errors per codevector is the code guaranteed to <i>detect</i>. Same for <i>correct</i>. Find the rate of \(G_{24}.\)
</p>

<p>
(b) A codevector of \(G_{24}\) is transmitted, and thirteen bit errors occur. Will an error be detected?
</p>

<p>
(c) Prove that \(G_{24}\) is a self-dual code. The proof may involve calculations, but they should not be computer-aided — it should be possible to do them by hand in a reasonable amount of time.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch10exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-3"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.2</span></span><span class="amsthmnotedefinition"> (<i>This exercise is discussed in the review
sessions</i>)</span>.   <a id="ex:F27"></a>Find all possible binary cyclic codes of length \(7\). For each such code, find its minimum distance, determine whether the code is perfect. Determine which codes that you obtain are linearly equivalent.
</p>

</li>

</ul>

</div>

<p>
[<a href="ch10exans.html#.">Answers to these exercises</a>]
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-4"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.3</span></span>.                      <a id="ex:G11"></a>(i) Show that a perfect ternary code of length \(11\) and minimum distance
\(5\) must contain \(729\) codewords.
</p>

<p>
(ii) A football match can end in a Win (2), Draw (1) or Loss (0) for your club. You buy a <i>football pool</i> ticket which contains 11 boxes. You fill in the boxes trying to predict the result of each of the 11 matches your club will play in a
forthcoming tournament. If, at the end of the tournament, it turns out that your ticket contained 9 or more correct guesses (out of 11), you win a prize.
</p>
<ul style="list-style-type:none">


<li>
<p>
(a) Assuming that the outcomes of the 11 matches are completely independent and random, show that one ticket wins a prize with a probability \(\frac {1}{729}\). [<i>Of course, this does not mean that just by completing 729 tickets you are
guaranteed a prize!</i>]
</p>
</li>
<li>


<p>
(b) Explain how one can use a code from (i) to buy and complete 729 football pool tickets and to <i>guarantee</i> that one of them wins a prize.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
[<a href="ch10exans.html#.">Answers to these exercises</a>]
</p>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|ch10exans.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-6"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch10exans ......
-->
<h3 id="autosec-7">Chapter&nbsp;<span class="sectionnumber">10&#x2003;</span>Exercises to Chapter 10 — solutions</h3>
<a id="lecnotes_html-autopage-7"></a>
<a id="lecnotes_html-autofile-28"></a>

<p>
Version 2022-11-22. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-2"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.1</span></span><span class="amsthmnotedefinition"> (the extended binary Golay code)</span>.                              <a
id="ex:G24"></a>The code \(G_{24}\) as defined as \(\widehat {G}_{23}\), that is, by <i>extending</i> the binary Golay code defined earlier.
</p>

<p>
(a) Determine the parameters \([n,k,d]_q\) of \(G_{24}.\) State how many bit errors per codevector is the code guaranteed to <i>detect</i>. Same for <i>correct</i>. Find the rate of \(G_{24}.\)
</p>

<p>
(b) A codevector of \(G_{24}\) is transmitted, and thirteen bit errors occur. Will an error be detected?
</p>

<p>
(c) Prove that \(G_{24}\) is a self-dual code. The proof may involve calculations, but they should not be computer-aided — it should be possible to do them by hand in a reasonable amount of time.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E10.1. </b> [<a href="ch10ex.html#.">These exercises without answers</a>]
</p>

<p>
Extending a binary code means appending a parity check bit to every codevector, so that the resulting vector is of even weight. Appending one bit increases the length by \(1\), so the length \(n\) of \(G_{24}\) is \(24.\)
</p>

<p>
Appending a bit to every codevector does not change the number of codevectors. The \(G_{23}\) is a \([23,12,7]_2\) code, so \(\#G_{24}=\#G_{23}=2^{12}\) and \(k=12\).
</p>

<p>
The minimum weight vector in \(G_{23}\setminus \{0\}\) has weight \(7\), so after extending, it becomes a vector of weight \(8.\) Extending a vector cannot decrease its weight, so \(d=w(G_{24})=8\). A \([24,12,8]_2\) code which is
guaranteed to detect up to \(8-1=7\) errors per codevector and is guaranteed to correct \([(8-1)/2]=3\) errors per codevector.
</p>

<p>
The rate of \(G_{24}\) is \(k/n=12/24=1/2\).
</p>

<p>
(b) When \(13\) bit errors occur in a vector of even weight, the received vector has odd weight. Since all codevectors of \(G_{24}\) have even weight (by construction), this will result in a detected error — despite \(13\) being greater than \(7\).
</p>

<p>
(c) We can construct a generator matrix \(\widehat G\) for \(G_{24}\) by adding a parity check bit to every row of a generator matrix \(G\) for \(G_{23}\). We will choose \(G\) to generate <i>cyclic</i> \(G_{23}\), and the rows of \(G\) will be
the cyclic shifts of the vector \(\ul g\) where \(g(x)=1+x^2+x^4+x^5+x^6+x^{10}+x^{11}\):
</p>
<div class="center">

<p>

<a href="G24genmatrix1.svg" target="_blank" ><img
    src="G24genmatrix1.svg"
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>

<p>
(only the first, second and 12<sup>th</sup> rows of \(G\) shown, blanks mean zeros). To construct \(\widehat G\), we extend each row of \(G\); since the weight of each row of \(G\) is \(7\), which is odd, we append&nbsp;\(1\):
</p>
<div class="center">

<p>

<a href="G24genmatrix2.svg" target="_blank" ><img
    src="G24genmatrix2.svg"
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>

<p>
To show that \(G_{24}\) is self-orthogonal, we need to check that \(n=2k\), \(24=2\times 12\) which is true; and also that \(\widehat G \widehat G^T=0\), equivalently the inner product of any two rows of \(\widehat G\) is \(0\).
</p>

<p>
Taking into account the product of the trailing \(\color {red}1\)s, we need to verify the equivalent statement that the inner product of any two of the cyclic shifts \(\ul g\), \(s(\ul g),\dots ,s^{11}(\ul g)\) is&nbsp;\(1\). This is easily seen
to reduce to the inner product of \(\ul g\) itself and its cyclic shifts. So one manually checks that the inner product of \(\ul g\) with \(s^i(\ul g)\), \(i=0,\dots ,11\) is&nbsp;\(1\).
</p>

<p>
This simplifies even further: note that the inner product of the vectors \(\ul a\) and \(\ul b_{\mathrm {backwards}}\) in \(\F _2^{23}\) is equal to the coefficient of \(x^{22}\) in the polynomial \(a(x)b(x)\). Let \(a(x) = x^ig(x)\) and
\(b(x) = \overleftarrow {g}(x) =x^{11}+x^9+x^7+x^6+x^5+x+1\), so that \(\ul a = s^i(\ul g)\) and \(\ul b_{\mathrm {backwards}}=\ul g\). Note that \(a(x)b(x)=x^ig(x)\overleftarrow g(x)=x^i\frac {x^{23}+1}{x+1}
=x^i(x^{22}+x^{21}+\dots +x+1)\). This polynomial contains the term \(x^{22}\) for all \(i=0,1,\dots ,11\), which proves that \(\ul a \cdot \ul b=1\), completing the proof of self-orthogonality of \(G_{24}\).
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-5"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.2</span></span><span class="amsthmnotedefinition"> (<i>This exercise is discussed in the review
sessions</i>)</span>.    Find all possible binary cyclic codes of length \(7\). For each such code, find its minimum distance, determine whether the code is perfect. Determine which codes that you obtain are linearly equivalent.
</p>

</li>

</ul>

</div>

<p>
<b>Answer to E10.2. </b> [<a href="ch10ex.html#.">These exercises without answers</a>]
</p>

<p>
First of all, one needs to write the polynomial \(x^7 - 1\) as a product of irreducible factors. One can always start with \(x-1\), because \(x-1\) is always a factor of \(x^n-1\) for any \(n\) and for every field \(\F _q\). We have \(x^7-1= (x -
1)(x^6+x^5+x^4+x^3+x^2+x+1)\).
</p>

<p>
We now need to factorise \(x^6+x^5+x^4+x^3+x^2+x+1\) over \(\F _2\). Unfortunately there is no easy way. One can use brute force (<i>this will not be expected in the exam</i>): check whether any of the polynomials of degree \(1\) are factors of
\(x^6+x^5+x^4+x^3+x^2+x+1\), then polynomials of degree \(2\), then polynomials of degree \(3\). In this case we obtain the factorisation \(x^6+x^5+x^4+x^3+x^2+x+1= (x^3 + x + 1)(x^3 + x^2 + 1)\). We conclude that
</p>

<p>
\[ x^7-1=(x+1)(x^3 + x + 1)(x^3 + x^2 + 1) \]
</p>

<p>
as a product of irreducible polynomials over \(\F _2\). (Note that \(x-1\) is the same as \(x+1\) over \(\F _2\).)
</p>

<p>
There are thus \(8\) cyclic binary codes of length \(7\): they correspond to generator polynomials which are product of a subset of the three irreducible factors of \(x^7-1\). To list all of them, we denote \(g_1=x+1\), \(g_2=x^3+x+1\),
\(g_3=x^3+x^2+1\):
</p>

<p>
\[ \begin {array}{lcc} g\text { (generator polynomial)} &amp; \deg g &amp; \dim g R_7 \\ \hline 1 &amp; 0 &amp; 7 \\ g_1 &amp; 1 &amp; 6 \\ g_2, \, g_3 &amp; 3 &amp; 4 \\ g_1 g_2, \, g_1 g_3 &amp; 4 &amp; 3 \\
g_2g_3 &amp; 6 &amp; 1 \\ g_1g_2g_3 &amp; 7 &amp; 0 \end {array} \]
</p>

<p>
<i>The code of dimension \(0\)</i> is \(\{\ul 0\}\), a cyclic code with generator polynomial \(x^7-1\).
</p>

<p>
<i>Dimension \(1\)</i>: the generator polynomial of this code is \((x^3+x+1)(x^3+x^2+1)= 1+x+x^2+x^3+x^4+x^5+x^6\), see the table given above. Therefore, its generator matrix is
</p>

<p>
\[ G=\left [\begin {matrix}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\end {matrix}\right ] .                \]
</p>

<p>
This is the generator matrix of the <i>binary repetition code of length \(7\)</i>. The minimum distance of this code is \(7\).
</p>

<p>
<i>Dimension \(6\)</i>: according to the table, the generator polynomial is \(g=x+1\). Therefore, the check polynomial is \(h=\frac {x^7-1}{g}=1+x+x^2+x^3+x^4+x^5+x^6\). Then the check matrix is \(H=\left [\begin
{matrix}1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1\end {matrix}\right ]\). The check matrix generates the dual code, which therefore is the repetition code. The code of dimension \(6\) is dual to the repetition code, hence is the <i>binary even
weight code of length \(7\)</i>. The minimum distance is \(2\).
</p>

<p>
<i>Dimension \(7\)</i>: the only code which has dimension equal to length is the trivial code. So the answer is the <i>trivial binary code of length \(7\)</i>. It has generator polynomial \(1\) (of degree 0).
</p>

<p>
<i>Dimension \(3\)</i>: we get two codes which are seen to be <i>simplex codes</i> \(\Sigma (3,2)= \Ham (3,2)^\perp \). From the above factorisation, there are two generator polynomials of degree \(4\):
</p>

<p>
\[ g_1(x) = (x+1)(x^3+x+1) = x^4+x^3+x^2+1 \text { and } g_2(x) = (x+1)(x^3+x^2+1) = x^4+x^2+x+1, \]
</p>

<p>
giving rise to the generator matrices
</p>

<p>
\[ G_1 = \begin {bmatrix} 1&amp;0&amp;1&amp;1&amp;1&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;1&amp;1&amp;1&amp;0 \\ 0&amp;0&amp;1&amp;0&amp;1&amp;1&amp;1 \end {bmatrix} \quad \text {and}\quad G_2 = \begin {bmatrix}
1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0 \\ 0&amp;1&amp;1&amp;1&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1 \end {bmatrix} \]
</p>

<p>
which generate the codes \(C_1\) and \(C_2\). Observing that \(G_2\) is obtained from \(G_1\) by permuting columns (e.g., permutation \(2\to 6\to 4\to 2\), \(3\leftrightarrow 5\) <i>or</i> notice that both matrices are made up of
<i>all</i> possible non-zero columns of size \(3\) — they are parity check matrices for Hamming code \(\mathrm {Ham}(3,2)\)), we conclude that both codes are \(\Sigma (3,2)\) and are linearly equivalent. Recall that their weight can be found
by writing down all the 7 non-zero codevectors; all of them have weight 4. They are \([7,3,4]_2\)-codes and are not perfect (the minimum distance is even).
</p>

<p>
<i>Dimension \(4\)</i>: there are two codes, one generated by \(x^3+x+1\), the other by \(x^3+x^2+1\). Consider the code \(D\) with generator polynomial \(g(x)=x^3+x+1\). The parity check polynomial of \(D\) is \(h(x)=
(x+1)(x^3+x^2+1)=x^4+x^2+x+1\) so its parity check matrix given by Theorem <a href="ch9.html#thm:gen-check">9.4</a> is
</p>

<p>
\[ H=\begin {bmatrix} 0&amp;0&amp;1&amp;0&amp;1&amp;1&amp;1 \\ 0&amp;1&amp;0&amp;1&amp;1&amp;1&amp;0 \\ 1&amp;0&amp;1&amp;1&amp;1&amp;0&amp;0 \end {bmatrix}.                            \]
</p>

<p>
This is the same as matrix \(G_1\) above (with the order of rows reversed — but this does not affect the code generated by the matrix), hence \(D^\perp \) is a \(\Sigma (3,2)\) code \(C_1\). Therefore, \(D\) is a \(\Ham (3,2)\) code, which is a
perfect \([7,4,3]_2\)-code.
</p>

<p>
A completely similar argument shows that the code \(D&apos;\) with generator polynomial \(x^3+x^2+1\) is dual to \(C_2\), hence is another \(\Ham (3,2)\) code and is linearly equivalent to \(D\).
</p>

<p>
There are thus 8 binary cyclic codes of length 7. None of them has dimension 2 or 5.
</p>
<div class="amsthmbodydefinition">

<ul style="list-style-type:none">



<li>
<p>
<a id="lecnotes_html-autopage-6"></a>
<span class="amsthmnamedefinition">Exercise</span><span class="amsthmnumberdefinition"> <span class="textup">10.3</span></span>.                      (i) Show that a perfect ternary code of length \(11\) and minimum distance \(5\) must contain
\(729\) codewords.
</p>

<p>
(ii) A football match can end in a Win (2), Draw (1) or Loss (0) for your club. You buy a <i>football pool</i> ticket which contains 11 boxes. You fill in the boxes trying to predict the result of each of the 11 matches your club will play in a
forthcoming tournament. If, at the end of the tournament, it turns out that your ticket contained 9 or more correct guesses (out of 11), you win a prize.
</p>
<ul style="list-style-type:none">


<li>
<p>
(a) Assuming that the outcomes of the 11 matches are completely independent and random, show that one ticket wins a prize with a probability \(\frac {1}{729}\). [<i>Of course, this does not mean that just by completing 729 tickets you are
guaranteed a prize!</i>]
</p>
</li>
<li>


<p>
(b) Explain how one can use a code from (i) to buy and complete 729 football pool tickets and to <i>guarantee</i> that one of them wins a prize.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
<b>Answer to E10.3. </b> [<a href="ch10ex.html#.">These exercises without answers</a>]
</p>

<p>
(i) Here is a calculation of the Hamming bound for a ternary code of length \(11\) and minimum distance \(5\): \(t=[\frac {5-1}{2}]=2\), \(\#S_2(\ul 0)=\binom {11}{0}+\binom {11}{1}(3-1)+\binom {11}{2} (3-1)^2=1+11\times
2+55\times 2^2 = 243=3^5\), so that the Hamming bound (hence the cardinality of a perfect code) is \(3^{11} \, / \, \#S_2(\ul 0)=3^{11}/3^5=3^6=729\).
</p>

<p>
(ii) (a) Let \(\ul X\) denote the vector of match outcomes. Let \(\ul Y\) denote the vector of values written on the ticket. The probablility that \(\ul Y\) wins a prize is the probability that \(d(\ul X,\ul Y)\le 2\), or, the same, that \(\ul X\)
belongs to the sphere \(S_2(\ul Y)\). Given the assumption that \(\ul X\) is uniformly distributed in \(\F _3^{11}\), this probability is calculated as \(\frac {\#S_2(\ul Y)}{\#\F _3^{11}}\). Note that \(\#S_2(\ul Y)=\#S_2(\ul 0)=243\),
so that the answer is \(243/3^{11}=1/729\).
</p>

<p>
(b) In fact, this is how the ternary Golay code \(G_{11}\), which is a perfect \([11,6,5]_3\) code, was discovered by Finnish football pool enthusiast Juhani Virtakallio in 1947. Read about this in:
</p>

<p>
A. Barg, <em>At the Dawn of the Theory of Codes</em>, The Mathematical Intelligencer 15, no. 1, 1993, pp. 20–26; <a href="http://www.ece.umd.edu/~abarg/reprints/dawn.pdf" target="_blank"
>http://www.ece.umd.edu/~abarg/reprints/dawn.pdf</a>
</p>

<p>
Virtakallio published the code — all the \(729\) codewords — in three (!) issues of a football pool magazine. When Marcel Golay rediscovered the code in 1949, he realised that \(G_{11}\) is a linear code, so it is enough to give only a check matrix.
Following the introduction of cyclic codes in 1957 by Eugene Prange, we can define this code by its generator polynomial \(x^5+x^4+2 x^3+x^2+2\).
</p>

<p>
Briefly, one should write the 729 codewords of this perfect code \(C\) in the 729 tickets. Recall from the proof of the Hamming bound that, since \(C\) is perfect, the space \(\F _3^{11}\) is covered by spheres of radius \(t=2\) centred at codevectors
from \(C\). Hence every vector in \(\F _3^{11}\) is at distance \(\le 2\) from a codevector of \(C\). Therefore, for every possible vector \(\ul X\) of 11 match outcomes there will be one out of the 729 tickets (codewords) which will differ from
\(\ul X\) in at most two positions. That ticket will win the prize.
</p>
<a id="lecnotes_html-autofile-last"></a>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
