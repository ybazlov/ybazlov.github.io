
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="bazlovstyle.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
    subequations: "0",
    section: "",
    loader: {
        load: ['[tex]/tagformat', '[tex]/textmacros'],
    },
    startup: {
        ready() {
            //      These would be replaced by import commands if you wanted to make
            //      a proper extension.
            const Configuration = MathJax._.input.tex.Configuration.Configuration;
            const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
            const Macro = MathJax._.input.tex.Symbol.Macro;
            const TexError = MathJax._.input.tex.TexError.default;
            const ParseUtil = MathJax._.input.tex.ParseUtil.default;
            const expandable = MathJax._.util.Options.expandable;


            //      Insert the replacement string into the TeX string, and check
            //      that there haven't been too many maxro substitutions (prevents
            //      infinite loops).
            const useArgument = (parser, text) => {
                parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                parser.i = 0;
                if (++parser.macroCount > parser.configuration.options.maxMacros) {
                    throw new TexError('MaxMacroSub1',
                    'MathJax maximum macro substitution count exceeded; ' +
                    'is there a recursive macro call?');
                }
            }


            //      Create the command map for:
            //          \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
            new CommandMap('Lwarp-macros', {
                ifstar: 'IfstarFunction',
                ifnextchar: 'IfnextcharFunction',
                ifblank: 'IfblankFunction',
                ifstrequal: 'IfstrequalFunction',
                gsubstitute: 'GsubstituteFunction',
                seteqnumber: 'SeteqnumberFunction'
            }, {
                //      This function implements an ifstar macro.
                IfstarFunction(parser, name) {
                    const resultstar = parser.GetArgument(name);
                    const resultnostar = parser.GetArgument(name);
                    const star = parser.GetStar();                      // true if there is a *
                    useArgument(parser, star ? resultstar : resultnostar);
                },


                //      This function implements an ifnextchar macro.
                IfnextcharFunction(parser, name) {
                    let whichchar = parser.GetArgument(name);
                    if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                        // $ syntax highlighting
                        whichchar = String.fromCodePoint(parseInt(whichchar));
                    }
                    const resultnextchar = parser.GetArgument(name);
                    const resultnotnextchar = parser.GetArgument(name);
                    const gotchar = (parser.GetNext() === whichchar);
                    useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                },


                // This function implements an ifblank macro.
                IfblankFunction(parser, name) {
                    const blankarg = parser.GetArgument(name);
                    const resultblank = parser.GetArgument(name);
                    const resultnotblank = parser.GetArgument(name);
                    const isblank = (blankarg.trim() == "");
                    useArgument(parser, isblank ? resultblank : resultnotblank);
                },


                // This function implements an ifstrequal macro.
                IfstrequalFunction(parser, name) {
                    const strequalfirst = parser.GetArgument(name);
                    const strequalsecond = parser.GetArgument(name);
                    const resultequal = parser.GetArgument(name);
                    const resultnotequal = parser.GetArgument(name);
                    const isequal = (strequalfirst == strequalsecond);
                    useArgument(parser, isequal ? resultequal : resultnotequal);
                },


                // This function implements a gsub macro.
                GsubstituteFunction(parser, name) {
                    const gsubfirst = parser.GetArgument(name);
                    const gsubsecond = parser.GetArgument(name);
                    const gsubthird = parser.GetArgument(name);
                    let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                    useArgument(parser, gsubresult);
                },


                //      This function modifies the equation numbers.
                SeteqnumberFunction(parser, name) {
                        //   Get the macro parameters
                        const star = parser.GetStar();                    // true if there is a *
                        const optBrackets = parser.GetBrackets(name);     // contents of optional brackets
                        const newsubequations = parser.GetArgument(name);    // the subequations argument
                        const neweqsection = parser.GetArgument(name);    // the eq section argument
                        const neweqnumber = parser.GetArgument(name);     // the eq number argument
                        MathJax.config.subequations=newsubequations ;     // a string with boolean meaning
                        MathJax.config.section=neweqsection ;             // a string with numeric meaning
                        parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                }


            });


            //      Create the Lwarp-macros package
            Configuration.create('Lwarp-macros', {
                handler: {macro: ['Lwarp-macros']}
            });


            MathJax.startup.defaultReady();


            // For forward references:
            MathJax.startup.input[0].preFilters.add(({math}) => {
                if (math.inputData.recompile){
                        MathJax.config.subequations = math.inputData.recompile.subequations;
                        MathJax.config.section = math.inputData.recompile.section;
                }
            });
            MathJax.startup.input[0].postFilters.add(({math}) => {
                if (math.inputData.recompile){
                        math.inputData.recompile.subequations = MathJax.config.subequations;
                        math.inputData.recompile.section = MathJax.config.section;
                }
            });


                // For \left, \right with unicode-math:
                const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                const {Symbol} = MathJax._.input.tex.Symbol;
                const {MapHandler} = MathJax._.input.tex.MapHandler;
                const delimiter = MapHandler.getMap('delimiter');
                delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
        }        // ready
    },           // startup


    tex: {
        packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
        tags: "ams",
                tagformat: {
                        number: function (n) {
                             if(MathJax.config.subequations==0)
                                 return(MathJax.config.section + n);
                             else
                                 return(MathJax.config.section + String.fromCharCode(96+n));
                        },
                },
    }
}
</script>


<script
        id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="lecnotes_html-autopage-7"></a>
<nav class="topnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="lecnotes_html.html" class="linkhome" >
Home</a>
</p>

</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<!--MathJax customizations:-->


<div class="hidden">

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\real }{\mathbb {R}} \)

\(\newcommand {\RR }{\mathbb {R}} \)

\(\newcommand {\ZZ }{\mathbb Z} \)

\(\newcommand {\F }{\mathbb F} \)

\(\newcommand {\Ham }{\mathrm {Ham}}\)

\(\newcommand {\PP }{\mathbb P}\)

\(\newcommand {\co }[1]{\overline {#1}} \)

\(\newcommand {\ul }[1]{\underline {#1}} \)

\(\newcommand {\bo }[1]{\mathbf {#1}} \)

\(\newcommand {\concat }[2]{[\, #1 \,|\, #2 \,]} \)

\(\newcommand {\Encode }{\texttt {ENCODE}} \)

\(\newcommand {\Decode }{\texttt {DECODE}} \)

\(\newcommand {\RM }{R} \)

\(\newcommand {\Rep }{\text {Rep}} \)

</div>

<p>
<!--
...... chapter ch12 ......
-->
<h3 id="autosec-8">Chapter&nbsp;<span class="sectionnumber">12&#x2003;</span>MATH32031 Coding Theory: end-of-semester revision 2023</h3>
<a id="lecnotes_html-autopage-8"></a>
<a id="lecnotes_html-autofile-32"></a>

<p>
Version 2022-12-12. <a href="lecnotes_html.pdf" target="_blank" >To PDF version of the notes</a>
</p>
<div class="center">

<p>
<b>See suggested answers and hints at end<br />
This list is not guaranteed to cover all possible topics that may arise in the exam. Your questions and suggestions are welcome; please post them to the Piazza discussion board or contact the lecturer during the
revision period.</b>
</p>
</div>

<p>
Suggested revision format: ask yourself <b><i>Can I...</i></b> followed by a question below. In case of difficulty/lack of confidence, revise the relevant part of the course material. Brief comments on a suggested approach are available below for
most questions. Questions marked (*) are more challenging: they have not been covered in the course but follow from lecture material or exercises.
</p>
<!--
...... section General codes ......
-->
<h4 id="autosec-10"><span class="sectionnumber">12.1&#x2003;</span>General codes</h4>
<a id="lecnotes_html-autopage-10"></a>


<p>
• <b>find the Hamming distance between two words</b>
</p>

<p>
• <b>find the minimum distance of a code with a small number of codewords</b>
</p>

<p>
• <b>given parameters \((n,M,d)_q\) of a code \(C\), find \([n,k,d]_q\) and the rate \(R\)</b>
</p>

<p>
• <b>given a code \(C\) as a list of codewords, decode a received word \(\ul y\)</b>
</p>

<p>
• <b>write down the parameters of a trivial code, of a repetition code</b>
</p>

<p>
• <b>given the minimum distance \(d\) of a code, write down the number of errors (per codeword) that the code can detect/correct</b>
</p>

<p>
• <b>write down the probability that \(i\) errors occur in a binary word of length \(n\) sent via BSC(\(p\))</b>
</p>
<!--
...... section Bounds ......
-->
<h4 id="autosec-11"><span class="sectionnumber">12.2&#x2003;</span>Bounds</h4>
<a id="lecnotes_html-autopage-11"></a>
<!--
...... subsection ...write down: ......
-->
<h5 id="autosec-12">...write down:</h5>
<a id="lecnotes_html-autopage-12"></a>


<p>
• <b>the Hamming bound for \(q\)-ary codes of length \(n\) and minimum distance \(d\)</b>
</p>

<p>
• <b>the Singleton bound?</b>
</p>
<!--
...... subsection ...calculate: ......
-->
<h5 id="autosec-13">...calculate:</h5>
<a id="lecnotes_html-autopage-13"></a>


<p>
• <b>the Hamming and Singleton bounds for a code with given parameters — and use these to check if the code is perfect/MDS?</b>
</p>
<!--
...... subsection ...give an example of: ......
-->
<h5 id="autosec-14">...give an example of:</h5>
<a id="lecnotes_html-autopage-14"></a>


<p>
• <b>perfect codes of minimum distance \(1\), \(3\), \(5\), \(7\), \(9\), \(\dots \)</b>
</p>
<!--
...... section Linear codes I ......
-->
<h4 id="autosec-15"><span class="sectionnumber">12.3&#x2003;</span>Linear codes I</h4>
<a id="lecnotes_html-autopage-15"></a>
<!--
...... subsection ...write down: ......
-->
<h5 id="autosec-16">...write down:</h5>
<a id="lecnotes_html-autopage-16"></a>


<p>
• <b>the parameters of \(E_n\) (with explanation)?</b>
</p>

<p>
• <b>the parameters of ISBN-10 (with explanation)?</b>
</p>

<p>
• <b>the weight enumerators of the trivial code, the repetition code, the code \(E_n\)?</b>
</p>

<p>
• <b>the special values of the weight enumerator: \(W_C(0,0)\), \(W_C(1,0)\), \(W_C(1,1)\)?</b>
</p>
<!--
...... section Linear codes II: encoding and decoding ......
-->
<h4 id="autosec-17"><span class="sectionnumber">12.4&#x2003;</span>Linear codes II: encoding and decoding</h4>
<a id="lecnotes_html-autopage-17"></a>


<p>
• <b>given a generator matrix \(G\) of a code \(C\), encode a message vector \(\ul u\). What is the number of rows/columns of \(G\)? What must be the length of \(\ul u\)? What do you get as the output of the
encoder?</b>
</p>
<!--
...... subsection ...calculate: ......
-->
<h5 id="autosec-18">...calculate:</h5>
<a id="lecnotes_html-autopage-18"></a>


<p>
• <b>a generator matrix in standard form for a given code?</b>
</p>

<p>
• <b>all the codevectors, and the weight enumerator of the linear code, if a generator matrix is given?</b>
</p>

<p>
• <b>\(P_{\text {undetect}}(C)\)? (what do you need to know to find it? for what codes and channels?)</b>
</p>

<p>
• <b>\(P_{\text {corr}}(C)\)? (what do you need to know to find it? for what codes and channels?)</b>
</p>
<!--
...... section Dual codes ......
-->
<h4 id="autosec-19"><span class="sectionnumber">12.5&#x2003;</span>Dual codes</h4>
<a id="lecnotes_html-autopage-19"></a>
<!--
...... subsection ...calculate: ......
-->
<h5 id="autosec-20">...calculate:</h5>
<a id="lecnotes_html-autopage-20"></a>


<p>
• <b>the inner product of two vectors?</b>
</p>

<p>
• <b>a check matrix of a given code? (what data do you need?)</b>
</p>

<p>
• <b>the dual code of the trivial/repetition/even weight/ISBN-10 code?</b>
</p>

<p>
• <b>the length and dimension of \(C^\perp \) if \(C\) has length \(n\), dimension \(k\)?</b>
</p>
<!--
...... subsection ...check: ......
-->
<h5 id="autosec-21">...check:</h5>
<a id="lecnotes_html-autopage-21"></a>


<p>
• <b>whether a given code is self-orthogonal? self-dual? (what data do you need?)</b>
</p>

<p>
• <b>calculate the syndrome of a vector? (what data do you need?)</b>
</p>

<p>
• <b>check if a given vector belongs to the code?</b>
</p>

<p>
• <b>construct a table of syndromes, and decode a received vector using your table?</b>
</p>

<p>
• <b>use the Average Weight Equation?</b>
</p>
<!--
...... section Hamming codes and simplex codes ......
-->
<h4 id="autosec-22"><span class="sectionnumber">12.6&#x2003;</span>Hamming codes and simplex codes</h4>
<a id="lecnotes_html-autopage-22"></a>
<!--
...... subsection ...write down: ......
-->
<h5 id="autosec-23">...write down:</h5>
<a id="lecnotes_html-autopage-23"></a>


<p>
• <b>the parameters of Ham(\(r,q\))?</b>
</p>

<p>
• <b>the weight of any non-zero codevector and the parameters of \(\Sigma (r,q)\)?</b>
</p>

<p>
• <b>the weight enumerator of \(\Sigma (r,q)\)?</b>
</p>
<!--
...... subsection ...construct: ......
-->
<h5 id="autosec-24">...construct:</h5>
<a id="lecnotes_html-autopage-24"></a>


<p>
• <b>a check matrix for \(\Ham (r,q)\) (\(q\) is a prime)? A generator matrix?</b>
</p>

<p>
• <b>given a check matrix for a Hamming code, decode a received vector?</b>
</p>
<!--
...... section Cyclic codes ......
-->
<h4 id="autosec-25"><span class="sectionnumber">12.7&#x2003;</span>Cyclic codes</h4>
<a id="lecnotes_html-autopage-25"></a>


<p>
• <b>write the given vector in \(\F _q^n\) as a polynomial, and a polynomial as a vector?</b>
</p>

<p>
• <b>given a (small) cyclic code \(C\), find the generator polynomial of \(C\)?</b>
</p>

<p>
• <b>carry out long division of polynomials?</b>
</p>
<!--
...... subsection ...calculate: ......
-->
<h5 id="autosec-26">...calculate:</h5>
<a id="lecnotes_html-autopage-26"></a>


<p>
• <b>the dimension of a cyclic code with a given generator polynomial?</b>
</p>

<p>
• <b>the check polynomial of a given cyclic code? (what do you need to know?)</b>
</p>

<p>
• <b>generator polynomials, check polynomials, generator matrices, check matrices of all possible cyclic codes in \(\mathbb F_q^n\)? (what do you need to know?)</b>
</p>
<!--
...... section Classification of perfect codes ......
-->
<h4 id="autosec-27"><span class="sectionnumber">12.8&#x2003;</span>Classification of perfect codes</h4>
<a id="lecnotes_html-autopage-27"></a>


<p>
• <b>write down the parameters of the Golay codes, and prove that the codes are perfect?</b>
</p>

<p>
• <b>use the Classification Theorem for perfect codes where \(q\) is a prime power?</b>
</p>
<!--
...... section Reed-Muller codes ......
-->
<h4 id="autosec-28"><span class="sectionnumber">12.9&#x2003;</span>Reed-Muller codes</h4>
<a id="lecnotes_html-autopage-28"></a>
<!--
...... subsection ...write down: ......
-->
<h5 id="autosec-29">...write down:</h5>
<a id="lecnotes_html-autopage-29"></a>


<p>
• <b>the parameters of \(\RM (r,m)\)?</b>
</p>
<a id="lecnotes_html-autofile-last"></a>
</section>

</main>

</div>


<nav class="botnavigation"><a href="lecnotes_html.html" class="linkhome" >
Home</a></nav>

</body>
</html>
